(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [888], {
        3096: function(t, e, i) {
            var n = "Expected a function",
                r = /^\s+|\s+$/g,
                s = /^[-+]0x[0-9a-f]+$/i,
                a = /^0b[01]+$/i,
                o = /^0o[0-7]+$/i,
                l = parseInt,
                h = "object" == typeof i.g && i.g && i.g.Object === Object && i.g,
                c = "object" == typeof self && self && self.Object === Object && self,
                u = h || c || Function("return this")(),
                d = Object.prototype.toString,
                p = Math.max,
                m = Math.min,
                f = function() {
                    return u.Date.now()
                };

            function g(t, e, i) {
                var r, s, a, o, l, h, c = 0,
                    u = !1,
                    d = !1,
                    g = !0;
                if ("function" != typeof t) throw new TypeError(n);

                function v(e) {
                    var i = r,
                        n = s;
                    return r = s = void 0, c = e, o = t.apply(n, i)
                }

                function _(t) {
                    return c = t, l = setTimeout(M, e), u ? v(t) : o
                }

                function b(t) {
                    var i = t - h;
                    return void 0 === h || i >= e || i < 0 || d && t - c >= a
                }

                function M() {
                    var t = f();
                    if (b(t)) return w(t);
                    l = setTimeout(M, function(t) {
                        var i = e - (t - h);
                        return d ? m(i, a - (t - c)) : i
                    }(t))
                }

                function w(t) {
                    return l = void 0, g && r ? v(t) : (r = s = void 0, o)
                }

                function S() {
                    var t = f(),
                        i = b(t);
                    if (r = arguments, s = this, h = t, i) {
                        if (void 0 === l) return _(h);
                        if (d) return l = setTimeout(M, e), v(h)
                    }
                    return void 0 === l && (l = setTimeout(M, e)), o
                }
                return e = x(e) || 0, y(i) && (u = !!i.leading, a = (d = "maxWait" in i) ? p(x(i.maxWait) || 0, e) : a, g = "trailing" in i ? !!i.trailing : g), S.cancel = function() {
                    void 0 !== l && clearTimeout(l), c = 0, r = h = s = l = void 0
                }, S.flush = function() {
                    return void 0 === l ? o : w(f())
                }, S
            }

            function y(t) {
                var e = typeof t;
                return !!t && ("object" == e || "function" == e)
            }

            function x(t) {
                if ("number" == typeof t) return t;
                if (function(t) {
                        return "symbol" == typeof t || function(t) {
                            return !!t && "object" == typeof t
                        }(t) && "[object Symbol]" == d.call(t)
                    }(t)) return NaN;
                if (y(t)) {
                    var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                    t = y(e) ? e + "" : e
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = t.replace(r, "");
                var i = a.test(t);
                return i || o.test(t) ? l(t.slice(2), i ? 2 : 8) : s.test(t) ? NaN : +t
            }
            t.exports = function(t, e, i) {
                var r = !0,
                    s = !0;
                if ("function" != typeof t) throw new TypeError(n);
                return y(i) && (r = "leading" in i ? !!i.leading : r, s = "trailing" in i ? !!i.trailing : s), g(t, e, {
                    leading: r,
                    maxWait: e,
                    trailing: s
                })
            }
        },
        1780: function(t, e, i) {
            (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function() {
                return i(8541)
            }])
        },
        1474: function(t, e, i) {
            "use strict";
            i.d(e, {
                Z: function() {
                    return r
                }
            });
            var n = i(5893);

            function r(t) {
                var e = t.name,
                    i = t.Icon,
                    r = t.color;
                return (0, n.jsxs)("div", {
                    className: "flex flex-col justify-center items-center p-4 w-[120px]",
                    children: [(0, n.jsx)("div", {
                        className: "hover:scale-[1.3] transition-all duration-300",
                        children: (0, n.jsx)(i, {
                            color: r,
                            size: 45
                        })
                    }), (0, n.jsx)("p", {
                        className: "text-bold p-2 text-xs",
                        children: e
                    })]
                })
            }
        },
        8541: function(t, e, i) {
            "use strict";
            i.r(e), i.d(e, {
                default: function() {
                    return id
                }
            });
            var n = i(5893),
                r = (i(6774), i(4051)),
                s = i.n(r),
                a = i(7294),
                o = (0, a.forwardRef)((function(t, e) {
                    var i = t.children,
                        r = t.loading;
                    return (0, n.jsxs)(n.Fragment, {
                        children: [(0, n.jsx)("div", {
                            className: "fixed flex justify-center items-center h-screen w-screen bg-black transition-all duration-[2500ms]",
                            children: (0, n.jsxs)("div", {
                                className: "".concat(r ? "opacity-100" : "opacity-0", " lds-ring absolute transition-all duration-1000"),
                                children: [(0, n.jsx)("div", {}), (0, n.jsx)("div", {}), (0, n.jsx)("div", {}), (0, n.jsx)("div", {})]
                            })
                        }), (0, n.jsx)("div", {
                            ref: e,
                            className: "fixed z-[100] flex justify-center items-center w-screen h-screen",
                            children: i
                        })]
                    })
                }));
            const l = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };
            const h = new class {
                constructor(t, e, i) {
                    const n = this;
                    let r, s = !1,
                        a = 0,
                        o = 0;
                    const l = [];
                    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                        o++, !1 === s && void 0 !== n.onStart && n.onStart(t, a, o), s = !0
                    }, this.itemEnd = function(t) {
                        a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (s = !1, void 0 !== n.onLoad && n.onLoad())
                    }, this.itemError = function(t) {
                        void 0 !== n.onError && n.onError(t)
                    }, this.resolveURL = function(t) {
                        return r ? r(t) : t
                    }, this.setURLModifier = function(t) {
                        return r = t, this
                    }, this.addHandler = function(t, e) {
                        return l.push(t, e), this
                    }, this.removeHandler = function(t) {
                        const e = l.indexOf(t);
                        return -1 !== e && l.splice(e, 2), this
                    }, this.getHandler = function(t) {
                        for (let e = 0, i = l.length; e < i; e += 2) {
                            const i = l[e],
                                n = l[e + 1];
                            if (i.global && (i.lastIndex = 0), i.test(t)) return n
                        }
                        return null
                    }
                }
            };
            class c {
                constructor(t) {
                    this.manager = void 0 !== t ? t : h, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(t, e) {
                    const i = this;
                    return new Promise((function(n, r) {
                        i.load(t, n, e, r)
                    }))
                }
                parse() {}
                setCrossOrigin(t) {
                    return this.crossOrigin = t, this
                }
                setWithCredentials(t) {
                    return this.withCredentials = t, this
                }
                setPath(t) {
                    return this.path = t, this
                }
                setResourcePath(t) {
                    return this.resourcePath = t, this
                }
                setRequestHeader(t) {
                    return this.requestHeader = t, this
                }
            }
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

            function u(t) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", t)
            }
            class d extends c {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = l.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const a = u("img");

                    function o() {
                        c(), l.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function h(e) {
                        c(), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }

                    function c() {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", h, !1)
                    }
                    return a.addEventListener("load", o, !1), a.addEventListener("error", h, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                }
            }
            class p {
                addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                }
                hasEventListener(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                }
                removeEventListener(t, e) {
                    if (void 0 === this._listeners) return;
                    const i = this._listeners[t];
                    if (void 0 !== i) {
                        const t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
                    }
                }
                dispatchEvent(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const i = e.slice(0);
                        for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
                        t.target = null
                    }
                }
            }
            const m = 1001,
                f = "srgb",
                g = "srgb-linear",
                y = 7680,
                x = [];
            for (let nd = 0; nd < 256; nd++) x[nd] = (nd < 16 ? "0" : "") + nd.toString(16);
            Math.PI, Math.PI;

            function v() {
                const t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0;
                return (x[255 & t] + x[t >> 8 & 255] + x[t >> 16 & 255] + x[t >> 24 & 255] + "-" + x[255 & e] + x[e >> 8 & 255] + "-" + x[e >> 16 & 15 | 64] + x[e >> 24 & 255] + "-" + x[63 & i | 128] + x[i >> 8 & 255] + "-" + x[i >> 16 & 255] + x[i >> 24 & 255] + x[255 & n] + x[n >> 8 & 255] + x[n >> 16 & 255] + x[n >> 24 & 255]).toLowerCase()
            }

            function _(t, e, i) {
                return Math.max(e, Math.min(i, t))
            }

            function b(t, e) {
                return (t % e + e) % e
            }

            function M(t, e, i) {
                return (1 - i) * t + i * e
            }
            class w {
                constructor(t = 0, e = 0) {
                    this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    const e = this.x,
                        i = this.y,
                        n = t.elements;
                    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    const i = Math.cos(e),
                        n = Math.sin(e),
                        r = this.x - t.x,
                        s = this.y - t.y;
                    return this.x = r * i - s * n + t.x, this.y = r * n + s * i + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            w.prototype.isVector2 = !0;
            class S {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, i, n, r, s, a, o, l) {
                    const h = this.elements;
                    return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = s, h[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(t) {
                    const e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        s = i[0],
                        a = i[3],
                        o = i[6],
                        l = i[1],
                        h = i[4],
                        c = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        m = n[0],
                        f = n[3],
                        g = n[6],
                        y = n[1],
                        x = n[4],
                        v = n[7],
                        _ = n[2],
                        b = n[5],
                        M = n[8];
                    return r[0] = s * m + a * y + o * _, r[3] = s * f + a * x + o * b, r[6] = s * g + a * v + o * M, r[1] = l * m + h * y + c * _, r[4] = l * f + h * x + c * b, r[7] = l * g + h * v + c * M, r[2] = u * m + d * y + p * _, r[5] = u * f + d * x + p * b, r[8] = u * g + d * v + p * M, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8];
                    return e * s * h - e * a * l - i * r * h + i * a * o + n * r * l - n * s * o
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8],
                        c = h * s - a * l,
                        u = a * o - h * r,
                        d = l * r - s * o,
                        p = e * c + i * u + n * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const m = 1 / p;
                    return t[0] = c * m, t[1] = (n * l - h * i) * m, t[2] = (a * i - n * s) * m, t[3] = u * m, t[4] = (h * e - n * o) * m, t[5] = (n * r - a * e) * m, t[6] = d * m, t[7] = (i * o - l * e) * m, t[8] = (s * e - i * r) * m, this
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose()
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, i, n, r, s, a) {
                    const o = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(i * o, i * l, -i * (o * s + l * a) + s + t, -n * l, n * o, -n * (-l * s + o * a) + a + e, 0, 0, 1), this
                }
                scale(t, e) {
                    const i = this.elements;
                    return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
                }
                rotate(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.elements,
                        r = n[0],
                        s = n[3],
                        a = n[6],
                        o = n[1],
                        l = n[4],
                        h = n[7];
                    return n[0] = e * r + i * o, n[3] = e * s + i * l, n[6] = e * a + i * h, n[1] = -i * r + e * o, n[4] = -i * s + e * l, n[7] = -i * a + e * h, this
                }
                translate(t, e) {
                    const i = this.elements;
                    return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
                }
                equals(t) {
                    const e = this.elements,
                        i = t.elements;
                    for (let n = 0; n < 9; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }

            function E(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function T(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            S.prototype.isMatrix3 = !0;
            const A = {
                    [f]: {
                        [g]: E
                    },
                    [g]: {
                        [f]: T
                    }
                },
                C = {
                    legacyMode: !0,
                    get workingColorSpace() {
                        return g
                    },
                    set workingColorSpace(t) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function(t, e, i) {
                        if (this.legacyMode || e === i || !e || !i) return t;
                        if (A[e] && void 0 !== A[e][i]) {
                            const n = A[e][i];
                            return t.r = n(t.r), t.g = n(t.g), t.b = n(t.b), t
                        }
                        throw new Error("Unsupported color space conversion.")
                    },
                    fromWorkingColorSpace: function(t, e) {
                        return this.convert(t, this.workingColorSpace, e)
                    },
                    toWorkingColorSpace: function(t, e) {
                        return this.convert(t, e, this.workingColorSpace)
                    }
                };
            let R;
            class L {
                constructor(t = null) {
                    this.uuid = v(), this.data = t, this.version = 0
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                    const i = {
                            uuid: this.uuid,
                            url: ""
                        },
                        n = this.data;
                    if (null !== n) {
                        let t;
                        if (Array.isArray(n)) {
                            t = [];
                            for (let e = 0, i = n.length; e < i; e++) n[e].isDataTexture ? t.push(P(n[e].image)) : t.push(P(n[e]))
                        } else t = P(n);
                        i.url = t
                    }
                    return e || (t.images[this.uuid] = i), i
                }
            }

            function P(t) {
                return "undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap ? class {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === R && (R = u("canvas")), R.width = t.width, R.height = t.height;
                            const i = R.getContext("2d");
                            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = R
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                    static sRGBToLinear(t) {
                        if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                            const e = u("canvas");
                            e.width = t.width, e.height = t.height;
                            const i = e.getContext("2d");
                            i.drawImage(t, 0, 0, t.width, t.height);
                            const n = i.getImageData(0, 0, t.width, t.height),
                                r = n.data;
                            for (let t = 0; t < r.length; t++) r[t] = 255 * E(r[t] / 255);
                            return i.putImageData(n, 0, 0), e
                        }
                        if (t.data) {
                            const e = t.data.slice(0);
                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * E(e[t] / 255)) : e[t] = E(e[t]);
                            return {
                                data: e,
                                width: t.width,
                                height: t.height
                            }
                        }
                        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                    }
                }.getDataURL(t) : t.data ? {
                    data: Array.prototype.slice.call(t.data),
                    width: t.width,
                    height: t.height,
                    type: t.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            L.prototype.isSource = !0;
            let z = 0;
            class D extends p {
                constructor(t = D.DEFAULT_IMAGE, e = D.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, h = 3e3) {
                    super(), Object.defineProperty(this, "id", {
                        value: z++
                    }), this.uuid = v(), this.name = "", this.source = new L(t), this.mipmaps = [], this.mapping = e, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new w(0, 0), this.repeat = new w(1, 1), this.center = new w(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new S, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                }
                get image() {
                    return this.source.data
                }
                set image(t) {
                    this.source.data = t
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(t).uuid,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case 1e3:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case m:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case 1002:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case 1e3:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case m:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case 1002:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
                set needsUpdate(t) {
                    !0 === t && (this.version++, this.source.needsUpdate = !0)
                }
            }
            D.DEFAULT_IMAGE = null, D.DEFAULT_MAPPING = 300, D.prototype.isTexture = !0;
            class I extends c {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    const r = new D,
                        s = new d(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                        r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                    }), i, n), r
                }
            }
            class N {
                constructor(t = 0, e = 0, i = 0, n = 1) {
                    this._x = t, this._y = e, this._z = i, this._w = n
                }
                static slerp(t, e, i, n) {
                    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(t, e, n)
                }
                static slerpFlat(t, e, i, n, r, s, a) {
                    let o = i[n + 0],
                        l = i[n + 1],
                        h = i[n + 2],
                        c = i[n + 3];
                    const u = r[s + 0],
                        d = r[s + 1],
                        p = r[s + 2],
                        m = r[s + 3];
                    if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = h, void(t[e + 3] = c);
                    if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                    if (c !== m || o !== u || l !== d || h !== p) {
                        let t = 1 - a;
                        const e = o * u + l * d + h * p + c * m,
                            i = e >= 0 ? 1 : -1,
                            n = 1 - e * e;
                        if (n > Number.EPSILON) {
                            const r = Math.sqrt(n),
                                s = Math.atan2(r, e * i);
                            t = Math.sin(t * s) / r, a = Math.sin(a * s) / r
                        }
                        const r = a * i;
                        if (o = o * t + u * r, l = l * t + d * r, h = h * t + p * r, c = c * t + m * r, t === 1 - a) {
                            const t = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
                            o *= t, l *= t, h *= t, c *= t
                        }
                    }
                    t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
                }
                static multiplyQuaternionsFlat(t, e, i, n, r, s) {
                    const a = i[n],
                        o = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        c = r[s],
                        u = r[s + 1],
                        d = r[s + 2],
                        p = r[s + 3];
                    return t[e] = a * p + h * c + o * d - l * u, t[e + 1] = o * p + h * u + l * c - a * d, t[e + 2] = l * p + h * d + a * u - o * c, t[e + 3] = h * p - a * c - o * u - l * d, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const i = t._x,
                        n = t._y,
                        r = t._z,
                        s = t._order,
                        a = Math.cos,
                        o = Math.sin,
                        l = a(i / 2),
                        h = a(n / 2),
                        c = a(r / 2),
                        u = o(i / 2),
                        d = o(n / 2),
                        p = o(r / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "YXZ":
                            this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        case "ZXY":
                            this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "ZYX":
                            this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        case "YZX":
                            this._x = u * h * c + l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "XZY":
                            this._x = u * h * c - l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    const i = e / 2,
                        n = Math.sin(i);
                    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        i = e[0],
                        n = e[4],
                        r = e[8],
                        s = e[1],
                        a = e[5],
                        o = e[9],
                        l = e[2],
                        h = e[6],
                        c = e[10],
                        u = i + a + c;
                    if (u > 0) {
                        const t = .5 / Math.sqrt(u + 1);
                        this._w = .25 / t, this._x = (h - o) * t, this._y = (r - l) * t, this._z = (s - n) * t
                    } else if (i > a && i > c) {
                        const t = 2 * Math.sqrt(1 + i - a - c);
                        this._w = (h - o) / t, this._x = .25 * t, this._y = (n + s) / t, this._z = (r + l) / t
                    } else if (a > c) {
                        const t = 2 * Math.sqrt(1 + a - i - c);
                        this._w = (r - l) / t, this._x = (n + s) / t, this._y = .25 * t, this._z = (o + h) / t
                    } else {
                        const t = 2 * Math.sqrt(1 + c - i - a);
                        this._w = (s - n) / t, this._x = (r + l) / t, this._y = (o + h) / t, this._z = .25 * t
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    let i = t.dot(e) + 1;
                    return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize()
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(_(this.dot(t), -1, 1)))
                }
                rotateTowards(t, e) {
                    const i = this.angleTo(t);
                    if (0 === i) return this;
                    const n = Math.min(1, e / i);
                    return this.slerp(t, n), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this)
                }
                multiplyQuaternions(t, e) {
                    const i = t._x,
                        n = t._y,
                        r = t._z,
                        s = t._w,
                        a = e._x,
                        o = e._y,
                        l = e._z,
                        h = e._w;
                    return this._x = i * h + s * a + n * l - r * o, this._y = n * h + s * o + r * a - i * l, this._z = r * h + s * l + i * o - n * a, this._w = s * h - i * a - n * o - r * l, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const i = this._x,
                        n = this._y,
                        r = this._z,
                        s = this._w;
                    let a = s * t._w + i * t._x + n * t._y + r * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                    const o = 1 - a * a;
                    if (o <= Number.EPSILON) {
                        const t = 1 - e;
                        return this._w = t * s + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(o),
                        h = Math.atan2(l, a),
                        c = Math.sin((1 - e) * h) / l,
                        u = Math.sin(e * h) / l;
                    return this._w = s * c + this._w * u, this._x = i * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this
                }
                slerpQuaternions(t, e, i) {
                    return this.copy(t).slerp(e, i)
                }
                random() {
                    const t = Math.random(),
                        e = Math.sqrt(1 - t),
                        i = Math.sqrt(t),
                        n = 2 * Math.PI * Math.random(),
                        r = 2 * Math.PI * Math.random();
                    return this.set(e * Math.cos(n), i * Math.sin(r), i * Math.cos(r), e * Math.sin(n))
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e = 0) {
                    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            N.prototype.isQuaternion = !0;
            class O {
                constructor(t = 0, e = 0, i = 0) {
                    this.x = t, this.y = e, this.z = i
                }
                set(t, e, i) {
                    return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                }
                applyEuler(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(H.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(H.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements,
                        s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                    return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s, this
                }
                applyQuaternion(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.x,
                        s = t.y,
                        a = t.z,
                        o = t.w,
                        l = o * e + s * n - a * i,
                        h = o * i + a * e - r * n,
                        c = o * n + r * i - s * e,
                        u = -r * e - s * i - a * n;
                    return this.x = l * o + u * -r + h * -a - c * -s, this.y = h * o + u * -s + c * -r - l * -a, this.z = c * o + u * -a + l * -s - h * -r, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
                }
                cross(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                }
                crossVectors(t, e) {
                    const i = t.x,
                        n = t.y,
                        r = t.z,
                        s = e.x,
                        a = e.y,
                        o = e.z;
                    return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const i = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(i)
                }
                projectOnPlane(t) {
                    return B.copy(this).projectOnVector(t), this.sub(B)
                }
                reflect(t) {
                    return this.sub(B.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const i = this.dot(t) / e;
                    return Math.acos(_(i, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        i = this.y - t.y,
                        n = this.z - t.z;
                    return e * e + i * i + n * n
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                }
                setFromSphericalCoords(t, e, i) {
                    const n = Math.sin(e) * t;
                    return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, i) {
                    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        i = this.setFromMatrixColumn(t, 1).length(),
                        n = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = i, this.z = n, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                setFromEuler(t) {
                    return this.x = t._x, this.y = t._y, this.z = t._z, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    const t = 2 * (Math.random() - .5),
                        e = Math.random() * Math.PI * 2,
                        i = Math.sqrt(1 - t ** 2);
                    return this.x = i * Math.cos(e), this.y = i * Math.sin(e), this.z = t, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            O.prototype.isVector3 = !0;
            const B = new O,
                H = new N;
            class U {
                constructor(t = new O(1 / 0, 1 / 0, 1 / 0), e = new O(-1 / 0, -1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.length; o < l; o += 3) {
                        const l = t[o],
                            h = t[o + 1],
                            c = t[o + 2];
                        l < e && (e = l), h < i && (i = h), c < n && (n = c), l > r && (r = l), h > s && (s = h), c > a && (a = c)
                    }
                    return this.min.set(e, i, n), this.max.set(r, s, a), this
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.count; o < l; o++) {
                        const l = t.getX(o),
                            h = t.getY(o),
                            c = t.getZ(o);
                        l < e && (e = l), h < i && (i = h), c < n && (n = c), l > r && (r = l), h > s && (s = h), c > a && (a = c)
                    }
                    return this.min.set(e, i, n), this.max.set(r, s, a), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const i = k.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                }
                setFromObject(t, e = !1) {
                    return this.makeEmpty(), this.expandByObject(t, e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(t, e = !1) {
                    t.updateWorldMatrix(!1, !1);
                    const i = t.geometry;
                    if (void 0 !== i)
                        if (e && void 0 != i.attributes && void 0 !== i.attributes.position) {
                            const e = i.attributes.position;
                            for (let i = 0, n = e.count; i < n; i++) k.fromBufferAttribute(e, i).applyMatrix4(t.matrixWorld), this.expandByPoint(k)
                        } else null === i.boundingBox && i.computeBoundingBox(), V.copy(i.boundingBox), V.applyMatrix4(t.matrixWorld), this.union(V);
                    const n = t.children;
                    for (let r = 0, s = n.length; r < s; r++) this.expandByObject(n[r], e);
                    return this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, k), k.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, i;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(J), Z.subVectors(this.max, J), G.subVectors(t.a, J), W.subVectors(t.b, J), j.subVectors(t.c, J), q.subVectors(W, G), X.subVectors(j, W), Y.subVectors(G, j);
                    let e = [0, -q.z, q.y, 0, -X.z, X.y, 0, -Y.z, Y.y, q.z, 0, -q.x, X.z, 0, -X.x, Y.z, 0, -Y.x, -q.y, q.x, 0, -X.y, X.x, 0, -Y.y, Y.x, 0];
                    return !!$(e, G, W, j, Z) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!$(e, G, W, j, Z) && (Q.crossVectors(q, X), e = [Q.x, Q.y, Q.z], $(e, G, W, j, Z)))
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return k.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                getBoundingSphere(t) {
                    return this.getCenter(t.center), t.radius = .5 * this.getSize(k).length(), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (F[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), F[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), F[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), F[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), F[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), F[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), F[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), F[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(F)), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            U.prototype.isBox3 = !0;
            const F = [new O, new O, new O, new O, new O, new O, new O, new O],
                k = new O,
                V = new U,
                G = new O,
                W = new O,
                j = new O,
                q = new O,
                X = new O,
                Y = new O,
                J = new O,
                Z = new O,
                Q = new O,
                K = new O;

            function $(t, e, i, n, r) {
                for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                    K.fromArray(t, s);
                    const a = r.x * Math.abs(K.x) + r.y * Math.abs(K.y) + r.z * Math.abs(K.z),
                        o = e.dot(K),
                        l = i.dot(K),
                        h = n.dot(K);
                    if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1
                }
                return !0
            }
            const tt = new U,
                et = new O,
                it = new O,
                nt = new O;
            class rt {
                constructor(t = new O, e = -1) {
                    this.center = t, this.radius = e
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    const i = this.center;
                    void 0 !== e ? i.copy(e) : tt.setFromPoints(t).getCenter(i);
                    let n = 0;
                    for (let r = 0, s = t.length; r < s; r++) n = Math.max(n, i.distanceToSquared(t[r]));
                    return this.radius = Math.sqrt(n), this
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    const i = this.center.distanceToSquared(t);
                    return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                expandByPoint(t) {
                    nt.subVectors(t, this.center);
                    const e = nt.lengthSq();
                    if (e > this.radius * this.radius) {
                        const t = Math.sqrt(e),
                            i = .5 * (t - this.radius);
                        this.center.add(nt.multiplyScalar(i / t)), this.radius += i
                    }
                    return this
                }
                union(t) {
                    return !0 === this.center.equals(t.center) ? it.set(0, 0, 1).multiplyScalar(t.radius) : it.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(et.copy(t.center).add(it)), this.expandByPoint(et.copy(t.center).sub(it)), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const st = new O,
                at = new O,
                ot = new O,
                lt = new O,
                ht = new O,
                ct = new O,
                ut = new O;
            class dt {
                constructor(t = new O, e = new O(0, 0, -1)) {
                    this.origin = t, this.direction = e
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, st)), this
                }
                closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    const i = e.dot(this.direction);
                    return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    const e = st.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (st.copy(this.direction).multiplyScalar(e).add(this.origin), st.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, i, n) {
                    at.copy(t).add(e).multiplyScalar(.5), ot.copy(e).sub(t).normalize(), lt.copy(this.origin).sub(at);
                    const r = .5 * t.distanceTo(e),
                        s = -this.direction.dot(ot),
                        a = lt.dot(this.direction),
                        o = -lt.dot(ot),
                        l = lt.lengthSq(),
                        h = Math.abs(1 - s * s);
                    let c, u, d, p;
                    if (h > 0)
                        if (c = s * o - a, u = s * a - o, p = r * h, c >= 0)
                            if (u >= -p)
                                if (u <= p) {
                                    const t = 1 / h;
                                    c *= t, u *= t, d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l
                                } else u = r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    else u = -r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    else u <= -p ? (c = Math.max(0, -(-s * r + a)), u = c > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l) : u <= p ? (c = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (c = Math.max(0, -(s * r + a)), u = c > 0 ? r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l);
                    else u = s > 0 ? -r : r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    return i && i.copy(this.direction).multiplyScalar(c).add(this.origin), n && n.copy(ot).multiplyScalar(u).add(at), d
                }
                intersectSphere(t, e) {
                    st.subVectors(t.center, this.origin);
                    const i = st.dot(this.direction),
                        n = st.dot(st) - i * i,
                        r = t.radius * t.radius;
                    if (n > r) return null;
                    const s = Math.sqrt(r - n),
                        a = i - s,
                        o = i + s;
                    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const i = -(this.origin.dot(t.normal) + t.constant) / e;
                    return i >= 0 ? i : null
                }
                intersectPlane(t, e) {
                    const i = this.distanceToPlane(t);
                    return null === i ? null : this.at(i, e)
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    return t.normal.dot(this.direction) * e < 0
                }
                intersectBox(t, e) {
                    let i, n, r, s, a, o;
                    const l = 1 / this.direction.x,
                        h = 1 / this.direction.y,
                        c = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, s = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, s = (t.min.y - u.y) * h), i > s || r > n ? null : ((r > i || i !== i) && (i = r), (s < n || n !== n) && (n = s), c >= 0 ? (a = (t.min.z - u.z) * c, o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, o = (t.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i !== i) && (i = a), (o < n || n !== n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, st)
                }
                intersectTriangle(t, e, i, n, r) {
                    ht.subVectors(e, t), ct.subVectors(i, t), ut.crossVectors(ht, ct);
                    let s, a = this.direction.dot(ut);
                    if (a > 0) {
                        if (n) return null;
                        s = 1
                    } else {
                        if (!(a < 0)) return null;
                        s = -1, a = -a
                    }
                    lt.subVectors(this.origin, t);
                    const o = s * this.direction.dot(ct.crossVectors(lt, ct));
                    if (o < 0) return null;
                    const l = s * this.direction.dot(ht.cross(lt));
                    if (l < 0) return null;
                    if (o + l > a) return null;
                    const h = -s * lt.dot(ut);
                    return h < 0 ? null : this.at(h / a, r)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class pt {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
                    const g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new pt).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                }
                copyPosition(t) {
                    const e = this.elements,
                        i = t.elements;
                    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                }
                setFromMatrix3(t) {
                    const e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                }
                makeBasis(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    const e = this.elements,
                        i = t.elements,
                        n = 1 / mt.setFromMatrixColumn(t, 0).length(),
                        r = 1 / mt.setFromMatrixColumn(t, 1).length(),
                        s = 1 / mt.setFromMatrixColumn(t, 2).length();
                    return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * s, e[9] = i[9] * s, e[10] = i[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z,
                        s = Math.cos(i),
                        a = Math.sin(i),
                        o = Math.cos(n),
                        l = Math.sin(n),
                        h = Math.cos(r),
                        c = Math.sin(r);
                    if ("XYZ" === t.order) {
                        const t = s * h,
                            i = s * c,
                            n = a * h,
                            r = a * c;
                        e[0] = o * h, e[4] = -o * c, e[8] = l, e[1] = i + n * l, e[5] = t - r * l, e[9] = -a * o, e[2] = r - t * l, e[6] = n + i * l, e[10] = s * o
                    } else if ("YXZ" === t.order) {
                        const t = o * h,
                            i = o * c,
                            n = l * h,
                            r = l * c;
                        e[0] = t + r * a, e[4] = n * a - i, e[8] = s * l, e[1] = s * c, e[5] = s * h, e[9] = -a, e[2] = i * a - n, e[6] = r + t * a, e[10] = s * o
                    } else if ("ZXY" === t.order) {
                        const t = o * h,
                            i = o * c,
                            n = l * h,
                            r = l * c;
                        e[0] = t - r * a, e[4] = -s * c, e[8] = n + i * a, e[1] = i + n * a, e[5] = s * h, e[9] = r - t * a, e[2] = -s * l, e[6] = a, e[10] = s * o
                    } else if ("ZYX" === t.order) {
                        const t = s * h,
                            i = s * c,
                            n = a * h,
                            r = a * c;
                        e[0] = o * h, e[4] = n * l - i, e[8] = t * l + r, e[1] = o * c, e[5] = r * l + t, e[9] = i * l - n, e[2] = -l, e[6] = a * o, e[10] = s * o
                    } else if ("YZX" === t.order) {
                        const t = s * o,
                            i = s * l,
                            n = a * o,
                            r = a * l;
                        e[0] = o * h, e[4] = r - t * c, e[8] = n * c + i, e[1] = c, e[5] = s * h, e[9] = -a * h, e[2] = -l * h, e[6] = i * c + n, e[10] = t - r * c
                    } else if ("XZY" === t.order) {
                        const t = s * o,
                            i = s * l,
                            n = a * o,
                            r = a * l;
                        e[0] = o * h, e[4] = -c, e[8] = l * h, e[1] = t * c + r, e[5] = s * h, e[9] = i * c - n, e[2] = n * c - i, e[6] = a * h, e[10] = r * c + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(gt, t, yt)
                }
                lookAt(t, e, i) {
                    const n = this.elements;
                    return _t.subVectors(t, e), 0 === _t.lengthSq() && (_t.z = 1), _t.normalize(), xt.crossVectors(i, _t), 0 === xt.lengthSq() && (1 === Math.abs(i.z) ? _t.x += 1e-4 : _t.z += 1e-4, _t.normalize(), xt.crossVectors(i, _t)), xt.normalize(), vt.crossVectors(_t, xt), n[0] = xt.x, n[4] = vt.x, n[8] = _t.x, n[1] = xt.y, n[5] = vt.y, n[9] = _t.y, n[2] = xt.z, n[6] = vt.z, n[10] = _t.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        s = i[0],
                        a = i[4],
                        o = i[8],
                        l = i[12],
                        h = i[1],
                        c = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        m = i[6],
                        f = i[10],
                        g = i[14],
                        y = i[3],
                        x = i[7],
                        v = i[11],
                        _ = i[15],
                        b = n[0],
                        M = n[4],
                        w = n[8],
                        S = n[12],
                        E = n[1],
                        T = n[5],
                        A = n[9],
                        C = n[13],
                        R = n[2],
                        L = n[6],
                        P = n[10],
                        z = n[14],
                        D = n[3],
                        I = n[7],
                        N = n[11],
                        O = n[15];
                    return r[0] = s * b + a * E + o * R + l * D, r[4] = s * M + a * T + o * L + l * I, r[8] = s * w + a * A + o * P + l * N, r[12] = s * S + a * C + o * z + l * O, r[1] = h * b + c * E + u * R + d * D, r[5] = h * M + c * T + u * L + d * I, r[9] = h * w + c * A + u * P + d * N, r[13] = h * S + c * C + u * z + d * O, r[2] = p * b + m * E + f * R + g * D, r[6] = p * M + m * T + f * L + g * I, r[10] = p * w + m * A + f * P + g * N, r[14] = p * S + m * C + f * z + g * O, r[3] = y * b + x * E + v * R + _ * D, r[7] = y * M + x * T + v * L + _ * I, r[11] = y * w + x * A + v * P + _ * N, r[15] = y * S + x * C + v * z + _ * O, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        i = t[4],
                        n = t[8],
                        r = t[12],
                        s = t[1],
                        a = t[5],
                        o = t[9],
                        l = t[13],
                        h = t[2],
                        c = t[6],
                        u = t[10],
                        d = t[14];
                    return t[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + t[11] * (+e * l * c - e * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + t[15] * (-n * a * h - e * o * c + e * a * u + n * s * c - i * s * u + i * o * h)
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(t, e, i) {
                    const n = this.elements;
                    return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8],
                        c = t[9],
                        u = t[10],
                        d = t[11],
                        p = t[12],
                        m = t[13],
                        f = t[14],
                        g = t[15],
                        y = c * f * l - m * u * l + m * o * d - a * f * d - c * o * g + a * u * g,
                        x = p * u * l - h * f * l - p * o * d + s * f * d + h * o * g - s * u * g,
                        v = h * m * l - p * c * l + p * a * d - s * m * d - h * a * g + s * c * g,
                        _ = p * c * o - h * m * o - p * a * u + s * m * u + h * a * f - s * c * f,
                        b = e * y + i * x + n * v + r * _;
                    if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const M = 1 / b;
                    return t[0] = y * M, t[1] = (m * u * r - c * f * r - m * n * d + i * f * d + c * n * g - i * u * g) * M, t[2] = (a * f * r - m * o * r + m * n * l - i * f * l - a * n * g + i * o * g) * M, t[3] = (c * o * r - a * u * r - c * n * l + i * u * l + a * n * d - i * o * d) * M, t[4] = x * M, t[5] = (h * f * r - p * u * r + p * n * d - e * f * d - h * n * g + e * u * g) * M, t[6] = (p * o * r - s * f * r - p * n * l + e * f * l + s * n * g - e * o * g) * M, t[7] = (s * u * r - h * o * r + h * n * l - e * u * l - s * n * d + e * o * d) * M, t[8] = v * M, t[9] = (p * c * r - h * m * r - p * i * d + e * m * d + h * i * g - e * c * g) * M, t[10] = (s * m * r - p * a * r + p * i * l - e * m * l - s * i * g + e * a * g) * M, t[11] = (h * a * r - s * c * r - h * i * l + e * c * l + s * i * d - e * a * d) * M, t[12] = _ * M, t[13] = (h * m * n - p * c * n + p * i * u - e * m * u - h * i * f + e * c * f) * M, t[14] = (p * a * n - s * m * n - p * i * o + e * m * o + s * i * f - e * a * f) * M, t[15] = (s * c * n - h * a * n + h * i * o - e * c * o - s * i * u + e * a * u) * M, this
                }
                scale(t) {
                    const e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z;
                    return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, i, n))
                }
                makeTranslation(t, e, i) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    const i = Math.cos(e),
                        n = Math.sin(e),
                        r = 1 - i,
                        s = t.x,
                        a = t.y,
                        o = t.z,
                        l = r * s,
                        h = r * a;
                    return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, h * a + i, h * o - n * s, 0, l * o - n * a, h * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, i, n, r, s) {
                    return this.set(1, i, r, 0, t, 1, s, 0, e, n, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, i) {
                    const n = this.elements,
                        r = e._x,
                        s = e._y,
                        a = e._z,
                        o = e._w,
                        l = r + r,
                        h = s + s,
                        c = a + a,
                        u = r * l,
                        d = r * h,
                        p = r * c,
                        m = s * h,
                        f = s * c,
                        g = a * c,
                        y = o * l,
                        x = o * h,
                        v = o * c,
                        _ = i.x,
                        b = i.y,
                        M = i.z;
                    return n[0] = (1 - (m + g)) * _, n[1] = (d + v) * _, n[2] = (p - x) * _, n[3] = 0, n[4] = (d - v) * b, n[5] = (1 - (u + g)) * b, n[6] = (f + y) * b, n[7] = 0, n[8] = (p + x) * M, n[9] = (f - y) * M, n[10] = (1 - (u + m)) * M, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                }
                decompose(t, e, i) {
                    const n = this.elements;
                    let r = mt.set(n[0], n[1], n[2]).length();
                    const s = mt.set(n[4], n[5], n[6]).length(),
                        a = mt.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], ft.copy(this);
                    const o = 1 / r,
                        l = 1 / s,
                        h = 1 / a;
                    return ft.elements[0] *= o, ft.elements[1] *= o, ft.elements[2] *= o, ft.elements[4] *= l, ft.elements[5] *= l, ft.elements[6] *= l, ft.elements[8] *= h, ft.elements[9] *= h, ft.elements[10] *= h, e.setFromRotationMatrix(ft), i.x = r, i.y = s, i.z = a, this
                }
                makePerspective(t, e, i, n, r, s) {
                    void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const a = this.elements,
                        o = 2 * r / (e - t),
                        l = 2 * r / (i - n),
                        h = (e + t) / (e - t),
                        c = (i + n) / (i - n),
                        u = -(s + r) / (s - r),
                        d = -2 * s * r / (s - r);
                    return a[0] = o, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = l, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                }
                makeOrthographic(t, e, i, n, r, s) {
                    const a = this.elements,
                        o = 1 / (e - t),
                        l = 1 / (i - n),
                        h = 1 / (s - r),
                        c = (e + t) * o,
                        u = (i + n) * l,
                        d = (s + r) * h;
                    return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                }
                equals(t) {
                    const e = this.elements,
                        i = t.elements;
                    for (let n = 0; n < 16; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                }
            }
            pt.prototype.isMatrix4 = !0;
            const mt = new O,
                ft = new pt,
                gt = new O(0, 0, 0),
                yt = new O(1, 1, 1),
                xt = new O,
                vt = new O,
                _t = new O,
                bt = new pt,
                Mt = new N;
            class wt {
                constructor(t = 0, e = 0, i = 0, n = wt.DefaultOrder) {
                    this._x = t, this._y = e, this._z = i, this._order = n
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, i, n = this._order) {
                    return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e = this._order, i = !0) {
                    const n = t.elements,
                        r = n[0],
                        s = n[4],
                        a = n[8],
                        o = n[1],
                        l = n[5],
                        h = n[9],
                        c = n[2],
                        u = n[6],
                        d = n[10];
                    switch (e) {
                        case "XYZ":
                            this._y = Math.asin(_(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-_(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, r), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(_(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-_(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(_(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-_(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, d), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !0 === i && this._onChangeCallback(), this
                }
                setFromQuaternion(t, e, i) {
                    return bt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(bt, e, i)
                }
                setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e)
                }
                reorder(t) {
                    return Mt.setFromEuler(this), this.setFromQuaternion(Mt, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            wt.prototype.isEuler = !0, wt.DefaultOrder = "XYZ", wt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class St {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = (1 << t | 0) >>> 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return 0 !== (this.mask & t.mask)
                }
                isEnabled(t) {
                    return 0 !== (this.mask & (1 << t | 0))
                }
            }
            let Et = 0;
            const Tt = new O,
                At = new N,
                Ct = new pt,
                Rt = new O,
                Lt = new O,
                Pt = new O,
                zt = new N,
                Dt = new O(1, 0, 0),
                It = new O(0, 1, 0),
                Nt = new O(0, 0, 1),
                Ot = {
                    type: "added"
                },
                Bt = {
                    type: "removed"
                };
            class Ht extends p {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Et++
                    }), this.uuid = v(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ht.DefaultUp.clone();
                    const t = new O,
                        e = new wt,
                        i = new N,
                        n = new O(1, 1, 1);
                    e._onChange((function() {
                        i.setFromEuler(e, !1)
                    })), i._onChange((function() {
                        e.setFromQuaternion(i, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        modelViewMatrix: {
                            value: new pt
                        },
                        normalMatrix: {
                            value: new S
                        }
                    }), this.matrix = new pt, this.matrixWorld = new pt, this.matrixAutoUpdate = Ht.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new St, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(t) {
                    return this.quaternion.premultiply(t), this
                }
                setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                }
                setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0)
                }
                setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t)
                }
                setRotationFromQuaternion(t) {
                    this.quaternion.copy(t)
                }
                rotateOnAxis(t, e) {
                    return At.setFromAxisAngle(t, e), this.quaternion.multiply(At), this
                }
                rotateOnWorldAxis(t, e) {
                    return At.setFromAxisAngle(t, e), this.quaternion.premultiply(At), this
                }
                rotateX(t) {
                    return this.rotateOnAxis(Dt, t)
                }
                rotateY(t) {
                    return this.rotateOnAxis(It, t)
                }
                rotateZ(t) {
                    return this.rotateOnAxis(Nt, t)
                }
                translateOnAxis(t, e) {
                    return Tt.copy(t).applyQuaternion(this.quaternion), this.position.add(Tt.multiplyScalar(e)), this
                }
                translateX(t) {
                    return this.translateOnAxis(Dt, t)
                }
                translateY(t) {
                    return this.translateOnAxis(It, t)
                }
                translateZ(t) {
                    return this.translateOnAxis(Nt, t)
                }
                localToWorld(t) {
                    return t.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(t) {
                    return t.applyMatrix4(Ct.copy(this.matrixWorld).invert())
                }
                lookAt(t, e, i) {
                    t.isVector3 ? Rt.copy(t) : Rt.set(t, e, i);
                    const n = this.parent;
                    this.updateWorldMatrix(!0, !1), Lt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ct.lookAt(Lt, Rt, this.up) : Ct.lookAt(Rt, Lt, this.up), this.quaternion.setFromRotationMatrix(Ct), n && (Ct.extractRotation(n.matrixWorld), At.setFromRotationMatrix(Ct), this.quaternion.premultiply(At.invert()))
                }
                add(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ot)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                }
                remove(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Bt)), this
                }
                removeFromParent() {
                    const t = this.parent;
                    return null !== t && t.remove(this), this
                }
                clear() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        e.parent = null, e.dispatchEvent(Bt)
                    }
                    return this.children.length = 0, this
                }
                attach(t) {
                    return this.updateWorldMatrix(!0, !1), Ct.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ct.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ct), this.add(t), t.updateWorldMatrix(!1, !0), this
                }
                getObjectById(t) {
                    return this.getObjectByProperty("id", t)
                }
                getObjectByName(t) {
                    return this.getObjectByProperty("name", t)
                }
                getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let i = 0, n = this.children.length; i < n; i++) {
                        const n = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== n) return n
                    }
                }
                getWorldPosition(t) {
                    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Lt, t, Pt), t
                }
                getWorldScale(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Lt, zt, t), t
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                }
                raycast() {}
                traverse(t) {
                    t(this);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                }
                traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
                traverseAncestors(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                }
                updateWorldMatrix(t, e) {
                    const i = this.parent;
                    if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                        const t = this.children;
                        for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t,
                        i = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, i.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const n = {};

                    function r(e, i) {
                        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = r(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const i = e.shapes;
                            if (Array.isArray(i))
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    r(t.shapes, n)
                                } else r(t.shapes, i)
                        }
                    }
                    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let i = 0, n = this.material.length; i < n; i++) e.push(r(t.materials, this.material[i]));
                            n.material = e
                        } else n.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        n.children = [];
                        for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object)
                    }
                    if (this.animations.length > 0) {
                        n.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            const i = this.animations[e];
                            n.animations.push(r(t.animations, i))
                        }
                    }
                    if (e) {
                        const e = s(t.geometries),
                            n = s(t.materials),
                            r = s(t.textures),
                            a = s(t.images),
                            o = s(t.shapes),
                            l = s(t.skeletons),
                            h = s(t.animations),
                            c = s(t.nodes);
                        e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), h.length > 0 && (i.animations = h), c.length > 0 && (i.nodes = c)
                    }
                    return i.object = n, i;

                    function s(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                }
                clone(t) {
                    return (new this.constructor).copy(this, t)
                }
                copy(t, e = !0) {
                    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (let i = 0; i < t.children.length; i++) {
                            const e = t.children[i];
                            this.add(e.clone())
                        }
                    return this
                }
            }
            Ht.DefaultUp = new O(0, 1, 0), Ht.DefaultMatrixAutoUpdate = !0, Ht.prototype.isObject3D = !0;
            const Ut = new O,
                Ft = new O,
                kt = new O,
                Vt = new O,
                Gt = new O,
                Wt = new O,
                jt = new O,
                qt = new O,
                Xt = new O,
                Yt = new O;
            class Jt {
                constructor(t = new O, e = new O, i = new O) {
                    this.a = t, this.b = e, this.c = i
                }
                static getNormal(t, e, i, n) {
                    n.subVectors(i, e), Ut.subVectors(t, e), n.cross(Ut);
                    const r = n.lengthSq();
                    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                }
                static getBarycoord(t, e, i, n, r) {
                    Ut.subVectors(n, e), Ft.subVectors(i, e), kt.subVectors(t, e);
                    const s = Ut.dot(Ut),
                        a = Ut.dot(Ft),
                        o = Ut.dot(kt),
                        l = Ft.dot(Ft),
                        h = Ft.dot(kt),
                        c = s * l - a * a;
                    if (0 === c) return r.set(-2, -1, -1);
                    const u = 1 / c,
                        d = (l * o - a * h) * u,
                        p = (s * h - a * o) * u;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(t, e, i, n) {
                    return this.getBarycoord(t, e, i, n, Vt), Vt.x >= 0 && Vt.y >= 0 && Vt.x + Vt.y <= 1
                }
                static getUV(t, e, i, n, r, s, a, o) {
                    return this.getBarycoord(t, e, i, n, Vt), o.set(0, 0), o.addScaledVector(r, Vt.x), o.addScaledVector(s, Vt.y), o.addScaledVector(a, Vt.z), o
                }
                static isFrontFacing(t, e, i, n) {
                    return Ut.subVectors(i, e), Ft.subVectors(t, e), Ut.cross(Ft).dot(n) < 0
                }
                set(t, e, i) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                }
                setFromPointsAndIndices(t, e, i, n) {
                    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                }
                setFromAttributeAndIndices(t, e, i, n) {
                    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return Ut.subVectors(this.c, this.b), Ft.subVectors(this.a, this.b), .5 * Ut.cross(Ft).length()
                }
                getMidpoint(t) {
                    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return Jt.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return Jt.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getUV(t, e, i, n, r) {
                    return Jt.getUV(t, this.a, this.b, this.c, e, i, n, r)
                }
                containsPoint(t) {
                    return Jt.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return Jt.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(t, e) {
                    const i = this.a,
                        n = this.b,
                        r = this.c;
                    let s, a;
                    Gt.subVectors(n, i), Wt.subVectors(r, i), qt.subVectors(t, i);
                    const o = Gt.dot(qt),
                        l = Wt.dot(qt);
                    if (o <= 0 && l <= 0) return e.copy(i);
                    Xt.subVectors(t, n);
                    const h = Gt.dot(Xt),
                        c = Wt.dot(Xt);
                    if (h >= 0 && c <= h) return e.copy(n);
                    const u = o * c - h * l;
                    if (u <= 0 && o >= 0 && h <= 0) return s = o / (o - h), e.copy(i).addScaledVector(Gt, s);
                    Yt.subVectors(t, r);
                    const d = Gt.dot(Yt),
                        p = Wt.dot(Yt);
                    if (p >= 0 && d <= p) return e.copy(r);
                    const m = d * l - o * p;
                    if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(i).addScaledVector(Wt, a);
                    const f = h * p - d * c;
                    if (f <= 0 && c - h >= 0 && d - p >= 0) return jt.subVectors(r, n), a = (c - h) / (c - h + (d - p)), e.copy(n).addScaledVector(jt, a);
                    const g = 1 / (f + m + u);
                    return s = m * g, a = u * g, e.copy(i).addScaledVector(Gt, s).addScaledVector(Wt, a)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            let Zt = 0;
            class Qt extends p {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Zt++
                    }), this.uuid = v(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = y, this.stencilZFail = y, this.stencilZPass = y, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(t) {
                    this._alphaTest > 0 !== t > 0 && this.version++, this._alphaTest = t
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const i = t[e];
                            if (void 0 === i) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === e) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                                continue
                            }
                            const n = this[e];
                            void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        }
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    const i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function n(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
                        const e = n(t.textures),
                            r = n(t.images);
                        e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r)
                    }
                    return i
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    const e = t.clippingPlanes;
                    let i = null;
                    if (null !== e) {
                        const t = e.length;
                        i = new Array(t);
                        for (let n = 0; n !== t; ++n) i[n] = e[n].clone()
                    }
                    return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
            }
            Qt.prototype.isMaterial = !0, Qt.fromType = function() {
                return null
            };
            const Kt = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                $t = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                te = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                ee = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function ie(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }

            function ne(t, e) {
                return e.r = t.r, e.g = t.g, e.b = t.b, e
            }
            class re {
                constructor(t, e, i) {
                    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t, e = "srgb") {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, C.toWorkingColorSpace(this, e), this
                }
                setRGB(t, e, i, n = "srgb-linear") {
                    return this.r = t, this.g = e, this.b = i, C.toWorkingColorSpace(this, n), this
                }
                setHSL(t, e, i, n = "srgb-linear") {
                    if (t = b(t, 1), e = _(e, 0, 1), i = _(i, 0, 1), 0 === e) this.r = this.g = this.b = i;
                    else {
                        const n = i <= .5 ? i * (1 + e) : i + e - i * e,
                            r = 2 * i - n;
                        this.r = ie(r, n, t + 1 / 3), this.g = ie(r, n, t), this.b = ie(r, n, t - 1 / 3)
                    }
                    return C.toWorkingColorSpace(this, n), this
                }
                setStyle(t, e = "srgb") {
                    function i(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    let n;
                    if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                        let t;
                        const r = n[1],
                            s = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, C.toWorkingColorSpace(this, e), i(t[4]), this;
                                if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, C.toWorkingColorSpace(this, e), i(t[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                    const n = parseFloat(t[1]) / 360,
                                        r = parseInt(t[2], 10) / 100,
                                        s = parseInt(t[3], 10) / 100;
                                    return i(t[4]), this.setHSL(n, r, s, e)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                        const t = n[1],
                            i = t.length;
                        if (3 === i) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, C.toWorkingColorSpace(this, e), this;
                        if (6 === i) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, C.toWorkingColorSpace(this, e), this
                    }
                    return t && t.length > 0 ? this.setColorName(t, e) : this
                }
                setColorName(t, e = "srgb") {
                    const i = Kt[t.toLowerCase()];
                    return void 0 !== i ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copySRGBToLinear(t) {
                    return this.r = E(t.r), this.g = E(t.g), this.b = E(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = T(t.r), this.g = T(t.g), this.b = T(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(t = "srgb") {
                    return C.fromWorkingColorSpace(ne(this, $t), t), _(255 * $t.r, 0, 255) << 16 ^ _(255 * $t.g, 0, 255) << 8 ^ _(255 * $t.b, 0, 255) << 0
                }
                getHexString(t = "srgb") {
                    return ("000000" + this.getHex(t).toString(16)).slice(-6)
                }
                getHSL(t, e = "srgb-linear") {
                    C.fromWorkingColorSpace(ne(this, $t), e);
                    const i = $t.r,
                        n = $t.g,
                        r = $t.b,
                        s = Math.max(i, n, r),
                        a = Math.min(i, n, r);
                    let o, l;
                    const h = (a + s) / 2;
                    if (a === s) o = 0, l = 0;
                    else {
                        const t = s - a;
                        switch (l = h <= .5 ? t / (s + a) : t / (2 - s - a), s) {
                            case i:
                                o = (n - r) / t + (n < r ? 6 : 0);
                                break;
                            case n:
                                o = (r - i) / t + 2;
                                break;
                            case r:
                                o = (i - n) / t + 4
                        }
                        o /= 6
                    }
                    return t.h = o, t.s = l, t.l = h, t
                }
                getRGB(t, e = "srgb-linear") {
                    return C.fromWorkingColorSpace(ne(this, $t), e), t.r = $t.r, t.g = $t.g, t.b = $t.b, t
                }
                getStyle(t = "srgb") {
                    return C.fromWorkingColorSpace(ne(this, $t), t), t !== f ? `color(${t} ${$t.r} ${$t.g} ${$t.b})` : `rgb(${255*$t.r|0},${255*$t.g|0},${255*$t.b|0})`
                }
                offsetHSL(t, e, i) {
                    return this.getHSL(te), te.h += t, te.s += e, te.l += i, this.setHSL(te.h, te.s, te.l), this
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpColors(t, e, i) {
                    return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this
                }
                lerpHSL(t, e) {
                    this.getHSL(te), t.getHSL(ee);
                    const i = M(te.h, ee.h, e),
                        n = M(te.s, ee.s, e),
                        r = M(te.l, ee.l, e);
                    return this.setHSL(i, n, r), this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e = 0) {
                    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            re.NAMES = Kt, re.prototype.isColor = !0, re.prototype.r = 1, re.prototype.g = 1, re.prototype.b = 1;
            class se extends Qt {
                constructor(t) {
                    super(), this.type = "MeshBasicMaterial", this.color = new re(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                }
            }
            se.prototype.isMeshBasicMaterial = !0;
            class ae {
                constructor(t = 0, e = 0, i = 0, n = 1) {
                    this.x = t, this.y = e, this.z = i, this.w = n
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, i, n) {
                    return this.x = t, this.y = e, this.z = i, this.w = n, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        s = t.elements;
                    return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, i, n, r;
                    const s = .01,
                        a = .1,
                        o = t.elements,
                        l = o[0],
                        h = o[4],
                        c = o[8],
                        u = o[1],
                        d = o[5],
                        p = o[9],
                        m = o[2],
                        f = o[6],
                        g = o[10];
                    if (Math.abs(h - u) < s && Math.abs(c - m) < s && Math.abs(p - f) < s) {
                        if (Math.abs(h + u) < a && Math.abs(c + m) < a && Math.abs(p + f) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (l + 1) / 2,
                            o = (d + 1) / 2,
                            y = (g + 1) / 2,
                            x = (h + u) / 4,
                            v = (c + m) / 4,
                            _ = (p + f) / 4;
                        return t > o && t > y ? t < s ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(t), n = x / i, r = v / i) : o > y ? o < s ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(o), i = x / n, r = _ / n) : y < s ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(y), i = v / r, n = _ / r), this.set(i, n, r, e), this
                    }
                    let y = Math.sqrt((f - p) * (f - p) + (c - m) * (c - m) + (u - h) * (u - h));
                    return Math.abs(y) < .001 && (y = 1), this.x = (f - p) / y, this.y = (c - m) / y, this.z = (u - h) / y, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            ae.prototype.isVector4 = !0;
            const oe = new O,
                le = new w;
            class he {
                constructor(t, e, i) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.usage = 35044, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                copy(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                }
                copyAt(t, e, i) {
                    t *= this.itemSize, i *= e.itemSize;
                    for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                }
                copyArray(t) {
                    return this.array.set(t), this
                }
                copyColorsArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), r = new re), e[i++] = r.r, e[i++] = r.g, e[i++] = r.b
                    }
                    return this
                }
                copyVector2sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), r = new w), e[i++] = r.x, e[i++] = r.y
                    }
                    return this
                }
                copyVector3sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), r = new O), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z
                    }
                    return this
                }
                copyVector4sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), r = new ae), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z, e[i++] = r.w
                    }
                    return this
                }
                applyMatrix3(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, i = this.count; e < i; e++) le.fromBufferAttribute(this, e), le.applyMatrix3(t), this.setXY(e, le.x, le.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, i = this.count; e < i; e++) oe.fromBufferAttribute(this, e), oe.applyMatrix3(t), this.setXYZ(e, oe.x, oe.y, oe.z);
                    return this
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.count; e < i; e++) oe.fromBufferAttribute(this, e), oe.applyMatrix4(t), this.setXYZ(e, oe.x, oe.y, oe.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) oe.fromBufferAttribute(this, e), oe.applyNormalMatrix(t), this.setXYZ(e, oe.x, oe.y, oe.z);
                    return this
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) oe.fromBufferAttribute(this, e), oe.transformDirection(t), this.setXYZ(e, oe.x, oe.y, oe.z);
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                getX(t) {
                    return this.array[t * this.itemSize]
                }
                setX(t, e) {
                    return this.array[t * this.itemSize] = e, this
                }
                getY(t) {
                    return this.array[t * this.itemSize + 1]
                }
                setY(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                }
                getZ(t) {
                    return this.array[t * this.itemSize + 2]
                }
                setZ(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                }
                getW(t) {
                    return this.array[t * this.itemSize + 3]
                }
                setW(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                }
                setXY(t, e, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
                }
                setXYZ(t, e, i, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                }
                setXYZW(t, e, i, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const t = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                }
            }
            he.prototype.isBufferAttribute = !0;
            class ce extends he {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i)
                }
            }
            class ue extends he {
                constructor(t, e, i) {
                    super(new Uint32Array(t), e, i)
                }
            }(class extends he {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i)
                }
            }).prototype.isFloat16BufferAttribute = !0;
            class de extends he {
                constructor(t, e, i) {
                    super(new Float32Array(t), e, i)
                }
            }
            let pe = 0;
            const me = new pt,
                fe = new Ht,
                ge = new O,
                ye = new U,
                xe = new U,
                ve = new O;
            class _e extends p {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: pe++
                    }), this.uuid = v(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(t) {
                    return Array.isArray(t) ? this.index = new(function(t) {
                        for (let e = t.length - 1; e >= 0; --e)
                            if (t[e] > 65535) return !0;
                        return !1
                    }(t) ? ue : ce)(t, 1) : this.index = t, this
                }
                getAttribute(t) {
                    return this.attributes[t]
                }
                setAttribute(t, e) {
                    return this.attributes[t] = e, this
                }
                deleteAttribute(t) {
                    return delete this.attributes[t], this
                }
                hasAttribute(t) {
                    return void 0 !== this.attributes[t]
                }
                addGroup(t, e, i = 0) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: i
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                }
                applyMatrix4(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    const i = this.attributes.normal;
                    if (void 0 !== i) {
                        const e = (new S).getNormalMatrix(t);
                        i.applyNormalMatrix(e), i.needsUpdate = !0
                    }
                    const n = this.attributes.tangent;
                    return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(t) {
                    return me.makeRotationFromQuaternion(t), this.applyMatrix4(me), this
                }
                rotateX(t) {
                    return me.makeRotationX(t), this.applyMatrix4(me), this
                }
                rotateY(t) {
                    return me.makeRotationY(t), this.applyMatrix4(me), this
                }
                rotateZ(t) {
                    return me.makeRotationZ(t), this.applyMatrix4(me), this
                }
                translate(t, e, i) {
                    return me.makeTranslation(t, e, i), this.applyMatrix4(me), this
                }
                scale(t, e, i) {
                    return me.makeScale(t, e, i), this.applyMatrix4(me), this
                }
                lookAt(t) {
                    return fe.lookAt(t), fe.updateMatrix(), this.applyMatrix4(fe.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(ge).negate(), this.translate(ge.x, ge.y, ge.z), this
                }
                setFromPoints(t) {
                    const e = [];
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i];
                        e.push(n.x, n.y, n.z || 0)
                    }
                    return this.setAttribute("position", new de(e, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new U);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new O(-1 / 0, -1 / 0, -1 / 0), new O(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let i = 0, n = e.length; i < n; i++) {
                                const t = e[i];
                                ye.setFromBufferAttribute(t), this.morphTargetsRelative ? (ve.addVectors(this.boundingBox.min, ye.min), this.boundingBox.expandByPoint(ve), ve.addVectors(this.boundingBox.max, ye.max), this.boundingBox.expandByPoint(ve)) : (this.boundingBox.expandByPoint(ye.min), this.boundingBox.expandByPoint(ye.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new rt);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new O, 1 / 0);
                    if (t) {
                        const i = this.boundingSphere.center;
                        if (ye.setFromBufferAttribute(t), e)
                            for (let t = 0, r = e.length; t < r; t++) {
                                const i = e[t];
                                xe.setFromBufferAttribute(i), this.morphTargetsRelative ? (ve.addVectors(ye.min, xe.min), ye.expandByPoint(ve), ve.addVectors(ye.max, xe.max), ye.expandByPoint(ve)) : (ye.expandByPoint(xe.min), ye.expandByPoint(xe.max))
                            }
                        ye.getCenter(i);
                        let n = 0;
                        for (let e = 0, r = t.count; e < r; e++) ve.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(ve));
                        if (e)
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r],
                                    a = this.morphTargetsRelative;
                                for (let e = 0, r = s.count; e < r; e++) ve.fromBufferAttribute(s, e), a && (ge.fromBufferAttribute(t, e), ve.add(ge)), n = Math.max(n, i.distanceToSquared(ve))
                            }
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const i = t.array,
                        n = e.position.array,
                        r = e.normal.array,
                        s = e.uv.array,
                        a = n.length / 3;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new he(new Float32Array(4 * a), 4));
                    const o = this.getAttribute("tangent").array,
                        l = [],
                        h = [];
                    for (let w = 0; w < a; w++) l[w] = new O, h[w] = new O;
                    const c = new O,
                        u = new O,
                        d = new O,
                        p = new w,
                        m = new w,
                        f = new w,
                        g = new O,
                        y = new O;

                    function x(t, e, i) {
                        c.fromArray(n, 3 * t), u.fromArray(n, 3 * e), d.fromArray(n, 3 * i), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * i), u.sub(c), d.sub(c), m.sub(p), f.sub(p);
                        const r = 1 / (m.x * f.y - f.x * m.y);
                        isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), y.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[i].add(g), h[t].add(y), h[e].add(y), h[i].add(y))
                    }
                    let v = this.groups;
                    0 === v.length && (v = [{
                        start: 0,
                        count: i.length
                    }]);
                    for (let w = 0, T = v.length; w < T; ++w) {
                        const t = v[w],
                            e = t.start;
                        for (let n = e, r = e + t.count; n < r; n += 3) x(i[n + 0], i[n + 1], i[n + 2])
                    }
                    const _ = new O,
                        b = new O,
                        M = new O,
                        S = new O;

                    function E(t) {
                        M.fromArray(r, 3 * t), S.copy(M);
                        const e = l[t];
                        _.copy(e), _.sub(M.multiplyScalar(M.dot(e))).normalize(), b.crossVectors(S, e);
                        const i = b.dot(h[t]) < 0 ? -1 : 1;
                        o[4 * t] = _.x, o[4 * t + 1] = _.y, o[4 * t + 2] = _.z, o[4 * t + 3] = i
                    }
                    for (let w = 0, T = v.length; w < T; ++w) {
                        const t = v[w],
                            e = t.start;
                        for (let n = e, r = e + t.count; n < r; n += 3) E(i[n + 0]), E(i[n + 1]), E(i[n + 2])
                    }
                }
                computeVertexNormals() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let i = this.getAttribute("normal");
                        if (void 0 === i) i = new he(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                        else
                            for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
                        const n = new O,
                            r = new O,
                            s = new O,
                            a = new O,
                            o = new O,
                            l = new O,
                            h = new O,
                            c = new O;
                        if (t)
                            for (let u = 0, d = t.count; u < d; u += 3) {
                                const d = t.getX(u + 0),
                                    p = t.getX(u + 1),
                                    m = t.getX(u + 2);
                                n.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, p), l.fromBufferAttribute(i, m), a.add(h), o.add(h), l.add(h), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(m, l.x, l.y, l.z)
                            } else
                                for (let t = 0, u = e.count; t < u; t += 3) n.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), i.setXYZ(t + 0, h.x, h.y, h.z), i.setXYZ(t + 1, h.x, h.y, h.z), i.setXYZ(t + 2, h.x, h.y, h.z);
                        this.normalizeNormals(), i.needsUpdate = !0
                    }
                }
                merge(t, e) {
                    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const i = this.attributes;
                    for (const n in i) {
                        if (void 0 === t.attributes[n]) continue;
                        const r = i[n].array,
                            s = t.attributes[n],
                            a = s.array,
                            o = s.itemSize * e,
                            l = Math.min(a.length, r.length - o);
                        for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t]
                    }
                    return this
                }
                normalizeNormals() {
                    const t = this.attributes.normal;
                    for (let e = 0, i = t.count; e < i; e++) ve.fromBufferAttribute(t, e), ve.normalize(), t.setXYZ(e, ve.x, ve.y, ve.z)
                }
                toNonIndexed() {
                    function t(t, e) {
                        const i = t.array,
                            n = t.itemSize,
                            r = t.normalized,
                            s = new i.constructor(e.length * n);
                        let a = 0,
                            o = 0;
                        for (let l = 0, h = e.length; l < h; l++) {
                            a = t.isInterleavedBufferAttribute ? e[l] * t.data.stride + t.offset : e[l] * n;
                            for (let t = 0; t < n; t++) s[o++] = i[a++]
                        }
                        return new he(s, n, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const e = new _e,
                        i = this.index.array,
                        n = this.attributes;
                    for (const a in n) {
                        const r = t(n[a], i);
                        e.setAttribute(a, r)
                    }
                    const r = this.morphAttributes;
                    for (const a in r) {
                        const n = [],
                            s = r[a];
                        for (let e = 0, r = s.length; e < r; e++) {
                            const r = t(s[e], i);
                            n.push(r)
                        }
                        e.morphAttributes[a] = n
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let a = 0, o = s.length; a < o; a++) {
                        const t = s[a];
                        e.addGroup(t.start, t.count, t.materialIndex)
                    }
                    return e
                }
                toJSON() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    const e = this.index;
                    null !== e && (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array)
                    });
                    const i = this.attributes;
                    for (const o in i) {
                        const e = i[o];
                        t.data.attributes[o] = e.toJSON(t.data)
                    }
                    const n = {};
                    let r = !1;
                    for (const o in this.morphAttributes) {
                        const e = this.morphAttributes[o],
                            i = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            i.push(r.toJSON(t.data))
                        }
                        i.length > 0 && (n[o] = i, r = !0)
                    }
                    r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    const a = this.boundingSphere;
                    return null !== a && (t.data.boundingSphere = {
                        center: a.center.toArray(),
                        radius: a.radius
                    }), t
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const e = {};
                    this.name = t.name;
                    const i = t.index;
                    null !== i && this.setIndex(i.clone(e));
                    const n = t.attributes;
                    for (const l in n) {
                        const t = n[l];
                        this.setAttribute(l, t.clone(e))
                    }
                    const r = t.morphAttributes;
                    for (const l in r) {
                        const t = [],
                            i = r[l];
                        for (let n = 0, r = i.length; n < r; n++) t.push(i[n].clone(e));
                        this.morphAttributes[l] = t
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const s = t.groups;
                    for (let l = 0, h = s.length; l < h; l++) {
                        const t = s[l];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const a = t.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    const o = t.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            _e.prototype.isBufferGeometry = !0;
            const be = new pt,
                Me = new dt,
                we = new rt,
                Se = new O,
                Ee = new O,
                Te = new O,
                Ae = new O,
                Ce = new O,
                Re = new O,
                Le = new O,
                Pe = new O,
                ze = new O,
                De = new w,
                Ie = new w,
                Ne = new w,
                Oe = new O,
                Be = new O;
            class He extends Ht {
                constructor(t = new _e, e = new se) {
                    super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(t) {
                    return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.material,
                        r = this.matrixWorld;
                    if (void 0 === n) return;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), we.copy(i.boundingSphere), we.applyMatrix4(r), !1 === t.ray.intersectsSphere(we)) return;
                    if (be.copy(r).invert(), Me.copy(t.ray).applyMatrix4(be), null !== i.boundingBox && !1 === Me.intersectsBox(i.boundingBox)) return;
                    let s;
                    if (i.isBufferGeometry) {
                        const r = i.index,
                            a = i.attributes.position,
                            o = i.morphAttributes.position,
                            l = i.morphTargetsRelative,
                            h = i.attributes.uv,
                            c = i.attributes.uv2,
                            u = i.groups,
                            d = i.drawRange;
                        if (null !== r)
                            if (Array.isArray(n))
                                for (let i = 0, p = u.length; i < p; i++) {
                                    const p = u[i],
                                        m = n[p.materialIndex];
                                    for (let i = Math.max(p.start, d.start), n = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); i < n; i += 3) {
                                        const n = r.getX(i),
                                            u = r.getX(i + 1),
                                            d = r.getX(i + 2);
                                        s = Ue(this, m, t, Me, a, o, l, h, c, n, u, d), s && (s.faceIndex = Math.floor(i / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                    }
                                } else {
                                    for (let i = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); i < u; i += 3) {
                                        const u = r.getX(i),
                                            d = r.getX(i + 1),
                                            p = r.getX(i + 2);
                                        s = Ue(this, n, t, Me, a, o, l, h, c, u, d, p), s && (s.faceIndex = Math.floor(i / 3), e.push(s))
                                    }
                                } else if (void 0 !== a)
                                    if (Array.isArray(n))
                                        for (let i = 0, p = u.length; i < p; i++) {
                                            const r = u[i],
                                                p = n[r.materialIndex];
                                            for (let i = Math.max(r.start, d.start), n = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); i < n; i += 3) {
                                                s = Ue(this, p, t, Me, a, o, l, h, c, i, i + 1, i + 2), s && (s.faceIndex = Math.floor(i / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                            }
                                        } else {
                                            for (let i = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); i < r; i += 3) {
                                                s = Ue(this, n, t, Me, a, o, l, h, c, i, i + 1, i + 2), s && (s.faceIndex = Math.floor(i / 3), e.push(s))
                                            }
                                        }
                    } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }

            function Ue(t, e, i, n, r, s, a, o, l, h, c, u) {
                Se.fromBufferAttribute(r, h), Ee.fromBufferAttribute(r, c), Te.fromBufferAttribute(r, u);
                const d = t.morphTargetInfluences;
                if (s && d) {
                    Le.set(0, 0, 0), Pe.set(0, 0, 0), ze.set(0, 0, 0);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = d[t],
                            i = s[t];
                        0 !== e && (Ae.fromBufferAttribute(i, h), Ce.fromBufferAttribute(i, c), Re.fromBufferAttribute(i, u), a ? (Le.addScaledVector(Ae, e), Pe.addScaledVector(Ce, e), ze.addScaledVector(Re, e)) : (Le.addScaledVector(Ae.sub(Se), e), Pe.addScaledVector(Ce.sub(Ee), e), ze.addScaledVector(Re.sub(Te), e)))
                    }
                    Se.add(Le), Ee.add(Pe), Te.add(ze)
                }
                t.isSkinnedMesh && (t.boneTransform(h, Se), t.boneTransform(c, Ee), t.boneTransform(u, Te));
                const p = function(t, e, i, n, r, s, a, o) {
                    let l;
                    if (l = 1 === e.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
                    Be.copy(o), Be.applyMatrix4(t.matrixWorld);
                    const h = i.ray.origin.distanceTo(Be);
                    return h < i.near || h > i.far ? null : {
                        distance: h,
                        point: Be.clone(),
                        object: t
                    }
                }(t, e, i, n, Se, Ee, Te, Oe);
                if (p) {
                    o && (De.fromBufferAttribute(o, h), Ie.fromBufferAttribute(o, c), Ne.fromBufferAttribute(o, u), p.uv = Jt.getUV(Oe, Se, Ee, Te, De, Ie, Ne, new w)), l && (De.fromBufferAttribute(l, h), Ie.fromBufferAttribute(l, c), Ne.fromBufferAttribute(l, u), p.uv2 = Jt.getUV(Oe, Se, Ee, Te, De, Ie, Ne, new w));
                    const t = {
                        a: h,
                        b: c,
                        c: u,
                        normal: new O,
                        materialIndex: 0
                    };
                    Jt.getNormal(Se, Ee, Te, t.normal), p.face = t
                }
                return p
            }

            function Fe(t, e, i, n, r, s) {
                var a = (new I).load(r);
                e.matcap = a;
                for (var o = 0; o < i; o++) {
                    var l = new He(t, e);
                    l.position.set((Math.random() - .5) * n, (Math.random() - .5) * n, (Math.random() - .5) * n), l.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                    var h = Math.random();
                    l.scale.set(h, h, h), s.add(l)
                }
            }
            He.prototype.isMesh = !0;
            const ke = "139",
                Ve = 100,
                Ge = 301,
                We = 302,
                je = 303,
                qe = 304,
                Xe = 306,
                Ye = 1e3,
                Je = 1001,
                Ze = 1002,
                Qe = 1003,
                Ke = 1004,
                $e = 1005,
                ti = 1006,
                ei = 1007,
                ii = 1008,
                ni = 1009,
                ri = 1012,
                si = 1014,
                ai = 1015,
                oi = 1016,
                li = 1020,
                hi = 1023,
                ci = 1026,
                ui = 1027,
                di = 33776,
                pi = 33777,
                mi = 33778,
                fi = 33779,
                gi = 2300,
                yi = 2301,
                xi = 2302,
                vi = 2400,
                _i = 2401,
                bi = 2402,
                Mi = 2500,
                wi = 3e3,
                Si = 3001,
                Ei = "srgb",
                Ti = "srgb-linear",
                Ai = 7680,
                Ci = 35044,
                Ri = 35048,
                Li = "300 es",
                Pi = 1035;
            class zi {
                addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                }
                hasEventListener(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                }
                removeEventListener(t, e) {
                    if (void 0 === this._listeners) return;
                    const i = this._listeners[t];
                    if (void 0 !== i) {
                        const t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
                    }
                }
                dispatchEvent(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const i = e.slice(0);
                        for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
                        t.target = null
                    }
                }
            }
            const Di = [];
            for (let nd = 0; nd < 256; nd++) Di[nd] = (nd < 16 ? "0" : "") + nd.toString(16);
            const Ii = Math.PI / 180,
                Ni = 180 / Math.PI;

            function Oi() {
                const t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0;
                return (Di[255 & t] + Di[t >> 8 & 255] + Di[t >> 16 & 255] + Di[t >> 24 & 255] + "-" + Di[255 & e] + Di[e >> 8 & 255] + "-" + Di[e >> 16 & 15 | 64] + Di[e >> 24 & 255] + "-" + Di[63 & i | 128] + Di[i >> 8 & 255] + "-" + Di[i >> 16 & 255] + Di[i >> 24 & 255] + Di[255 & n] + Di[n >> 8 & 255] + Di[n >> 16 & 255] + Di[n >> 24 & 255]).toLowerCase()
            }

            function Bi(t, e, i) {
                return Math.max(e, Math.min(i, t))
            }

            function Hi(t, e) {
                return (t % e + e) % e
            }

            function Ui(t, e, i) {
                return (1 - i) * t + i * e
            }

            function Fi(t) {
                return 0 === (t & t - 1) && 0 !== t
            }

            function ki(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            }
            class Vi {
                constructor(t = 0, e = 0) {
                    this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    const e = this.x,
                        i = this.y,
                        n = t.elements;
                    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    const i = Math.cos(e),
                        n = Math.sin(e),
                        r = this.x - t.x,
                        s = this.y - t.y;
                    return this.x = r * i - s * n + t.x, this.y = r * n + s * i + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            Vi.prototype.isVector2 = !0;
            class Gi {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, i, n, r, s, a, o, l) {
                    const h = this.elements;
                    return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = s, h[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(t) {
                    const e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        s = i[0],
                        a = i[3],
                        o = i[6],
                        l = i[1],
                        h = i[4],
                        c = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        m = n[0],
                        f = n[3],
                        g = n[6],
                        y = n[1],
                        x = n[4],
                        v = n[7],
                        _ = n[2],
                        b = n[5],
                        M = n[8];
                    return r[0] = s * m + a * y + o * _, r[3] = s * f + a * x + o * b, r[6] = s * g + a * v + o * M, r[1] = l * m + h * y + c * _, r[4] = l * f + h * x + c * b, r[7] = l * g + h * v + c * M, r[2] = u * m + d * y + p * _, r[5] = u * f + d * x + p * b, r[8] = u * g + d * v + p * M, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8];
                    return e * s * h - e * a * l - i * r * h + i * a * o + n * r * l - n * s * o
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8],
                        c = h * s - a * l,
                        u = a * o - h * r,
                        d = l * r - s * o,
                        p = e * c + i * u + n * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const m = 1 / p;
                    return t[0] = c * m, t[1] = (n * l - h * i) * m, t[2] = (a * i - n * s) * m, t[3] = u * m, t[4] = (h * e - n * o) * m, t[5] = (n * r - a * e) * m, t[6] = d * m, t[7] = (i * o - l * e) * m, t[8] = (s * e - i * r) * m, this
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose()
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, i, n, r, s, a) {
                    const o = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(i * o, i * l, -i * (o * s + l * a) + s + t, -n * l, n * o, -n * (-l * s + o * a) + a + e, 0, 0, 1), this
                }
                scale(t, e) {
                    const i = this.elements;
                    return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
                }
                rotate(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.elements,
                        r = n[0],
                        s = n[3],
                        a = n[6],
                        o = n[1],
                        l = n[4],
                        h = n[7];
                    return n[0] = e * r + i * o, n[3] = e * s + i * l, n[6] = e * a + i * h, n[1] = -i * r + e * o, n[4] = -i * s + e * l, n[7] = -i * a + e * h, this
                }
                translate(t, e) {
                    const i = this.elements;
                    return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
                }
                equals(t) {
                    const e = this.elements,
                        i = t.elements;
                    for (let n = 0; n < 9; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }

            function Wi(t) {
                for (let e = t.length - 1; e >= 0; --e)
                    if (t[e] > 65535) return !0;
                return !1
            }
            Gi.prototype.isMatrix3 = !0;
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

            function ji(t) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", t)
            }

            function qi(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function Xi(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            const Yi = {
                    [Ei]: {
                        [Ti]: qi
                    },
                    [Ti]: {
                        [Ei]: Xi
                    }
                },
                Ji = {
                    legacyMode: !0,
                    get workingColorSpace() {
                        return Ti
                    },
                    set workingColorSpace(t) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function(t, e, i) {
                        if (this.legacyMode || e === i || !e || !i) return t;
                        if (Yi[e] && void 0 !== Yi[e][i]) {
                            const n = Yi[e][i];
                            return t.r = n(t.r), t.g = n(t.g), t.b = n(t.b), t
                        }
                        throw new Error("Unsupported color space conversion.")
                    },
                    fromWorkingColorSpace: function(t, e) {
                        return this.convert(t, this.workingColorSpace, e)
                    },
                    toWorkingColorSpace: function(t, e) {
                        return this.convert(t, e, this.workingColorSpace)
                    }
                },
                Zi = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                Qi = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                Ki = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                $i = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function tn(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }

            function en(t, e) {
                return e.r = t.r, e.g = t.g, e.b = t.b, e
            }
            class nn {
                constructor(t, e, i) {
                    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t, e = "srgb") {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, Ji.toWorkingColorSpace(this, e), this
                }
                setRGB(t, e, i, n = "srgb-linear") {
                    return this.r = t, this.g = e, this.b = i, Ji.toWorkingColorSpace(this, n), this
                }
                setHSL(t, e, i, n = "srgb-linear") {
                    if (t = Hi(t, 1), e = Bi(e, 0, 1), i = Bi(i, 0, 1), 0 === e) this.r = this.g = this.b = i;
                    else {
                        const n = i <= .5 ? i * (1 + e) : i + e - i * e,
                            r = 2 * i - n;
                        this.r = tn(r, n, t + 1 / 3), this.g = tn(r, n, t), this.b = tn(r, n, t - 1 / 3)
                    }
                    return Ji.toWorkingColorSpace(this, n), this
                }
                setStyle(t, e = "srgb") {
                    function i(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    let n;
                    if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                        let t;
                        const r = n[1],
                            s = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, Ji.toWorkingColorSpace(this, e), i(t[4]), this;
                                if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, Ji.toWorkingColorSpace(this, e), i(t[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                    const n = parseFloat(t[1]) / 360,
                                        r = parseInt(t[2], 10) / 100,
                                        s = parseInt(t[3], 10) / 100;
                                    return i(t[4]), this.setHSL(n, r, s, e)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                        const t = n[1],
                            i = t.length;
                        if (3 === i) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, Ji.toWorkingColorSpace(this, e), this;
                        if (6 === i) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, Ji.toWorkingColorSpace(this, e), this
                    }
                    return t && t.length > 0 ? this.setColorName(t, e) : this
                }
                setColorName(t, e = "srgb") {
                    const i = Zi[t.toLowerCase()];
                    return void 0 !== i ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copySRGBToLinear(t) {
                    return this.r = qi(t.r), this.g = qi(t.g), this.b = qi(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = Xi(t.r), this.g = Xi(t.g), this.b = Xi(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(t = "srgb") {
                    return Ji.fromWorkingColorSpace(en(this, Qi), t), Bi(255 * Qi.r, 0, 255) << 16 ^ Bi(255 * Qi.g, 0, 255) << 8 ^ Bi(255 * Qi.b, 0, 255) << 0
                }
                getHexString(t = "srgb") {
                    return ("000000" + this.getHex(t).toString(16)).slice(-6)
                }
                getHSL(t, e = "srgb-linear") {
                    Ji.fromWorkingColorSpace(en(this, Qi), e);
                    const i = Qi.r,
                        n = Qi.g,
                        r = Qi.b,
                        s = Math.max(i, n, r),
                        a = Math.min(i, n, r);
                    let o, l;
                    const h = (a + s) / 2;
                    if (a === s) o = 0, l = 0;
                    else {
                        const t = s - a;
                        switch (l = h <= .5 ? t / (s + a) : t / (2 - s - a), s) {
                            case i:
                                o = (n - r) / t + (n < r ? 6 : 0);
                                break;
                            case n:
                                o = (r - i) / t + 2;
                                break;
                            case r:
                                o = (i - n) / t + 4
                        }
                        o /= 6
                    }
                    return t.h = o, t.s = l, t.l = h, t
                }
                getRGB(t, e = "srgb-linear") {
                    return Ji.fromWorkingColorSpace(en(this, Qi), e), t.r = Qi.r, t.g = Qi.g, t.b = Qi.b, t
                }
                getStyle(t = "srgb") {
                    return Ji.fromWorkingColorSpace(en(this, Qi), t), t !== Ei ? `color(${t} ${Qi.r} ${Qi.g} ${Qi.b})` : `rgb(${255*Qi.r|0},${255*Qi.g|0},${255*Qi.b|0})`
                }
                offsetHSL(t, e, i) {
                    return this.getHSL(Ki), Ki.h += t, Ki.s += e, Ki.l += i, this.setHSL(Ki.h, Ki.s, Ki.l), this
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpColors(t, e, i) {
                    return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this
                }
                lerpHSL(t, e) {
                    this.getHSL(Ki), t.getHSL($i);
                    const i = Ui(Ki.h, $i.h, e),
                        n = Ui(Ki.s, $i.s, e),
                        r = Ui(Ki.l, $i.l, e);
                    return this.setHSL(i, n, r), this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e = 0) {
                    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            let rn;
            nn.NAMES = Zi, nn.prototype.isColor = !0, nn.prototype.r = 1, nn.prototype.g = 1, nn.prototype.b = 1;
            class sn {
                static getDataURL(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                        void 0 === rn && (rn = ji("canvas")), rn.width = t.width, rn.height = t.height;
                        const i = rn.getContext("2d");
                        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = rn
                    }
                    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                }
                static sRGBToLinear(t) {
                    if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                        const e = ji("canvas");
                        e.width = t.width, e.height = t.height;
                        const i = e.getContext("2d");
                        i.drawImage(t, 0, 0, t.width, t.height);
                        const n = i.getImageData(0, 0, t.width, t.height),
                            r = n.data;
                        for (let t = 0; t < r.length; t++) r[t] = 255 * qi(r[t] / 255);
                        return i.putImageData(n, 0, 0), e
                    }
                    if (t.data) {
                        const e = t.data.slice(0);
                        for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * qi(e[t] / 255)) : e[t] = qi(e[t]);
                        return {
                            data: e,
                            width: t.width,
                            height: t.height
                        }
                    }
                    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                }
            }
            class an {
                constructor(t = null) {
                    this.uuid = Oi(), this.data = t, this.version = 0
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                    const i = {
                            uuid: this.uuid,
                            url: ""
                        },
                        n = this.data;
                    if (null !== n) {
                        let t;
                        if (Array.isArray(n)) {
                            t = [];
                            for (let e = 0, i = n.length; e < i; e++) n[e].isDataTexture ? t.push(on(n[e].image)) : t.push(on(n[e]))
                        } else t = on(n);
                        i.url = t
                    }
                    return e || (t.images[this.uuid] = i), i
                }
            }

            function on(t) {
                return "undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap ? sn.getDataURL(t) : t.data ? {
                    data: Array.prototype.slice.call(t.data),
                    width: t.width,
                    height: t.height,
                    type: t.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            an.prototype.isSource = !0;
            let ln = 0;
            class hn extends zi {
                constructor(t = hn.DEFAULT_IMAGE, e = hn.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, h = 3e3) {
                    super(), Object.defineProperty(this, "id", {
                        value: ln++
                    }), this.uuid = Oi(), this.name = "", this.source = new an(t), this.mipmaps = [], this.mapping = e, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Vi(0, 0), this.repeat = new Vi(1, 1), this.center = new Vi(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Gi, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                }
                get image() {
                    return this.source.data
                }
                set image(t) {
                    this.source.data = t
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(t).uuid,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case Ye:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case Je:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case Ze:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case Ye:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case Je:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case Ze:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
                set needsUpdate(t) {
                    !0 === t && (this.version++, this.source.needsUpdate = !0)
                }
            }
            hn.DEFAULT_IMAGE = null, hn.DEFAULT_MAPPING = 300, hn.prototype.isTexture = !0;
            class cn {
                constructor(t = 0, e = 0, i = 0, n = 1) {
                    this.x = t, this.y = e, this.z = i, this.w = n
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, i, n) {
                    return this.x = t, this.y = e, this.z = i, this.w = n, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        s = t.elements;
                    return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, i, n, r;
                    const s = .01,
                        a = .1,
                        o = t.elements,
                        l = o[0],
                        h = o[4],
                        c = o[8],
                        u = o[1],
                        d = o[5],
                        p = o[9],
                        m = o[2],
                        f = o[6],
                        g = o[10];
                    if (Math.abs(h - u) < s && Math.abs(c - m) < s && Math.abs(p - f) < s) {
                        if (Math.abs(h + u) < a && Math.abs(c + m) < a && Math.abs(p + f) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (l + 1) / 2,
                            o = (d + 1) / 2,
                            y = (g + 1) / 2,
                            x = (h + u) / 4,
                            v = (c + m) / 4,
                            _ = (p + f) / 4;
                        return t > o && t > y ? t < s ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(t), n = x / i, r = v / i) : o > y ? o < s ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(o), i = x / n, r = _ / n) : y < s ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(y), i = v / r, n = _ / r), this.set(i, n, r, e), this
                    }
                    let y = Math.sqrt((f - p) * (f - p) + (c - m) * (c - m) + (u - h) * (u - h));
                    return Math.abs(y) < .001 && (y = 1), this.x = (f - p) / y, this.y = (c - m) / y, this.z = (u - h) / y, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            cn.prototype.isVector4 = !0;
            class un extends zi {
                constructor(t, e, i = {}) {
                    super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new cn(0, 0, t, e), this.scissorTest = !1, this.viewport = new cn(0, 0, t, e);
                    const n = {
                        width: t,
                        height: e,
                        depth: 1
                    };
                    this.texture = new hn(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : ti, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null, this.samples = void 0 !== i.samples ? i.samples : 0
                }
                setSize(t, e, i = 1) {
                    this.width === t && this.height === e && this.depth === i || (this.width = t, this.height = e, this.depth = i, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0, this.texture.image = Object.assign({}, t.texture.image), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            un.prototype.isWebGLRenderTarget = !0;
            class dn extends hn {
                constructor(t = null, e = 1, i = 1, n = 1) {
                    super(null), this.image = {
                        data: t,
                        width: e,
                        height: i,
                        depth: n
                    }, this.magFilter = Qe, this.minFilter = Qe, this.wrapR = Je, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            dn.prototype.isDataArrayTexture = !0;
            (class extends un {
                constructor(t, e, i) {
                    super(t, e), this.depth = i, this.texture = new dn(null, t, e, i), this.texture.isRenderTargetTexture = !0
                }
            }).prototype.isWebGLArrayRenderTarget = !0;
            class pn extends hn {
                constructor(t = null, e = 1, i = 1, n = 1) {
                    super(null), this.image = {
                        data: t,
                        width: e,
                        height: i,
                        depth: n
                    }, this.magFilter = Qe, this.minFilter = Qe, this.wrapR = Je, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            pn.prototype.isData3DTexture = !0;
            (class extends un {
                constructor(t, e, i) {
                    super(t, e), this.depth = i, this.texture = new pn(null, t, e, i), this.texture.isRenderTargetTexture = !0
                }
            }).prototype.isWebGL3DRenderTarget = !0;
            (class extends un {
                constructor(t, e, i, n = {}) {
                    super(t, e, n);
                    const r = this.texture;
                    this.texture = [];
                    for (let s = 0; s < i; s++) this.texture[s] = r.clone(), this.texture[s].isRenderTargetTexture = !0
                }
                setSize(t, e, i = 1) {
                    if (this.width !== t || this.height !== e || this.depth !== i) {
                        this.width = t, this.height = e, this.depth = i;
                        for (let n = 0, r = this.texture.length; n < r; n++) this.texture[n].image.width = t, this.texture[n].image.height = e, this.texture[n].image.depth = i;
                        this.dispose()
                    }
                    return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                }
                copy(t) {
                    this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                    for (let e = 0, i = t.texture.length; e < i; e++) this.texture[e] = t.texture[e].clone();
                    return this
                }
            }).prototype.isWebGLMultipleRenderTargets = !0;
            class mn {
                constructor(t = 0, e = 0, i = 0, n = 1) {
                    this._x = t, this._y = e, this._z = i, this._w = n
                }
                static slerp(t, e, i, n) {
                    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(t, e, n)
                }
                static slerpFlat(t, e, i, n, r, s, a) {
                    let o = i[n + 0],
                        l = i[n + 1],
                        h = i[n + 2],
                        c = i[n + 3];
                    const u = r[s + 0],
                        d = r[s + 1],
                        p = r[s + 2],
                        m = r[s + 3];
                    if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = h, void(t[e + 3] = c);
                    if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                    if (c !== m || o !== u || l !== d || h !== p) {
                        let t = 1 - a;
                        const e = o * u + l * d + h * p + c * m,
                            i = e >= 0 ? 1 : -1,
                            n = 1 - e * e;
                        if (n > Number.EPSILON) {
                            const r = Math.sqrt(n),
                                s = Math.atan2(r, e * i);
                            t = Math.sin(t * s) / r, a = Math.sin(a * s) / r
                        }
                        const r = a * i;
                        if (o = o * t + u * r, l = l * t + d * r, h = h * t + p * r, c = c * t + m * r, t === 1 - a) {
                            const t = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
                            o *= t, l *= t, h *= t, c *= t
                        }
                    }
                    t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
                }
                static multiplyQuaternionsFlat(t, e, i, n, r, s) {
                    const a = i[n],
                        o = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        c = r[s],
                        u = r[s + 1],
                        d = r[s + 2],
                        p = r[s + 3];
                    return t[e] = a * p + h * c + o * d - l * u, t[e + 1] = o * p + h * u + l * c - a * d, t[e + 2] = l * p + h * d + a * u - o * c, t[e + 3] = h * p - a * c - o * u - l * d, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const i = t._x,
                        n = t._y,
                        r = t._z,
                        s = t._order,
                        a = Math.cos,
                        o = Math.sin,
                        l = a(i / 2),
                        h = a(n / 2),
                        c = a(r / 2),
                        u = o(i / 2),
                        d = o(n / 2),
                        p = o(r / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "YXZ":
                            this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        case "ZXY":
                            this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "ZYX":
                            this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        case "YZX":
                            this._x = u * h * c + l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "XZY":
                            this._x = u * h * c - l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    const i = e / 2,
                        n = Math.sin(i);
                    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        i = e[0],
                        n = e[4],
                        r = e[8],
                        s = e[1],
                        a = e[5],
                        o = e[9],
                        l = e[2],
                        h = e[6],
                        c = e[10],
                        u = i + a + c;
                    if (u > 0) {
                        const t = .5 / Math.sqrt(u + 1);
                        this._w = .25 / t, this._x = (h - o) * t, this._y = (r - l) * t, this._z = (s - n) * t
                    } else if (i > a && i > c) {
                        const t = 2 * Math.sqrt(1 + i - a - c);
                        this._w = (h - o) / t, this._x = .25 * t, this._y = (n + s) / t, this._z = (r + l) / t
                    } else if (a > c) {
                        const t = 2 * Math.sqrt(1 + a - i - c);
                        this._w = (r - l) / t, this._x = (n + s) / t, this._y = .25 * t, this._z = (o + h) / t
                    } else {
                        const t = 2 * Math.sqrt(1 + c - i - a);
                        this._w = (s - n) / t, this._x = (r + l) / t, this._y = (o + h) / t, this._z = .25 * t
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    let i = t.dot(e) + 1;
                    return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize()
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(Bi(this.dot(t), -1, 1)))
                }
                rotateTowards(t, e) {
                    const i = this.angleTo(t);
                    if (0 === i) return this;
                    const n = Math.min(1, e / i);
                    return this.slerp(t, n), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this)
                }
                multiplyQuaternions(t, e) {
                    const i = t._x,
                        n = t._y,
                        r = t._z,
                        s = t._w,
                        a = e._x,
                        o = e._y,
                        l = e._z,
                        h = e._w;
                    return this._x = i * h + s * a + n * l - r * o, this._y = n * h + s * o + r * a - i * l, this._z = r * h + s * l + i * o - n * a, this._w = s * h - i * a - n * o - r * l, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const i = this._x,
                        n = this._y,
                        r = this._z,
                        s = this._w;
                    let a = s * t._w + i * t._x + n * t._y + r * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                    const o = 1 - a * a;
                    if (o <= Number.EPSILON) {
                        const t = 1 - e;
                        return this._w = t * s + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(o),
                        h = Math.atan2(l, a),
                        c = Math.sin((1 - e) * h) / l,
                        u = Math.sin(e * h) / l;
                    return this._w = s * c + this._w * u, this._x = i * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this
                }
                slerpQuaternions(t, e, i) {
                    return this.copy(t).slerp(e, i)
                }
                random() {
                    const t = Math.random(),
                        e = Math.sqrt(1 - t),
                        i = Math.sqrt(t),
                        n = 2 * Math.PI * Math.random(),
                        r = 2 * Math.PI * Math.random();
                    return this.set(e * Math.cos(n), i * Math.sin(r), i * Math.cos(r), e * Math.sin(n))
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e = 0) {
                    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            mn.prototype.isQuaternion = !0;
            class fn {
                constructor(t = 0, e = 0, i = 0) {
                    this.x = t, this.y = e, this.z = i
                }
                set(t, e, i) {
                    return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                }
                applyEuler(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(yn.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(yn.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements,
                        s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                    return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s, this
                }
                applyQuaternion(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.x,
                        s = t.y,
                        a = t.z,
                        o = t.w,
                        l = o * e + s * n - a * i,
                        h = o * i + a * e - r * n,
                        c = o * n + r * i - s * e,
                        u = -r * e - s * i - a * n;
                    return this.x = l * o + u * -r + h * -a - c * -s, this.y = h * o + u * -s + c * -r - l * -a, this.z = c * o + u * -a + l * -s - h * -r, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
                }
                cross(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                }
                crossVectors(t, e) {
                    const i = t.x,
                        n = t.y,
                        r = t.z,
                        s = e.x,
                        a = e.y,
                        o = e.z;
                    return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const i = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(i)
                }
                projectOnPlane(t) {
                    return gn.copy(this).projectOnVector(t), this.sub(gn)
                }
                reflect(t) {
                    return this.sub(gn.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const i = this.dot(t) / e;
                    return Math.acos(Bi(i, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        i = this.y - t.y,
                        n = this.z - t.z;
                    return e * e + i * i + n * n
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                }
                setFromSphericalCoords(t, e, i) {
                    const n = Math.sin(e) * t;
                    return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, i) {
                    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        i = this.setFromMatrixColumn(t, 1).length(),
                        n = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = i, this.z = n, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                setFromEuler(t) {
                    return this.x = t._x, this.y = t._y, this.z = t._z, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    const t = 2 * (Math.random() - .5),
                        e = Math.random() * Math.PI * 2,
                        i = Math.sqrt(1 - t ** 2);
                    return this.x = i * Math.cos(e), this.y = i * Math.sin(e), this.z = t, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            fn.prototype.isVector3 = !0;
            const gn = new fn,
                yn = new mn;
            class xn {
                constructor(t = new fn(1 / 0, 1 / 0, 1 / 0), e = new fn(-1 / 0, -1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.length; o < l; o += 3) {
                        const l = t[o],
                            h = t[o + 1],
                            c = t[o + 2];
                        l < e && (e = l), h < i && (i = h), c < n && (n = c), l > r && (r = l), h > s && (s = h), c > a && (a = c)
                    }
                    return this.min.set(e, i, n), this.max.set(r, s, a), this
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.count; o < l; o++) {
                        const l = t.getX(o),
                            h = t.getY(o),
                            c = t.getZ(o);
                        l < e && (e = l), h < i && (i = h), c < n && (n = c), l > r && (r = l), h > s && (s = h), c > a && (a = c)
                    }
                    return this.min.set(e, i, n), this.max.set(r, s, a), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const i = _n.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                }
                setFromObject(t, e = !1) {
                    return this.makeEmpty(), this.expandByObject(t, e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(t, e = !1) {
                    t.updateWorldMatrix(!1, !1);
                    const i = t.geometry;
                    if (void 0 !== i)
                        if (e && void 0 != i.attributes && void 0 !== i.attributes.position) {
                            const e = i.attributes.position;
                            for (let i = 0, n = e.count; i < n; i++) _n.fromBufferAttribute(e, i).applyMatrix4(t.matrixWorld), this.expandByPoint(_n)
                        } else null === i.boundingBox && i.computeBoundingBox(), bn.copy(i.boundingBox), bn.applyMatrix4(t.matrixWorld), this.union(bn);
                    const n = t.children;
                    for (let r = 0, s = n.length; r < s; r++) this.expandByObject(n[r], e);
                    return this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, _n), _n.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, i;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Cn), Rn.subVectors(this.max, Cn), Mn.subVectors(t.a, Cn), wn.subVectors(t.b, Cn), Sn.subVectors(t.c, Cn), En.subVectors(wn, Mn), Tn.subVectors(Sn, wn), An.subVectors(Mn, Sn);
                    let e = [0, -En.z, En.y, 0, -Tn.z, Tn.y, 0, -An.z, An.y, En.z, 0, -En.x, Tn.z, 0, -Tn.x, An.z, 0, -An.x, -En.y, En.x, 0, -Tn.y, Tn.x, 0, -An.y, An.x, 0];
                    return !!zn(e, Mn, wn, Sn, Rn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!zn(e, Mn, wn, Sn, Rn) && (Ln.crossVectors(En, Tn), e = [Ln.x, Ln.y, Ln.z], zn(e, Mn, wn, Sn, Rn)))
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return _n.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                getBoundingSphere(t) {
                    return this.getCenter(t.center), t.radius = .5 * this.getSize(_n).length(), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (vn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), vn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), vn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), vn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), vn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), vn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), vn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), vn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(vn)), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            xn.prototype.isBox3 = !0;
            const vn = [new fn, new fn, new fn, new fn, new fn, new fn, new fn, new fn],
                _n = new fn,
                bn = new xn,
                Mn = new fn,
                wn = new fn,
                Sn = new fn,
                En = new fn,
                Tn = new fn,
                An = new fn,
                Cn = new fn,
                Rn = new fn,
                Ln = new fn,
                Pn = new fn;

            function zn(t, e, i, n, r) {
                for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                    Pn.fromArray(t, s);
                    const a = r.x * Math.abs(Pn.x) + r.y * Math.abs(Pn.y) + r.z * Math.abs(Pn.z),
                        o = e.dot(Pn),
                        l = i.dot(Pn),
                        h = n.dot(Pn);
                    if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1
                }
                return !0
            }
            const Dn = new xn,
                In = new fn,
                Nn = new fn,
                On = new fn;
            class Bn {
                constructor(t = new fn, e = -1) {
                    this.center = t, this.radius = e
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    const i = this.center;
                    void 0 !== e ? i.copy(e) : Dn.setFromPoints(t).getCenter(i);
                    let n = 0;
                    for (let r = 0, s = t.length; r < s; r++) n = Math.max(n, i.distanceToSquared(t[r]));
                    return this.radius = Math.sqrt(n), this
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    const i = this.center.distanceToSquared(t);
                    return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                expandByPoint(t) {
                    On.subVectors(t, this.center);
                    const e = On.lengthSq();
                    if (e > this.radius * this.radius) {
                        const t = Math.sqrt(e),
                            i = .5 * (t - this.radius);
                        this.center.add(On.multiplyScalar(i / t)), this.radius += i
                    }
                    return this
                }
                union(t) {
                    return !0 === this.center.equals(t.center) ? Nn.set(0, 0, 1).multiplyScalar(t.radius) : Nn.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(In.copy(t.center).add(Nn)), this.expandByPoint(In.copy(t.center).sub(Nn)), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Hn = new fn,
                Un = new fn,
                Fn = new fn,
                kn = new fn,
                Vn = new fn,
                Gn = new fn,
                Wn = new fn;
            class jn {
                constructor(t = new fn, e = new fn(0, 0, -1)) {
                    this.origin = t, this.direction = e
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, Hn)), this
                }
                closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    const i = e.dot(this.direction);
                    return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    const e = Hn.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Hn.copy(this.direction).multiplyScalar(e).add(this.origin), Hn.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, i, n) {
                    Un.copy(t).add(e).multiplyScalar(.5), Fn.copy(e).sub(t).normalize(), kn.copy(this.origin).sub(Un);
                    const r = .5 * t.distanceTo(e),
                        s = -this.direction.dot(Fn),
                        a = kn.dot(this.direction),
                        o = -kn.dot(Fn),
                        l = kn.lengthSq(),
                        h = Math.abs(1 - s * s);
                    let c, u, d, p;
                    if (h > 0)
                        if (c = s * o - a, u = s * a - o, p = r * h, c >= 0)
                            if (u >= -p)
                                if (u <= p) {
                                    const t = 1 / h;
                                    c *= t, u *= t, d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l
                                } else u = r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    else u = -r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    else u <= -p ? (c = Math.max(0, -(-s * r + a)), u = c > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l) : u <= p ? (c = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (c = Math.max(0, -(s * r + a)), u = c > 0 ? r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l);
                    else u = s > 0 ? -r : r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    return i && i.copy(this.direction).multiplyScalar(c).add(this.origin), n && n.copy(Fn).multiplyScalar(u).add(Un), d
                }
                intersectSphere(t, e) {
                    Hn.subVectors(t.center, this.origin);
                    const i = Hn.dot(this.direction),
                        n = Hn.dot(Hn) - i * i,
                        r = t.radius * t.radius;
                    if (n > r) return null;
                    const s = Math.sqrt(r - n),
                        a = i - s,
                        o = i + s;
                    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const i = -(this.origin.dot(t.normal) + t.constant) / e;
                    return i >= 0 ? i : null
                }
                intersectPlane(t, e) {
                    const i = this.distanceToPlane(t);
                    return null === i ? null : this.at(i, e)
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    return t.normal.dot(this.direction) * e < 0
                }
                intersectBox(t, e) {
                    let i, n, r, s, a, o;
                    const l = 1 / this.direction.x,
                        h = 1 / this.direction.y,
                        c = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, s = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, s = (t.min.y - u.y) * h), i > s || r > n ? null : ((r > i || i !== i) && (i = r), (s < n || n !== n) && (n = s), c >= 0 ? (a = (t.min.z - u.z) * c, o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, o = (t.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i !== i) && (i = a), (o < n || n !== n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, Hn)
                }
                intersectTriangle(t, e, i, n, r) {
                    Vn.subVectors(e, t), Gn.subVectors(i, t), Wn.crossVectors(Vn, Gn);
                    let s, a = this.direction.dot(Wn);
                    if (a > 0) {
                        if (n) return null;
                        s = 1
                    } else {
                        if (!(a < 0)) return null;
                        s = -1, a = -a
                    }
                    kn.subVectors(this.origin, t);
                    const o = s * this.direction.dot(Gn.crossVectors(kn, Gn));
                    if (o < 0) return null;
                    const l = s * this.direction.dot(Vn.cross(kn));
                    if (l < 0) return null;
                    if (o + l > a) return null;
                    const h = -s * kn.dot(Wn);
                    return h < 0 ? null : this.at(h / a, r)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class qn {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
                    const g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new qn).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                }
                copyPosition(t) {
                    const e = this.elements,
                        i = t.elements;
                    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                }
                setFromMatrix3(t) {
                    const e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                }
                makeBasis(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    const e = this.elements,
                        i = t.elements,
                        n = 1 / Xn.setFromMatrixColumn(t, 0).length(),
                        r = 1 / Xn.setFromMatrixColumn(t, 1).length(),
                        s = 1 / Xn.setFromMatrixColumn(t, 2).length();
                    return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * s, e[9] = i[9] * s, e[10] = i[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z,
                        s = Math.cos(i),
                        a = Math.sin(i),
                        o = Math.cos(n),
                        l = Math.sin(n),
                        h = Math.cos(r),
                        c = Math.sin(r);
                    if ("XYZ" === t.order) {
                        const t = s * h,
                            i = s * c,
                            n = a * h,
                            r = a * c;
                        e[0] = o * h, e[4] = -o * c, e[8] = l, e[1] = i + n * l, e[5] = t - r * l, e[9] = -a * o, e[2] = r - t * l, e[6] = n + i * l, e[10] = s * o
                    } else if ("YXZ" === t.order) {
                        const t = o * h,
                            i = o * c,
                            n = l * h,
                            r = l * c;
                        e[0] = t + r * a, e[4] = n * a - i, e[8] = s * l, e[1] = s * c, e[5] = s * h, e[9] = -a, e[2] = i * a - n, e[6] = r + t * a, e[10] = s * o
                    } else if ("ZXY" === t.order) {
                        const t = o * h,
                            i = o * c,
                            n = l * h,
                            r = l * c;
                        e[0] = t - r * a, e[4] = -s * c, e[8] = n + i * a, e[1] = i + n * a, e[5] = s * h, e[9] = r - t * a, e[2] = -s * l, e[6] = a, e[10] = s * o
                    } else if ("ZYX" === t.order) {
                        const t = s * h,
                            i = s * c,
                            n = a * h,
                            r = a * c;
                        e[0] = o * h, e[4] = n * l - i, e[8] = t * l + r, e[1] = o * c, e[5] = r * l + t, e[9] = i * l - n, e[2] = -l, e[6] = a * o, e[10] = s * o
                    } else if ("YZX" === t.order) {
                        const t = s * o,
                            i = s * l,
                            n = a * o,
                            r = a * l;
                        e[0] = o * h, e[4] = r - t * c, e[8] = n * c + i, e[1] = c, e[5] = s * h, e[9] = -a * h, e[2] = -l * h, e[6] = i * c + n, e[10] = t - r * c
                    } else if ("XZY" === t.order) {
                        const t = s * o,
                            i = s * l,
                            n = a * o,
                            r = a * l;
                        e[0] = o * h, e[4] = -c, e[8] = l * h, e[1] = t * c + r, e[5] = s * h, e[9] = i * c - n, e[2] = n * c - i, e[6] = a * h, e[10] = r * c + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(Jn, t, Zn)
                }
                lookAt(t, e, i) {
                    const n = this.elements;
                    return $n.subVectors(t, e), 0 === $n.lengthSq() && ($n.z = 1), $n.normalize(), Qn.crossVectors(i, $n), 0 === Qn.lengthSq() && (1 === Math.abs(i.z) ? $n.x += 1e-4 : $n.z += 1e-4, $n.normalize(), Qn.crossVectors(i, $n)), Qn.normalize(), Kn.crossVectors($n, Qn), n[0] = Qn.x, n[4] = Kn.x, n[8] = $n.x, n[1] = Qn.y, n[5] = Kn.y, n[9] = $n.y, n[2] = Qn.z, n[6] = Kn.z, n[10] = $n.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        s = i[0],
                        a = i[4],
                        o = i[8],
                        l = i[12],
                        h = i[1],
                        c = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        m = i[6],
                        f = i[10],
                        g = i[14],
                        y = i[3],
                        x = i[7],
                        v = i[11],
                        _ = i[15],
                        b = n[0],
                        M = n[4],
                        w = n[8],
                        S = n[12],
                        E = n[1],
                        T = n[5],
                        A = n[9],
                        C = n[13],
                        R = n[2],
                        L = n[6],
                        P = n[10],
                        z = n[14],
                        D = n[3],
                        I = n[7],
                        N = n[11],
                        O = n[15];
                    return r[0] = s * b + a * E + o * R + l * D, r[4] = s * M + a * T + o * L + l * I, r[8] = s * w + a * A + o * P + l * N, r[12] = s * S + a * C + o * z + l * O, r[1] = h * b + c * E + u * R + d * D, r[5] = h * M + c * T + u * L + d * I, r[9] = h * w + c * A + u * P + d * N, r[13] = h * S + c * C + u * z + d * O, r[2] = p * b + m * E + f * R + g * D, r[6] = p * M + m * T + f * L + g * I, r[10] = p * w + m * A + f * P + g * N, r[14] = p * S + m * C + f * z + g * O, r[3] = y * b + x * E + v * R + _ * D, r[7] = y * M + x * T + v * L + _ * I, r[11] = y * w + x * A + v * P + _ * N, r[15] = y * S + x * C + v * z + _ * O, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        i = t[4],
                        n = t[8],
                        r = t[12],
                        s = t[1],
                        a = t[5],
                        o = t[9],
                        l = t[13],
                        h = t[2],
                        c = t[6],
                        u = t[10],
                        d = t[14];
                    return t[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + t[11] * (+e * l * c - e * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + t[15] * (-n * a * h - e * o * c + e * a * u + n * s * c - i * s * u + i * o * h)
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(t, e, i) {
                    const n = this.elements;
                    return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8],
                        c = t[9],
                        u = t[10],
                        d = t[11],
                        p = t[12],
                        m = t[13],
                        f = t[14],
                        g = t[15],
                        y = c * f * l - m * u * l + m * o * d - a * f * d - c * o * g + a * u * g,
                        x = p * u * l - h * f * l - p * o * d + s * f * d + h * o * g - s * u * g,
                        v = h * m * l - p * c * l + p * a * d - s * m * d - h * a * g + s * c * g,
                        _ = p * c * o - h * m * o - p * a * u + s * m * u + h * a * f - s * c * f,
                        b = e * y + i * x + n * v + r * _;
                    if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const M = 1 / b;
                    return t[0] = y * M, t[1] = (m * u * r - c * f * r - m * n * d + i * f * d + c * n * g - i * u * g) * M, t[2] = (a * f * r - m * o * r + m * n * l - i * f * l - a * n * g + i * o * g) * M, t[3] = (c * o * r - a * u * r - c * n * l + i * u * l + a * n * d - i * o * d) * M, t[4] = x * M, t[5] = (h * f * r - p * u * r + p * n * d - e * f * d - h * n * g + e * u * g) * M, t[6] = (p * o * r - s * f * r - p * n * l + e * f * l + s * n * g - e * o * g) * M, t[7] = (s * u * r - h * o * r + h * n * l - e * u * l - s * n * d + e * o * d) * M, t[8] = v * M, t[9] = (p * c * r - h * m * r - p * i * d + e * m * d + h * i * g - e * c * g) * M, t[10] = (s * m * r - p * a * r + p * i * l - e * m * l - s * i * g + e * a * g) * M, t[11] = (h * a * r - s * c * r - h * i * l + e * c * l + s * i * d - e * a * d) * M, t[12] = _ * M, t[13] = (h * m * n - p * c * n + p * i * u - e * m * u - h * i * f + e * c * f) * M, t[14] = (p * a * n - s * m * n - p * i * o + e * m * o + s * i * f - e * a * f) * M, t[15] = (s * c * n - h * a * n + h * i * o - e * c * o - s * i * u + e * a * u) * M, this
                }
                scale(t) {
                    const e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z;
                    return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, i, n))
                }
                makeTranslation(t, e, i) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    const i = Math.cos(e),
                        n = Math.sin(e),
                        r = 1 - i,
                        s = t.x,
                        a = t.y,
                        o = t.z,
                        l = r * s,
                        h = r * a;
                    return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, h * a + i, h * o - n * s, 0, l * o - n * a, h * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, i, n, r, s) {
                    return this.set(1, i, r, 0, t, 1, s, 0, e, n, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, i) {
                    const n = this.elements,
                        r = e._x,
                        s = e._y,
                        a = e._z,
                        o = e._w,
                        l = r + r,
                        h = s + s,
                        c = a + a,
                        u = r * l,
                        d = r * h,
                        p = r * c,
                        m = s * h,
                        f = s * c,
                        g = a * c,
                        y = o * l,
                        x = o * h,
                        v = o * c,
                        _ = i.x,
                        b = i.y,
                        M = i.z;
                    return n[0] = (1 - (m + g)) * _, n[1] = (d + v) * _, n[2] = (p - x) * _, n[3] = 0, n[4] = (d - v) * b, n[5] = (1 - (u + g)) * b, n[6] = (f + y) * b, n[7] = 0, n[8] = (p + x) * M, n[9] = (f - y) * M, n[10] = (1 - (u + m)) * M, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                }
                decompose(t, e, i) {
                    const n = this.elements;
                    let r = Xn.set(n[0], n[1], n[2]).length();
                    const s = Xn.set(n[4], n[5], n[6]).length(),
                        a = Xn.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Yn.copy(this);
                    const o = 1 / r,
                        l = 1 / s,
                        h = 1 / a;
                    return Yn.elements[0] *= o, Yn.elements[1] *= o, Yn.elements[2] *= o, Yn.elements[4] *= l, Yn.elements[5] *= l, Yn.elements[6] *= l, Yn.elements[8] *= h, Yn.elements[9] *= h, Yn.elements[10] *= h, e.setFromRotationMatrix(Yn), i.x = r, i.y = s, i.z = a, this
                }
                makePerspective(t, e, i, n, r, s) {
                    void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const a = this.elements,
                        o = 2 * r / (e - t),
                        l = 2 * r / (i - n),
                        h = (e + t) / (e - t),
                        c = (i + n) / (i - n),
                        u = -(s + r) / (s - r),
                        d = -2 * s * r / (s - r);
                    return a[0] = o, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = l, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                }
                makeOrthographic(t, e, i, n, r, s) {
                    const a = this.elements,
                        o = 1 / (e - t),
                        l = 1 / (i - n),
                        h = 1 / (s - r),
                        c = (e + t) * o,
                        u = (i + n) * l,
                        d = (s + r) * h;
                    return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                }
                equals(t) {
                    const e = this.elements,
                        i = t.elements;
                    for (let n = 0; n < 16; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                }
            }
            qn.prototype.isMatrix4 = !0;
            const Xn = new fn,
                Yn = new qn,
                Jn = new fn(0, 0, 0),
                Zn = new fn(1, 1, 1),
                Qn = new fn,
                Kn = new fn,
                $n = new fn,
                tr = new qn,
                er = new mn;
            class ir {
                constructor(t = 0, e = 0, i = 0, n = ir.DefaultOrder) {
                    this._x = t, this._y = e, this._z = i, this._order = n
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, i, n = this._order) {
                    return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e = this._order, i = !0) {
                    const n = t.elements,
                        r = n[0],
                        s = n[4],
                        a = n[8],
                        o = n[1],
                        l = n[5],
                        h = n[9],
                        c = n[2],
                        u = n[6],
                        d = n[10];
                    switch (e) {
                        case "XYZ":
                            this._y = Math.asin(Bi(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-Bi(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, r), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(Bi(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-Bi(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(Bi(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-Bi(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, d), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !0 === i && this._onChangeCallback(), this
                }
                setFromQuaternion(t, e, i) {
                    return tr.makeRotationFromQuaternion(t), this.setFromRotationMatrix(tr, e, i)
                }
                setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e)
                }
                reorder(t) {
                    return er.setFromEuler(this), this.setFromQuaternion(er, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            ir.prototype.isEuler = !0, ir.DefaultOrder = "XYZ", ir.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class nr {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = (1 << t | 0) >>> 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return 0 !== (this.mask & t.mask)
                }
                isEnabled(t) {
                    return 0 !== (this.mask & (1 << t | 0))
                }
            }
            let rr = 0;
            const sr = new fn,
                ar = new mn,
                or = new qn,
                lr = new fn,
                hr = new fn,
                cr = new fn,
                ur = new mn,
                dr = new fn(1, 0, 0),
                pr = new fn(0, 1, 0),
                mr = new fn(0, 0, 1),
                fr = {
                    type: "added"
                },
                gr = {
                    type: "removed"
                };
            class yr extends zi {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: rr++
                    }), this.uuid = Oi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = yr.DefaultUp.clone();
                    const t = new fn,
                        e = new ir,
                        i = new mn,
                        n = new fn(1, 1, 1);
                    e._onChange((function() {
                        i.setFromEuler(e, !1)
                    })), i._onChange((function() {
                        e.setFromQuaternion(i, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        modelViewMatrix: {
                            value: new qn
                        },
                        normalMatrix: {
                            value: new Gi
                        }
                    }), this.matrix = new qn, this.matrixWorld = new qn, this.matrixAutoUpdate = yr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new nr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(t) {
                    return this.quaternion.premultiply(t), this
                }
                setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                }
                setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0)
                }
                setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t)
                }
                setRotationFromQuaternion(t) {
                    this.quaternion.copy(t)
                }
                rotateOnAxis(t, e) {
                    return ar.setFromAxisAngle(t, e), this.quaternion.multiply(ar), this
                }
                rotateOnWorldAxis(t, e) {
                    return ar.setFromAxisAngle(t, e), this.quaternion.premultiply(ar), this
                }
                rotateX(t) {
                    return this.rotateOnAxis(dr, t)
                }
                rotateY(t) {
                    return this.rotateOnAxis(pr, t)
                }
                rotateZ(t) {
                    return this.rotateOnAxis(mr, t)
                }
                translateOnAxis(t, e) {
                    return sr.copy(t).applyQuaternion(this.quaternion), this.position.add(sr.multiplyScalar(e)), this
                }
                translateX(t) {
                    return this.translateOnAxis(dr, t)
                }
                translateY(t) {
                    return this.translateOnAxis(pr, t)
                }
                translateZ(t) {
                    return this.translateOnAxis(mr, t)
                }
                localToWorld(t) {
                    return t.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(t) {
                    return t.applyMatrix4(or.copy(this.matrixWorld).invert())
                }
                lookAt(t, e, i) {
                    t.isVector3 ? lr.copy(t) : lr.set(t, e, i);
                    const n = this.parent;
                    this.updateWorldMatrix(!0, !1), hr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? or.lookAt(hr, lr, this.up) : or.lookAt(lr, hr, this.up), this.quaternion.setFromRotationMatrix(or), n && (or.extractRotation(n.matrixWorld), ar.setFromRotationMatrix(or), this.quaternion.premultiply(ar.invert()))
                }
                add(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(fr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                }
                remove(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(gr)), this
                }
                removeFromParent() {
                    const t = this.parent;
                    return null !== t && t.remove(this), this
                }
                clear() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        e.parent = null, e.dispatchEvent(gr)
                    }
                    return this.children.length = 0, this
                }
                attach(t) {
                    return this.updateWorldMatrix(!0, !1), or.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), or.multiply(t.parent.matrixWorld)), t.applyMatrix4(or), this.add(t), t.updateWorldMatrix(!1, !0), this
                }
                getObjectById(t) {
                    return this.getObjectByProperty("id", t)
                }
                getObjectByName(t) {
                    return this.getObjectByProperty("name", t)
                }
                getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let i = 0, n = this.children.length; i < n; i++) {
                        const n = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== n) return n
                    }
                }
                getWorldPosition(t) {
                    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hr, t, cr), t
                }
                getWorldScale(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hr, ur, t), t
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                }
                raycast() {}
                traverse(t) {
                    t(this);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                }
                traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
                traverseAncestors(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                }
                updateWorldMatrix(t, e) {
                    const i = this.parent;
                    if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                        const t = this.children;
                        for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t,
                        i = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, i.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const n = {};

                    function r(e, i) {
                        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = r(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const i = e.shapes;
                            if (Array.isArray(i))
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    r(t.shapes, n)
                                } else r(t.shapes, i)
                        }
                    }
                    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let i = 0, n = this.material.length; i < n; i++) e.push(r(t.materials, this.material[i]));
                            n.material = e
                        } else n.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        n.children = [];
                        for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object)
                    }
                    if (this.animations.length > 0) {
                        n.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            const i = this.animations[e];
                            n.animations.push(r(t.animations, i))
                        }
                    }
                    if (e) {
                        const e = s(t.geometries),
                            n = s(t.materials),
                            r = s(t.textures),
                            a = s(t.images),
                            o = s(t.shapes),
                            l = s(t.skeletons),
                            h = s(t.animations),
                            c = s(t.nodes);
                        e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), h.length > 0 && (i.animations = h), c.length > 0 && (i.nodes = c)
                    }
                    return i.object = n, i;

                    function s(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                }
                clone(t) {
                    return (new this.constructor).copy(this, t)
                }
                copy(t, e = !0) {
                    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (let i = 0; i < t.children.length; i++) {
                            const e = t.children[i];
                            this.add(e.clone())
                        }
                    return this
                }
            }
            yr.DefaultUp = new fn(0, 1, 0), yr.DefaultMatrixAutoUpdate = !0, yr.prototype.isObject3D = !0;
            const xr = new fn,
                vr = new fn,
                _r = new fn,
                br = new fn,
                Mr = new fn,
                wr = new fn,
                Sr = new fn,
                Er = new fn,
                Tr = new fn,
                Ar = new fn;
            class Cr {
                constructor(t = new fn, e = new fn, i = new fn) {
                    this.a = t, this.b = e, this.c = i
                }
                static getNormal(t, e, i, n) {
                    n.subVectors(i, e), xr.subVectors(t, e), n.cross(xr);
                    const r = n.lengthSq();
                    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                }
                static getBarycoord(t, e, i, n, r) {
                    xr.subVectors(n, e), vr.subVectors(i, e), _r.subVectors(t, e);
                    const s = xr.dot(xr),
                        a = xr.dot(vr),
                        o = xr.dot(_r),
                        l = vr.dot(vr),
                        h = vr.dot(_r),
                        c = s * l - a * a;
                    if (0 === c) return r.set(-2, -1, -1);
                    const u = 1 / c,
                        d = (l * o - a * h) * u,
                        p = (s * h - a * o) * u;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(t, e, i, n) {
                    return this.getBarycoord(t, e, i, n, br), br.x >= 0 && br.y >= 0 && br.x + br.y <= 1
                }
                static getUV(t, e, i, n, r, s, a, o) {
                    return this.getBarycoord(t, e, i, n, br), o.set(0, 0), o.addScaledVector(r, br.x), o.addScaledVector(s, br.y), o.addScaledVector(a, br.z), o
                }
                static isFrontFacing(t, e, i, n) {
                    return xr.subVectors(i, e), vr.subVectors(t, e), xr.cross(vr).dot(n) < 0
                }
                set(t, e, i) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                }
                setFromPointsAndIndices(t, e, i, n) {
                    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                }
                setFromAttributeAndIndices(t, e, i, n) {
                    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return xr.subVectors(this.c, this.b), vr.subVectors(this.a, this.b), .5 * xr.cross(vr).length()
                }
                getMidpoint(t) {
                    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return Cr.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return Cr.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getUV(t, e, i, n, r) {
                    return Cr.getUV(t, this.a, this.b, this.c, e, i, n, r)
                }
                containsPoint(t) {
                    return Cr.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return Cr.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(t, e) {
                    const i = this.a,
                        n = this.b,
                        r = this.c;
                    let s, a;
                    Mr.subVectors(n, i), wr.subVectors(r, i), Er.subVectors(t, i);
                    const o = Mr.dot(Er),
                        l = wr.dot(Er);
                    if (o <= 0 && l <= 0) return e.copy(i);
                    Tr.subVectors(t, n);
                    const h = Mr.dot(Tr),
                        c = wr.dot(Tr);
                    if (h >= 0 && c <= h) return e.copy(n);
                    const u = o * c - h * l;
                    if (u <= 0 && o >= 0 && h <= 0) return s = o / (o - h), e.copy(i).addScaledVector(Mr, s);
                    Ar.subVectors(t, r);
                    const d = Mr.dot(Ar),
                        p = wr.dot(Ar);
                    if (p >= 0 && d <= p) return e.copy(r);
                    const m = d * l - o * p;
                    if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(i).addScaledVector(wr, a);
                    const f = h * p - d * c;
                    if (f <= 0 && c - h >= 0 && d - p >= 0) return Sr.subVectors(r, n), a = (c - h) / (c - h + (d - p)), e.copy(n).addScaledVector(Sr, a);
                    const g = 1 / (f + m + u);
                    return s = m * g, a = u * g, e.copy(i).addScaledVector(Mr, s).addScaledVector(wr, a)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            let Rr = 0;
            class Lr extends zi {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Rr++
                    }), this.uuid = Oi(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Ve, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ai, this.stencilZFail = Ai, this.stencilZPass = Ai, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(t) {
                    this._alphaTest > 0 !== t > 0 && this.version++, this._alphaTest = t
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const i = t[e];
                            if (void 0 === i) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === e) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                                continue
                            }
                            const n = this[e];
                            void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        }
                }
                toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    const i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function n(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
                        const e = n(t.textures),
                            r = n(t.images);
                        e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r)
                    }
                    return i
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    const e = t.clippingPlanes;
                    let i = null;
                    if (null !== e) {
                        const t = e.length;
                        i = new Array(t);
                        for (let n = 0; n !== t; ++n) i[n] = e[n].clone()
                    }
                    return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
            }
            Lr.prototype.isMaterial = !0, Lr.fromType = function() {
                return null
            };
            class Pr extends Lr {
                constructor(t) {
                    super(), this.type = "MeshBasicMaterial", this.color = new nn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                }
            }
            Pr.prototype.isMeshBasicMaterial = !0;
            const zr = new fn,
                Dr = new Vi;
            class Ir {
                constructor(t, e, i) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.usage = Ci, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                copy(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                }
                copyAt(t, e, i) {
                    t *= this.itemSize, i *= e.itemSize;
                    for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                }
                copyArray(t) {
                    return this.array.set(t), this
                }
                copyColorsArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), r = new nn), e[i++] = r.r, e[i++] = r.g, e[i++] = r.b
                    }
                    return this
                }
                copyVector2sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), r = new Vi), e[i++] = r.x, e[i++] = r.y
                    }
                    return this
                }
                copyVector3sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), r = new fn), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z
                    }
                    return this
                }
                copyVector4sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), r = new cn), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z, e[i++] = r.w
                    }
                    return this
                }
                applyMatrix3(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, i = this.count; e < i; e++) Dr.fromBufferAttribute(this, e), Dr.applyMatrix3(t), this.setXY(e, Dr.x, Dr.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, i = this.count; e < i; e++) zr.fromBufferAttribute(this, e), zr.applyMatrix3(t), this.setXYZ(e, zr.x, zr.y, zr.z);
                    return this
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.count; e < i; e++) zr.fromBufferAttribute(this, e), zr.applyMatrix4(t), this.setXYZ(e, zr.x, zr.y, zr.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) zr.fromBufferAttribute(this, e), zr.applyNormalMatrix(t), this.setXYZ(e, zr.x, zr.y, zr.z);
                    return this
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) zr.fromBufferAttribute(this, e), zr.transformDirection(t), this.setXYZ(e, zr.x, zr.y, zr.z);
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                getX(t) {
                    return this.array[t * this.itemSize]
                }
                setX(t, e) {
                    return this.array[t * this.itemSize] = e, this
                }
                getY(t) {
                    return this.array[t * this.itemSize + 1]
                }
                setY(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                }
                getZ(t) {
                    return this.array[t * this.itemSize + 2]
                }
                setZ(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                }
                getW(t) {
                    return this.array[t * this.itemSize + 3]
                }
                setW(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                }
                setXY(t, e, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
                }
                setXYZ(t, e, i, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                }
                setXYZW(t, e, i, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const t = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (t.name = this.name), this.usage !== Ci && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                }
            }
            Ir.prototype.isBufferAttribute = !0;
            class Nr extends Ir {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i)
                }
            }
            class Or extends Ir {
                constructor(t, e, i) {
                    super(new Uint32Array(t), e, i)
                }
            }(class extends Ir {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i)
                }
            }).prototype.isFloat16BufferAttribute = !0;
            class Br extends Ir {
                constructor(t, e, i) {
                    super(new Float32Array(t), e, i)
                }
            }
            let Hr = 0;
            const Ur = new qn,
                Fr = new yr,
                kr = new fn,
                Vr = new xn,
                Gr = new xn,
                Wr = new fn;
            class jr extends zi {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Hr++
                    }), this.uuid = Oi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(t) {
                    return Array.isArray(t) ? this.index = new(Wi(t) ? Or : Nr)(t, 1) : this.index = t, this
                }
                getAttribute(t) {
                    return this.attributes[t]
                }
                setAttribute(t, e) {
                    return this.attributes[t] = e, this
                }
                deleteAttribute(t) {
                    return delete this.attributes[t], this
                }
                hasAttribute(t) {
                    return void 0 !== this.attributes[t]
                }
                addGroup(t, e, i = 0) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: i
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                }
                applyMatrix4(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    const i = this.attributes.normal;
                    if (void 0 !== i) {
                        const e = (new Gi).getNormalMatrix(t);
                        i.applyNormalMatrix(e), i.needsUpdate = !0
                    }
                    const n = this.attributes.tangent;
                    return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(t) {
                    return Ur.makeRotationFromQuaternion(t), this.applyMatrix4(Ur), this
                }
                rotateX(t) {
                    return Ur.makeRotationX(t), this.applyMatrix4(Ur), this
                }
                rotateY(t) {
                    return Ur.makeRotationY(t), this.applyMatrix4(Ur), this
                }
                rotateZ(t) {
                    return Ur.makeRotationZ(t), this.applyMatrix4(Ur), this
                }
                translate(t, e, i) {
                    return Ur.makeTranslation(t, e, i), this.applyMatrix4(Ur), this
                }
                scale(t, e, i) {
                    return Ur.makeScale(t, e, i), this.applyMatrix4(Ur), this
                }
                lookAt(t) {
                    return Fr.lookAt(t), Fr.updateMatrix(), this.applyMatrix4(Fr.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(kr).negate(), this.translate(kr.x, kr.y, kr.z), this
                }
                setFromPoints(t) {
                    const e = [];
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i];
                        e.push(n.x, n.y, n.z || 0)
                    }
                    return this.setAttribute("position", new Br(e, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new xn);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new fn(-1 / 0, -1 / 0, -1 / 0), new fn(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let i = 0, n = e.length; i < n; i++) {
                                const t = e[i];
                                Vr.setFromBufferAttribute(t), this.morphTargetsRelative ? (Wr.addVectors(this.boundingBox.min, Vr.min), this.boundingBox.expandByPoint(Wr), Wr.addVectors(this.boundingBox.max, Vr.max), this.boundingBox.expandByPoint(Wr)) : (this.boundingBox.expandByPoint(Vr.min), this.boundingBox.expandByPoint(Vr.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new Bn);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new fn, 1 / 0);
                    if (t) {
                        const i = this.boundingSphere.center;
                        if (Vr.setFromBufferAttribute(t), e)
                            for (let t = 0, r = e.length; t < r; t++) {
                                const i = e[t];
                                Gr.setFromBufferAttribute(i), this.morphTargetsRelative ? (Wr.addVectors(Vr.min, Gr.min), Vr.expandByPoint(Wr), Wr.addVectors(Vr.max, Gr.max), Vr.expandByPoint(Wr)) : (Vr.expandByPoint(Gr.min), Vr.expandByPoint(Gr.max))
                            }
                        Vr.getCenter(i);
                        let n = 0;
                        for (let e = 0, r = t.count; e < r; e++) Wr.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(Wr));
                        if (e)
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r],
                                    a = this.morphTargetsRelative;
                                for (let e = 0, r = s.count; e < r; e++) Wr.fromBufferAttribute(s, e), a && (kr.fromBufferAttribute(t, e), Wr.add(kr)), n = Math.max(n, i.distanceToSquared(Wr))
                            }
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const i = t.array,
                        n = e.position.array,
                        r = e.normal.array,
                        s = e.uv.array,
                        a = n.length / 3;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ir(new Float32Array(4 * a), 4));
                    const o = this.getAttribute("tangent").array,
                        l = [],
                        h = [];
                    for (let E = 0; E < a; E++) l[E] = new fn, h[E] = new fn;
                    const c = new fn,
                        u = new fn,
                        d = new fn,
                        p = new Vi,
                        m = new Vi,
                        f = new Vi,
                        g = new fn,
                        y = new fn;

                    function x(t, e, i) {
                        c.fromArray(n, 3 * t), u.fromArray(n, 3 * e), d.fromArray(n, 3 * i), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * i), u.sub(c), d.sub(c), m.sub(p), f.sub(p);
                        const r = 1 / (m.x * f.y - f.x * m.y);
                        isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), y.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[i].add(g), h[t].add(y), h[e].add(y), h[i].add(y))
                    }
                    let v = this.groups;
                    0 === v.length && (v = [{
                        start: 0,
                        count: i.length
                    }]);
                    for (let E = 0, T = v.length; E < T; ++E) {
                        const t = v[E],
                            e = t.start;
                        for (let n = e, r = e + t.count; n < r; n += 3) x(i[n + 0], i[n + 1], i[n + 2])
                    }
                    const _ = new fn,
                        b = new fn,
                        M = new fn,
                        w = new fn;

                    function S(t) {
                        M.fromArray(r, 3 * t), w.copy(M);
                        const e = l[t];
                        _.copy(e), _.sub(M.multiplyScalar(M.dot(e))).normalize(), b.crossVectors(w, e);
                        const i = b.dot(h[t]) < 0 ? -1 : 1;
                        o[4 * t] = _.x, o[4 * t + 1] = _.y, o[4 * t + 2] = _.z, o[4 * t + 3] = i
                    }
                    for (let E = 0, T = v.length; E < T; ++E) {
                        const t = v[E],
                            e = t.start;
                        for (let n = e, r = e + t.count; n < r; n += 3) S(i[n + 0]), S(i[n + 1]), S(i[n + 2])
                    }
                }
                computeVertexNormals() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let i = this.getAttribute("normal");
                        if (void 0 === i) i = new Ir(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                        else
                            for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
                        const n = new fn,
                            r = new fn,
                            s = new fn,
                            a = new fn,
                            o = new fn,
                            l = new fn,
                            h = new fn,
                            c = new fn;
                        if (t)
                            for (let u = 0, d = t.count; u < d; u += 3) {
                                const d = t.getX(u + 0),
                                    p = t.getX(u + 1),
                                    m = t.getX(u + 2);
                                n.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, p), l.fromBufferAttribute(i, m), a.add(h), o.add(h), l.add(h), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(m, l.x, l.y, l.z)
                            } else
                                for (let t = 0, u = e.count; t < u; t += 3) n.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), i.setXYZ(t + 0, h.x, h.y, h.z), i.setXYZ(t + 1, h.x, h.y, h.z), i.setXYZ(t + 2, h.x, h.y, h.z);
                        this.normalizeNormals(), i.needsUpdate = !0
                    }
                }
                merge(t, e) {
                    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const i = this.attributes;
                    for (const n in i) {
                        if (void 0 === t.attributes[n]) continue;
                        const r = i[n].array,
                            s = t.attributes[n],
                            a = s.array,
                            o = s.itemSize * e,
                            l = Math.min(a.length, r.length - o);
                        for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t]
                    }
                    return this
                }
                normalizeNormals() {
                    const t = this.attributes.normal;
                    for (let e = 0, i = t.count; e < i; e++) Wr.fromBufferAttribute(t, e), Wr.normalize(), t.setXYZ(e, Wr.x, Wr.y, Wr.z)
                }
                toNonIndexed() {
                    function t(t, e) {
                        const i = t.array,
                            n = t.itemSize,
                            r = t.normalized,
                            s = new i.constructor(e.length * n);
                        let a = 0,
                            o = 0;
                        for (let l = 0, h = e.length; l < h; l++) {
                            a = t.isInterleavedBufferAttribute ? e[l] * t.data.stride + t.offset : e[l] * n;
                            for (let t = 0; t < n; t++) s[o++] = i[a++]
                        }
                        return new Ir(s, n, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const e = new jr,
                        i = this.index.array,
                        n = this.attributes;
                    for (const a in n) {
                        const r = t(n[a], i);
                        e.setAttribute(a, r)
                    }
                    const r = this.morphAttributes;
                    for (const a in r) {
                        const n = [],
                            s = r[a];
                        for (let e = 0, r = s.length; e < r; e++) {
                            const r = t(s[e], i);
                            n.push(r)
                        }
                        e.morphAttributes[a] = n
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let a = 0, o = s.length; a < o; a++) {
                        const t = s[a];
                        e.addGroup(t.start, t.count, t.materialIndex)
                    }
                    return e
                }
                toJSON() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    const e = this.index;
                    null !== e && (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array)
                    });
                    const i = this.attributes;
                    for (const o in i) {
                        const e = i[o];
                        t.data.attributes[o] = e.toJSON(t.data)
                    }
                    const n = {};
                    let r = !1;
                    for (const o in this.morphAttributes) {
                        const e = this.morphAttributes[o],
                            i = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            i.push(r.toJSON(t.data))
                        }
                        i.length > 0 && (n[o] = i, r = !0)
                    }
                    r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    const a = this.boundingSphere;
                    return null !== a && (t.data.boundingSphere = {
                        center: a.center.toArray(),
                        radius: a.radius
                    }), t
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const e = {};
                    this.name = t.name;
                    const i = t.index;
                    null !== i && this.setIndex(i.clone(e));
                    const n = t.attributes;
                    for (const l in n) {
                        const t = n[l];
                        this.setAttribute(l, t.clone(e))
                    }
                    const r = t.morphAttributes;
                    for (const l in r) {
                        const t = [],
                            i = r[l];
                        for (let n = 0, r = i.length; n < r; n++) t.push(i[n].clone(e));
                        this.morphAttributes[l] = t
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const s = t.groups;
                    for (let l = 0, h = s.length; l < h; l++) {
                        const t = s[l];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const a = t.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    const o = t.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            jr.prototype.isBufferGeometry = !0;
            const qr = new qn,
                Xr = new jn,
                Yr = new Bn,
                Jr = new fn,
                Zr = new fn,
                Qr = new fn,
                Kr = new fn,
                $r = new fn,
                ts = new fn,
                es = new fn,
                is = new fn,
                ns = new fn,
                rs = new Vi,
                ss = new Vi,
                as = new Vi,
                os = new fn,
                ls = new fn;
            class hs extends yr {
                constructor(t = new jr, e = new Pr) {
                    super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(t) {
                    return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.material,
                        r = this.matrixWorld;
                    if (void 0 === n) return;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), Yr.copy(i.boundingSphere), Yr.applyMatrix4(r), !1 === t.ray.intersectsSphere(Yr)) return;
                    if (qr.copy(r).invert(), Xr.copy(t.ray).applyMatrix4(qr), null !== i.boundingBox && !1 === Xr.intersectsBox(i.boundingBox)) return;
                    let s;
                    if (i.isBufferGeometry) {
                        const r = i.index,
                            a = i.attributes.position,
                            o = i.morphAttributes.position,
                            l = i.morphTargetsRelative,
                            h = i.attributes.uv,
                            c = i.attributes.uv2,
                            u = i.groups,
                            d = i.drawRange;
                        if (null !== r)
                            if (Array.isArray(n))
                                for (let i = 0, p = u.length; i < p; i++) {
                                    const p = u[i],
                                        m = n[p.materialIndex];
                                    for (let i = Math.max(p.start, d.start), n = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); i < n; i += 3) {
                                        const n = r.getX(i),
                                            u = r.getX(i + 1),
                                            d = r.getX(i + 2);
                                        s = cs(this, m, t, Xr, a, o, l, h, c, n, u, d), s && (s.faceIndex = Math.floor(i / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                    }
                                } else {
                                    for (let i = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); i < u; i += 3) {
                                        const u = r.getX(i),
                                            d = r.getX(i + 1),
                                            p = r.getX(i + 2);
                                        s = cs(this, n, t, Xr, a, o, l, h, c, u, d, p), s && (s.faceIndex = Math.floor(i / 3), e.push(s))
                                    }
                                } else if (void 0 !== a)
                                    if (Array.isArray(n))
                                        for (let i = 0, p = u.length; i < p; i++) {
                                            const r = u[i],
                                                p = n[r.materialIndex];
                                            for (let i = Math.max(r.start, d.start), n = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); i < n; i += 3) {
                                                s = cs(this, p, t, Xr, a, o, l, h, c, i, i + 1, i + 2), s && (s.faceIndex = Math.floor(i / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                            }
                                        } else {
                                            for (let i = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); i < r; i += 3) {
                                                s = cs(this, n, t, Xr, a, o, l, h, c, i, i + 1, i + 2), s && (s.faceIndex = Math.floor(i / 3), e.push(s))
                                            }
                                        }
                    } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }

            function cs(t, e, i, n, r, s, a, o, l, h, c, u) {
                Jr.fromBufferAttribute(r, h), Zr.fromBufferAttribute(r, c), Qr.fromBufferAttribute(r, u);
                const d = t.morphTargetInfluences;
                if (s && d) {
                    es.set(0, 0, 0), is.set(0, 0, 0), ns.set(0, 0, 0);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = d[t],
                            i = s[t];
                        0 !== e && (Kr.fromBufferAttribute(i, h), $r.fromBufferAttribute(i, c), ts.fromBufferAttribute(i, u), a ? (es.addScaledVector(Kr, e), is.addScaledVector($r, e), ns.addScaledVector(ts, e)) : (es.addScaledVector(Kr.sub(Jr), e), is.addScaledVector($r.sub(Zr), e), ns.addScaledVector(ts.sub(Qr), e)))
                    }
                    Jr.add(es), Zr.add(is), Qr.add(ns)
                }
                t.isSkinnedMesh && (t.boneTransform(h, Jr), t.boneTransform(c, Zr), t.boneTransform(u, Qr));
                const p = function(t, e, i, n, r, s, a, o) {
                    let l;
                    if (l = 1 === e.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
                    ls.copy(o), ls.applyMatrix4(t.matrixWorld);
                    const h = i.ray.origin.distanceTo(ls);
                    return h < i.near || h > i.far ? null : {
                        distance: h,
                        point: ls.clone(),
                        object: t
                    }
                }(t, e, i, n, Jr, Zr, Qr, os);
                if (p) {
                    o && (rs.fromBufferAttribute(o, h), ss.fromBufferAttribute(o, c), as.fromBufferAttribute(o, u), p.uv = Cr.getUV(os, Jr, Zr, Qr, rs, ss, as, new Vi)), l && (rs.fromBufferAttribute(l, h), ss.fromBufferAttribute(l, c), as.fromBufferAttribute(l, u), p.uv2 = Cr.getUV(os, Jr, Zr, Qr, rs, ss, as, new Vi));
                    const t = {
                        a: h,
                        b: c,
                        c: u,
                        normal: new fn,
                        materialIndex: 0
                    };
                    Cr.getNormal(Jr, Zr, Qr, t.normal), p.face = t
                }
                return p
            }
            hs.prototype.isMesh = !0;
            class us extends jr {
                constructor(t = 1, e = 1, i = 1, n = 1, r = 1, s = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: t,
                        height: e,
                        depth: i,
                        widthSegments: n,
                        heightSegments: r,
                        depthSegments: s
                    };
                    const a = this;
                    n = Math.floor(n), r = Math.floor(r), s = Math.floor(s);
                    const o = [],
                        l = [],
                        h = [],
                        c = [];
                    let u = 0,
                        d = 0;

                    function p(t, e, i, n, r, s, p, m, f, g, y) {
                        const x = s / f,
                            v = p / g,
                            _ = s / 2,
                            b = p / 2,
                            M = m / 2,
                            w = f + 1,
                            S = g + 1;
                        let E = 0,
                            T = 0;
                        const A = new fn;
                        for (let a = 0; a < S; a++) {
                            const s = a * v - b;
                            for (let o = 0; o < w; o++) {
                                const u = o * x - _;
                                A[t] = u * n, A[e] = s * r, A[i] = M, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[i] = m > 0 ? 1 : -1, h.push(A.x, A.y, A.z), c.push(o / f), c.push(1 - a / g), E += 1
                            }
                        }
                        for (let a = 0; a < g; a++)
                            for (let t = 0; t < f; t++) {
                                const e = u + t + w * a,
                                    i = u + t + w * (a + 1),
                                    n = u + (t + 1) + w * (a + 1),
                                    r = u + (t + 1) + w * a;
                                o.push(e, i, r), o.push(i, n, r), T += 6
                            }
                        a.addGroup(d, T, y), d += T, u += E
                    }
                    p("z", "y", "x", -1, -1, i, e, t, s, r, 0), p("z", "y", "x", 1, -1, i, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, s, 2), p("x", "z", "y", 1, -1, t, i, -e, n, s, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new Br(l, 3)), this.setAttribute("normal", new Br(h, 3)), this.setAttribute("uv", new Br(c, 2))
                }
                static fromJSON(t) {
                    return new us(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                }
            }

            function ds(t) {
                const e = {};
                for (const i in t) {
                    e[i] = {};
                    for (const n in t[i]) {
                        const r = t[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                    }
                }
                return e
            }

            function ps(t) {
                const e = {};
                for (let i = 0; i < t.length; i++) {
                    const n = ds(t[i]);
                    for (const t in n) e[t] = n[t]
                }
                return e
            }
            const ms = {
                clone: ds,
                merge: ps
            };
            class fs extends Lr {
                constructor(t) {
                    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                }
                copy(t) {
                    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ds(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    e.glslVersion = this.glslVersion, e.uniforms = {};
                    for (const n in this.uniforms) {
                        const i = this.uniforms[n].value;
                        i && i.isTexture ? e.uniforms[n] = {
                            type: "t",
                            value: i.toJSON(t).uuid
                        } : i && i.isColor ? e.uniforms[n] = {
                            type: "c",
                            value: i.getHex()
                        } : i && i.isVector2 ? e.uniforms[n] = {
                            type: "v2",
                            value: i.toArray()
                        } : i && i.isVector3 ? e.uniforms[n] = {
                            type: "v3",
                            value: i.toArray()
                        } : i && i.isVector4 ? e.uniforms[n] = {
                            type: "v4",
                            value: i.toArray()
                        } : i && i.isMatrix3 ? e.uniforms[n] = {
                            type: "m3",
                            value: i.toArray()
                        } : i && i.isMatrix4 ? e.uniforms[n] = {
                            type: "m4",
                            value: i.toArray()
                        } : e.uniforms[n] = {
                            value: i
                        }
                    }
                    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                    const i = {};
                    for (const n in this.extensions) !0 === this.extensions[n] && (i[n] = !0);
                    return Object.keys(i).length > 0 && (e.extensions = i), e
                }
            }
            fs.prototype.isShaderMaterial = !0;
            class gs extends yr {
                constructor() {
                    super(), this.type = "Camera", this.matrixWorldInverse = new qn, this.projectionMatrix = new qn, this.projectionMatrixInverse = new qn
                }
                copy(t, e) {
                    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(t, e) {
                    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            gs.prototype.isCamera = !0;
            class ys extends gs {
                constructor(t = 50, e = 1, i = .1, n = 2e3) {
                    super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(t, e) {
                    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                }
                setFocalLength(t) {
                    const e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Ni * Math.atan(e), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const t = Math.tan(.5 * Ii * this.fov);
                    return .5 * this.getFilmHeight() / t
                }
                getEffectiveFOV() {
                    return 2 * Ni * Math.atan(Math.tan(.5 * Ii * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(t, e, i, n, r, s) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const t = this.near;
                    let e = t * Math.tan(.5 * Ii * this.fov) / this.zoom,
                        i = 2 * e,
                        n = this.aspect * i,
                        r = -.5 * n;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = s.fullWidth,
                            a = s.fullHeight;
                        r += s.offsetX * n / t, e -= s.offsetY * i / a, n *= s.width / t, i *= s.height / a
                    }
                    const a = this.filmOffset;
                    0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }
            ys.prototype.isPerspectiveCamera = !0;
            const xs = 90;
            class vs extends yr {
                constructor(t, e, i) {
                    if (super(), this.type = "CubeCamera", !0 !== i.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = i;
                    const n = new ys(xs, 1, t, e);
                    n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new fn(1, 0, 0)), this.add(n);
                    const r = new ys(xs, 1, t, e);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new fn(-1, 0, 0)), this.add(r);
                    const s = new ys(xs, 1, t, e);
                    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new fn(0, 1, 0)), this.add(s);
                    const a = new ys(xs, 1, t, e);
                    a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new fn(0, -1, 0)), this.add(a);
                    const o = new ys(xs, 1, t, e);
                    o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new fn(0, 0, 1)), this.add(o);
                    const l = new ys(xs, 1, t, e);
                    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new fn(0, 0, -1)), this.add(l)
                }
                update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const i = this.renderTarget,
                        [n, r, s, a, o, l] = this.children,
                        h = t.getRenderTarget(),
                        c = t.outputEncoding,
                        u = t.toneMapping,
                        d = t.xr.enabled;
                    t.outputEncoding = wi, t.toneMapping = 0, t.xr.enabled = !1;
                    const p = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0), t.render(e, n), t.setRenderTarget(i, 1), t.render(e, r), t.setRenderTarget(i, 2), t.render(e, s), t.setRenderTarget(i, 3), t.render(e, a), t.setRenderTarget(i, 4), t.render(e, o), i.texture.generateMipmaps = p, t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(h), t.outputEncoding = c, t.toneMapping = u, t.xr.enabled = d, i.texture.needsPMREMUpdate = !0
                }
            }
            class _s extends hn {
                constructor(t, e, i, n, r, s, a, o, l, h) {
                    super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Ge, i, n, r, s, a, o, l, h), this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(t) {
                    this.image = t
                }
            }
            _s.prototype.isCubeTexture = !0;
            class bs extends un {
                constructor(t, e = {}) {
                    super(t, t, e);
                    const i = {
                            width: t,
                            height: t,
                            depth: 1
                        },
                        n = [i, i, i, i, i, i];
                    this.texture = new _s(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : ti
                }
                fromEquirectangularTexture(t, e) {
                    this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                    const i = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                        },
                        n = new us(5, 5, 5),
                        r = new fs({
                            name: "CubemapFromEquirect",
                            uniforms: ds(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader,
                            side: 1,
                            blending: 0
                        });
                    r.uniforms.tEquirect.value = e;
                    const s = new hs(n, r),
                        a = e.minFilter;
                    e.minFilter === ii && (e.minFilter = ti);
                    return new vs(1, 10, this).update(t, s), e.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
                }
                clear(t, e, i, n) {
                    const r = t.getRenderTarget();
                    for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, i, n);
                    t.setRenderTarget(r)
                }
            }
            bs.prototype.isWebGLCubeRenderTarget = !0;
            const Ms = new fn,
                ws = new fn,
                Ss = new Gi;
            class Es {
                constructor(t = new fn(1, 0, 0), e = 0) {
                    this.normal = t, this.constant = e
                }
                set(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                }
                setComponents(t, e, i, n) {
                    return this.normal.set(t, e, i), this.constant = n, this
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                }
                setFromCoplanarPoints(t, e, i) {
                    const n = Ms.subVectors(i, e).cross(ws.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(n, t), this
                }
                copy(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius
                }
                projectPoint(t, e) {
                    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                }
                intersectLine(t, e) {
                    const i = t.delta(Ms),
                        n = this.normal.dot(i);
                    if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                    const r = -(t.start.dot(this.normal) + this.constant) / n;
                    return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start)
                }
                intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                        i = this.distanceToPoint(t.end);
                    return e < 0 && i > 0 || i < 0 && e > 0
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this)
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this)
                }
                coplanarPoint(t) {
                    return t.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(t, e) {
                    const i = e || Ss.getNormalMatrix(t),
                        n = this.coplanarPoint(Ms).applyMatrix4(t),
                        r = this.normal.applyMatrix3(i).normalize();
                    return this.constant = -n.dot(r), this
                }
                translate(t) {
                    return this.constant -= t.dot(this.normal), this
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            Es.prototype.isPlane = !0;
            const Ts = new Bn,
                As = new fn;
            class Cs {
                constructor(t = new Es, e = new Es, i = new Es, n = new Es, r = new Es, s = new Es) {
                    this.planes = [t, e, i, n, r, s]
                }
                set(t, e, i, n, r, s) {
                    const a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this
                }
                copy(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                    return this
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        i = t.elements,
                        n = i[0],
                        r = i[1],
                        s = i[2],
                        a = i[3],
                        o = i[4],
                        l = i[5],
                        h = i[6],
                        c = i[7],
                        u = i[8],
                        d = i[9],
                        p = i[10],
                        m = i[11],
                        f = i[12],
                        g = i[13],
                        y = i[14],
                        x = i[15];
                    return e[0].setComponents(a - n, c - o, m - u, x - f).normalize(), e[1].setComponents(a + n, c + o, m + u, x + f).normalize(), e[2].setComponents(a + r, c + l, m + d, x + g).normalize(), e[3].setComponents(a - r, c - l, m - d, x - g).normalize(), e[4].setComponents(a - s, c - h, m - p, x - y).normalize(), e[5].setComponents(a + s, c + h, m + p, x + y).normalize(), this
                }
                intersectsObject(t) {
                    const e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), Ts.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ts)
                }
                intersectsSprite(t) {
                    return Ts.center.set(0, 0, 0), Ts.radius = .7071067811865476, Ts.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ts)
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        i = t.center,
                        n = -t.radius;
                    for (let r = 0; r < 6; r++) {
                        if (e[r].distanceToPoint(i) < n) return !1
                    }
                    return !0
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) {
                        const n = e[i];
                        if (As.x = n.normal.x > 0 ? t.max.x : t.min.x, As.y = n.normal.y > 0 ? t.max.y : t.min.y, As.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(As) < 0) return !1
                    }
                    return !0
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++)
                        if (e[i].distanceToPoint(t) < 0) return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }

            function Rs() {
                let t = null,
                    e = !1,
                    i = null,
                    n = null;

                function r(e, s) {
                    i(e, s), n = t.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== e && null !== i && (n = t.requestAnimationFrame(r), e = !0)
                    },
                    stop: function() {
                        t.cancelAnimationFrame(n), e = !1
                    },
                    setAnimationLoop: function(t) {
                        i = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function Ls(t, e) {
                const i = e.isWebGL2,
                    n = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
                    },
                    remove: function(e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const i = n.get(e);
                        i && (t.deleteBuffer(i.buffer), n.delete(e))
                    },
                    update: function(e, r) {
                        if (e.isGLBufferAttribute) {
                            const t = n.get(e);
                            return void((!t || t.version < e.version) && n.set(e, {
                                buffer: e.buffer,
                                type: e.type,
                                bytesPerElement: e.elementSize,
                                version: e.version
                            }))
                        }
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const s = n.get(e);
                        void 0 === s ? n.set(e, function(e, n) {
                            const r = e.array,
                                s = e.usage,
                                a = t.createBuffer();
                            let o;
                            if (t.bindBuffer(n, a), t.bufferData(n, r, s), e.onUploadCallback(), r instanceof Float32Array) o = 5126;
                            else if (r instanceof Uint16Array)
                                if (e.isFloat16BufferAttribute) {
                                    if (!i) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                    o = 5131
                                } else o = 5123;
                            else if (r instanceof Int16Array) o = 5122;
                            else if (r instanceof Uint32Array) o = 5125;
                            else if (r instanceof Int32Array) o = 5124;
                            else if (r instanceof Int8Array) o = 5120;
                            else if (r instanceof Uint8Array) o = 5121;
                            else {
                                if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                                o = 5121
                            }
                            return {
                                buffer: a,
                                type: o,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(e, r)) : s.version < e.version && (! function(e, n, r) {
                            const s = n.array,
                                a = n.updateRange;
                            t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (i ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                        }(s.buffer, e, r), s.version = e.version)
                    }
                }
            }
            class Ps extends jr {
                constructor(t = 1, e = 1, i = 1, n = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: i,
                        heightSegments: n
                    };
                    const r = t / 2,
                        s = e / 2,
                        a = Math.floor(i),
                        o = Math.floor(n),
                        l = a + 1,
                        h = o + 1,
                        c = t / a,
                        u = e / o,
                        d = [],
                        p = [],
                        m = [],
                        f = [];
                    for (let g = 0; g < h; g++) {
                        const t = g * u - s;
                        for (let e = 0; e < l; e++) {
                            const i = e * c - r;
                            p.push(i, -t, 0), m.push(0, 0, 1), f.push(e / a), f.push(1 - g / o)
                        }
                    }
                    for (let g = 0; g < o; g++)
                        for (let t = 0; t < a; t++) {
                            const e = t + l * g,
                                i = t + l * (g + 1),
                                n = t + 1 + l * (g + 1),
                                r = t + 1 + l * g;
                            d.push(e, i, r), d.push(i, n, r)
                        }
                    this.setIndex(d), this.setAttribute("position", new Br(p, 3)), this.setAttribute("normal", new Br(m, 3)), this.setAttribute("uv", new Br(f, 2))
                }
                static fromJSON(t) {
                    return new Ps(t.width, t.height, t.widthSegments, t.heightSegments)
                }
            }
            const zs = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                },
                Ds = {
                    common: {
                        diffuse: {
                            value: new nn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Gi
                        },
                        uv2Transform: {
                            value: new Gi
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Vi(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new nn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new nn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Gi
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new nn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Vi(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Gi
                        }
                    }
                },
                Is = {
                    basic: {
                        uniforms: ps([Ds.common, Ds.specularmap, Ds.envmap, Ds.aomap, Ds.lightmap, Ds.fog]),
                        vertexShader: zs.meshbasic_vert,
                        fragmentShader: zs.meshbasic_frag
                    },
                    lambert: {
                        uniforms: ps([Ds.common, Ds.specularmap, Ds.envmap, Ds.aomap, Ds.lightmap, Ds.emissivemap, Ds.fog, Ds.lights, {
                            emissive: {
                                value: new nn(0)
                            }
                        }]),
                        vertexShader: zs.meshlambert_vert,
                        fragmentShader: zs.meshlambert_frag
                    },
                    phong: {
                        uniforms: ps([Ds.common, Ds.specularmap, Ds.envmap, Ds.aomap, Ds.lightmap, Ds.emissivemap, Ds.bumpmap, Ds.normalmap, Ds.displacementmap, Ds.fog, Ds.lights, {
                            emissive: {
                                value: new nn(0)
                            },
                            specular: {
                                value: new nn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: zs.meshphong_vert,
                        fragmentShader: zs.meshphong_frag
                    },
                    standard: {
                        uniforms: ps([Ds.common, Ds.envmap, Ds.aomap, Ds.lightmap, Ds.emissivemap, Ds.bumpmap, Ds.normalmap, Ds.displacementmap, Ds.roughnessmap, Ds.metalnessmap, Ds.fog, Ds.lights, {
                            emissive: {
                                value: new nn(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: zs.meshphysical_vert,
                        fragmentShader: zs.meshphysical_frag
                    },
                    toon: {
                        uniforms: ps([Ds.common, Ds.aomap, Ds.lightmap, Ds.emissivemap, Ds.bumpmap, Ds.normalmap, Ds.displacementmap, Ds.gradientmap, Ds.fog, Ds.lights, {
                            emissive: {
                                value: new nn(0)
                            }
                        }]),
                        vertexShader: zs.meshtoon_vert,
                        fragmentShader: zs.meshtoon_frag
                    },
                    matcap: {
                        uniforms: ps([Ds.common, Ds.bumpmap, Ds.normalmap, Ds.displacementmap, Ds.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: zs.meshmatcap_vert,
                        fragmentShader: zs.meshmatcap_frag
                    },
                    points: {
                        uniforms: ps([Ds.points, Ds.fog]),
                        vertexShader: zs.points_vert,
                        fragmentShader: zs.points_frag
                    },
                    dashed: {
                        uniforms: ps([Ds.common, Ds.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: zs.linedashed_vert,
                        fragmentShader: zs.linedashed_frag
                    },
                    depth: {
                        uniforms: ps([Ds.common, Ds.displacementmap]),
                        vertexShader: zs.depth_vert,
                        fragmentShader: zs.depth_frag
                    },
                    normal: {
                        uniforms: ps([Ds.common, Ds.bumpmap, Ds.normalmap, Ds.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: zs.meshnormal_vert,
                        fragmentShader: zs.meshnormal_frag
                    },
                    sprite: {
                        uniforms: ps([Ds.sprite, Ds.fog]),
                        vertexShader: zs.sprite_vert,
                        fragmentShader: zs.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Gi
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: zs.background_vert,
                        fragmentShader: zs.background_frag
                    },
                    cube: {
                        uniforms: ps([Ds.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: zs.cube_vert,
                        fragmentShader: zs.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: zs.equirect_vert,
                        fragmentShader: zs.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: ps([Ds.common, Ds.displacementmap, {
                            referencePosition: {
                                value: new fn
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: zs.distanceRGBA_vert,
                        fragmentShader: zs.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: ps([Ds.lights, Ds.fog, {
                            color: {
                                value: new nn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: zs.shadow_vert,
                        fragmentShader: zs.shadow_frag
                    }
                };

            function Ns(t, e, i, n, r, s) {
                const a = new nn(0);
                let o, l, h = !0 === r ? 0 : 1,
                    c = null,
                    u = 0,
                    d = null;

                function p(t, e) {
                    i.buffers.color.setClear(t.r, t.g, t.b, e, s)
                }
                return {
                    getClearColor: function() {
                        return a
                    },
                    setClearColor: function(t, e = 1) {
                        a.set(t), h = e, p(a, h)
                    },
                    getClearAlpha: function() {
                        return h
                    },
                    setClearAlpha: function(t) {
                        h = t, p(a, h)
                    },
                    render: function(i, r) {
                        let s = !1,
                            m = !0 === r.isScene ? r.background : null;
                        m && m.isTexture && (m = e.get(m));
                        const f = t.xr,
                            g = f.getSession && f.getSession();
                        g && "additive" === g.environmentBlendMode && (m = null), null === m ? p(a, h) : m && m.isColor && (p(m, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.mapping === Xe) ? (void 0 === l && (l = new hs(new us(1, 1, 1), new fs({
                            name: "BackgroundCubeMaterial",
                            uniforms: ds(Is.cube.uniforms),
                            vertexShader: Is.cube.vertexShader,
                            fragmentShader: Is.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, i) {
                            this.matrixWorld.copyPosition(i.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), n.update(l)), l.material.uniforms.envMap.value = m, l.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, c === m && u === m.version && d === t.toneMapping || (l.material.needsUpdate = !0, c = m, u = m.version, d = t.toneMapping), i.unshift(l, l.geometry, l.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new hs(new Ps(2, 2), new fs({
                            name: "BackgroundMaterial",
                            uniforms: ds(Is.background.uniforms),
                            vertexShader: Is.background.vertexShader,
                            fragmentShader: Is.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), n.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), c === m && u === m.version && d === t.toneMapping || (o.material.needsUpdate = !0, c = m, u = m.version, d = t.toneMapping), i.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function Os(t, e, i, n) {
                const r = t.getParameter(34921),
                    s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    a = n.isWebGL2 || null !== s,
                    o = {},
                    l = p(null);
                let h = l,
                    c = !1;

                function u(e) {
                    return n.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
                }

                function d(e) {
                    return n.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
                }

                function p(t) {
                    const e = [],
                        i = [],
                        n = [];
                    for (let s = 0; s < r; s++) e[s] = 0, i[s] = 0, n[s] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: i,
                        attributeDivisors: n,
                        object: t,
                        attributes: {},
                        index: null
                    }
                }

                function m() {
                    const t = h.newAttributes;
                    for (let e = 0, i = t.length; e < i; e++) t[e] = 0
                }

                function f(t) {
                    g(t, 0)
                }

                function g(i, r) {
                    const s = h.newAttributes,
                        a = h.enabledAttributes,
                        o = h.attributeDivisors;
                    if (s[i] = 1, 0 === a[i] && (t.enableVertexAttribArray(i), a[i] = 1), o[i] !== r) {
                        (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), o[i] = r
                    }
                }

                function y() {
                    const e = h.newAttributes,
                        i = h.enabledAttributes;
                    for (let n = 0, r = i.length; n < r; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), i[n] = 0)
                }

                function x(e, i, r, s, a, o) {
                    !0 !== n.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, i, r, s, a, o) : t.vertexAttribIPointer(e, i, r, a, o)
                }

                function v() {
                    _(), c = !0, h !== l && (h = l, u(h.object))
                }

                function _() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(r, l, d, v, _) {
                        let b = !1;
                        if (a) {
                            const e = function(e, i, r) {
                                const a = !0 === r.wireframe;
                                let l = o[e.id];
                                void 0 === l && (l = {}, o[e.id] = l);
                                let h = l[i.id];
                                void 0 === h && (h = {}, l[i.id] = h);
                                let c = h[a];
                                void 0 === c && (c = p(n.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), h[a] = c);
                                return c
                            }(v, d, l);
                            h !== e && (h = e, u(h.object)), b = function(t, e) {
                                const i = h.attributes,
                                    n = t.attributes;
                                let r = 0;
                                for (const s in n) {
                                    const t = i[s],
                                        e = n[s];
                                    if (void 0 === t) return !0;
                                    if (t.attribute !== e) return !0;
                                    if (t.data !== e.data) return !0;
                                    r++
                                }
                                return h.attributesNum !== r || h.index !== e
                            }(v, _), b && function(t, e) {
                                const i = {},
                                    n = t.attributes;
                                let r = 0;
                                for (const s in n) {
                                    const t = n[s],
                                        e = {};
                                    e.attribute = t, t.data && (e.data = t.data), i[s] = e, r++
                                }
                                h.attributes = i, h.attributesNum = r, h.index = e
                            }(v, _)
                        } else {
                            const t = !0 === l.wireframe;
                            h.geometry === v.id && h.program === d.id && h.wireframe === t || (h.geometry = v.id, h.program = d.id, h.wireframe = t, b = !0)
                        }!0 === r.isInstancedMesh && (b = !0), null !== _ && i.update(_, 34963), (b || c) && (c = !1, function(r, s, a, o) {
                            if (!1 === n.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                            m();
                            const l = o.attributes,
                                h = a.getAttributes(),
                                c = s.defaultAttributeValues;
                            for (const e in h) {
                                const n = h[e];
                                if (n.location >= 0) {
                                    let s = l[e];
                                    if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                        const e = s.normalized,
                                            a = s.itemSize,
                                            l = i.get(s);
                                        if (void 0 === l) continue;
                                        const h = l.buffer,
                                            c = l.type,
                                            u = l.bytesPerElement;
                                        if (s.isInterleavedBufferAttribute) {
                                            const i = s.data,
                                                l = i.stride,
                                                d = s.offset;
                                            if (i.isInstancedInterleavedBuffer) {
                                                for (let t = 0; t < n.locationSize; t++) g(n.location + t, i.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count)
                                            } else
                                                for (let t = 0; t < n.locationSize; t++) f(n.location + t);
                                            t.bindBuffer(34962, h);
                                            for (let t = 0; t < n.locationSize; t++) x(n.location + t, a / n.locationSize, c, e, l * u, (d + a / n.locationSize * t) * u)
                                        } else {
                                            if (s.isInstancedBufferAttribute) {
                                                for (let t = 0; t < n.locationSize; t++) g(n.location + t, s.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                            } else
                                                for (let t = 0; t < n.locationSize; t++) f(n.location + t);
                                            t.bindBuffer(34962, h);
                                            for (let t = 0; t < n.locationSize; t++) x(n.location + t, a / n.locationSize, c, e, a * u, a / n.locationSize * t * u)
                                        }
                                    } else if (void 0 !== c) {
                                        const i = c[e];
                                        if (void 0 !== i) switch (i.length) {
                                            case 2:
                                                t.vertexAttrib2fv(n.location, i);
                                                break;
                                            case 3:
                                                t.vertexAttrib3fv(n.location, i);
                                                break;
                                            case 4:
                                                t.vertexAttrib4fv(n.location, i);
                                                break;
                                            default:
                                                t.vertexAttrib1fv(n.location, i)
                                        }
                                    }
                                }
                            }
                            y()
                        }(r, l, d, v), null !== _ && t.bindBuffer(34963, i.get(_).buffer))
                    },
                    reset: v,
                    resetDefaultState: _,
                    dispose: function() {
                        v();
                        for (const t in o) {
                            const e = o[t];
                            for (const t in e) {
                                const i = e[t];
                                for (const t in i) d(i[t].object), delete i[t];
                                delete e[t]
                            }
                            delete o[t]
                        }
                    },
                    releaseStatesOfGeometry: function(t) {
                        if (void 0 === o[t.id]) return;
                        const e = o[t.id];
                        for (const i in e) {
                            const t = e[i];
                            for (const e in t) d(t[e].object), delete t[e];
                            delete e[i]
                        }
                        delete o[t.id]
                    },
                    releaseStatesOfProgram: function(t) {
                        for (const e in o) {
                            const i = o[e];
                            if (void 0 === i[t.id]) continue;
                            const n = i[t.id];
                            for (const t in n) d(n[t].object), delete n[t];
                            delete i[t.id]
                        }
                    },
                    initAttributes: m,
                    enableAttribute: f,
                    disableUnusedAttributes: y
                }
            }

            function Bs(t, e, i, n) {
                const r = n.isWebGL2;
                let s;
                this.setMode = function(t) {
                    s = t
                }, this.render = function(e, n) {
                    t.drawArrays(s, e, n), i.update(n, s, 1)
                }, this.renderInstances = function(n, a, o) {
                    if (0 === o) return;
                    let l, h;
                    if (r) l = t, h = "drawArraysInstanced";
                    else if (l = e.get("ANGLE_instanced_arrays"), h = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[h](s, n, a, o), i.update(a, s, o)
                }
            }

            function Hs(t, e, i) {
                let n;

                function r(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const s = "undefined" !== typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                let a = void 0 !== i.precision ? i.precision : "highp";
                const o = r(a);
                o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
                const l = s || e.has("WEBGL_draw_buffers"),
                    h = !0 === i.logarithmicDepthBuffer,
                    c = t.getParameter(34930),
                    u = t.getParameter(35660),
                    d = t.getParameter(3379),
                    p = t.getParameter(34076),
                    m = t.getParameter(34921),
                    f = t.getParameter(36347),
                    g = t.getParameter(36348),
                    y = t.getParameter(36349),
                    x = u > 0,
                    v = s || e.has("OES_texture_float");
                return {
                    isWebGL2: s,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== n) return n;
                        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                            const i = e.get("EXT_texture_filter_anisotropic");
                            n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else n = 0;
                        return n
                    },
                    getMaxPrecision: r,
                    precision: a,
                    logarithmicDepthBuffer: h,
                    maxTextures: c,
                    maxVertexTextures: u,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: m,
                    maxVertexUniforms: f,
                    maxVaryings: g,
                    maxFragmentUniforms: y,
                    vertexTextures: x,
                    floatFragmentTextures: v,
                    floatVertexTextures: x && v,
                    maxSamples: s ? t.getParameter(36183) : 0
                }
            }

            function Us(t) {
                const e = this;
                let i = null,
                    n = 0,
                    r = !1,
                    s = !1;
                const a = new Es,
                    o = new Gi,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function h() {
                    l.value !== i && (l.value = i, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
                }

                function c(t, i, n, r) {
                    const s = null !== t ? t.length : 0;
                    let h = null;
                    if (0 !== s) {
                        if (h = l.value, !0 !== r || null === h) {
                            const e = n + 4 * s,
                                r = i.matrixWorldInverse;
                            o.getNormalMatrix(r), (null === h || h.length < e) && (h = new Float32Array(e));
                            for (let i = 0, l = n; i !== s; ++i, l += 4) a.copy(t[i]).applyMatrix4(r, o), a.normal.toArray(h, l), h[l + 3] = a.constant
                        }
                        l.value = h, l.needsUpdate = !0
                    }
                    return e.numPlanes = s, e.numIntersection = 0, h
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) {
                    const a = 0 !== t.length || e || 0 !== n || r;
                    return r = e, i = c(t, s, 0), n = t.length, a
                }, this.beginShadows = function() {
                    s = !0, c(null)
                }, this.endShadows = function() {
                    s = !1, h()
                }, this.setState = function(e, a, o) {
                    const u = e.clippingPlanes,
                        d = e.clipIntersection,
                        p = e.clipShadows,
                        m = t.get(e);
                    if (!r || null === u || 0 === u.length || s && !p) s ? c(null) : h();
                    else {
                        const t = s ? 0 : n,
                            e = 4 * t;
                        let r = m.clippingState || null;
                        l.value = r, r = c(u, a, e, o);
                        for (let n = 0; n !== e; ++n) r[n] = i[n];
                        m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                    }
                }
            }

            function Fs(t) {
                let e = new WeakMap;

                function i(t, e) {
                    return e === je ? t.mapping = Ge : e === qe && (t.mapping = We), t
                }

                function n(t) {
                    const i = t.target;
                    i.removeEventListener("dispose", n);
                    const r = e.get(i);
                    void 0 !== r && (e.delete(i), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                            const s = r.mapping;
                            if (s === je || s === qe) {
                                if (e.has(r)) {
                                    return i(e.get(r).texture, r.mapping)
                                } {
                                    const s = r.image;
                                    if (s && s.height > 0) {
                                        const a = new bs(s.height / 2);
                                        return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", n), i(a.texture, r.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }
            Is.physical = {
                uniforms: ps([Is.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new Vi(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new nn(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new Vi
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new nn(0)
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new nn(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: zs.meshphysical_vert,
                fragmentShader: zs.meshphysical_frag
            };
            class ks extends gs {
                constructor(t = -1, e = 1, i = 1, n = -1, r = .1, s = 2e3) {
                    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = r, this.far = s, this.updateProjectionMatrix()
                }
                copy(t, e) {
                    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                }
                setViewOffset(t, e, i, n, r, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2;
                    let r = i - t,
                        s = i + t,
                        a = n + e,
                        o = n - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += t * this.view.offsetX, s = r + t * this.view.width, a -= e * this.view.offsetY, o = a - e * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }
            ks.prototype.isOrthographicCamera = !0;
            const Vs = [.125, .215, .35, .446, .526, .582],
                Gs = 20,
                Ws = new ks,
                js = new nn;
            let qs = null;
            const Xs = (1 + Math.sqrt(5)) / 2,
                Ys = 1 / Xs,
                Js = [new fn(1, 1, 1), new fn(-1, 1, 1), new fn(1, 1, -1), new fn(-1, 1, -1), new fn(0, Xs, Ys), new fn(0, Xs, -Ys), new fn(Ys, 0, Xs), new fn(-Ys, 0, Xs), new fn(Xs, Ys, 0), new fn(-Xs, Ys, 0)];
            class Zs {
                constructor(t) {
                    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(t, e = 0, i = .1, n = 100) {
                    qs = this._renderer.getRenderTarget(), this._setSize(256);
                    const r = this._allocateTargets();
                    return r.depthBuffer = !0, this._sceneToCubeUV(t, i, n, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(t, e = null) {
                    return this._fromTexture(t, e)
                }
                fromCubemap(t, e = null) {
                    return this._fromTexture(t, e)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = ta(), this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = $s(), this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(t) {
                    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
                }
                _cleanup(t) {
                    this._renderer.setRenderTarget(qs), t.scissorTest = !1, Ks(t, 0, 0, t.width, t.height)
                }
                _fromTexture(t, e) {
                    t.mapping === Ge || t.mapping === We ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), qs = this._renderer.getRenderTarget();
                    const i = e || this._allocateTargets();
                    return this._textureToCubeUV(t, i), this._applyPMREM(i), this._cleanup(i), i
                }
                _allocateTargets() {
                    const t = 3 * Math.max(this._cubeSize, 112),
                        e = 4 * this._cubeSize - 32,
                        i = {
                            magFilter: ti,
                            minFilter: ti,
                            generateMipmaps: !1,
                            type: oi,
                            format: hi,
                            encoding: wi,
                            depthBuffer: !1
                        },
                        n = Qs(t, e, i);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) {
                        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Qs(t, e, i);
                        const {
                            _lodMax: n
                        } = this;
                        ({
                            sizeLods: this._sizeLods,
                            lodPlanes: this._lodPlanes,
                            sigmas: this._sigmas
                        } = function(t) {
                            const e = [],
                                i = [],
                                n = [];
                            let r = t;
                            const s = t - 4 + 1 + Vs.length;
                            for (let a = 0; a < s; a++) {
                                const s = Math.pow(2, r);
                                i.push(s);
                                let o = 1 / s;
                                a > t - 4 ? o = Vs[a - t + 4 - 1] : 0 === a && (o = 0), n.push(o);
                                const l = 1 / (s - 1),
                                    h = -l / 2,
                                    c = 1 + l / 2,
                                    u = [h, h, c, h, c, c, h, h, c, c, h, c],
                                    d = 6,
                                    p = 6,
                                    m = 3,
                                    f = 2,
                                    g = 1,
                                    y = new Float32Array(m * p * d),
                                    x = new Float32Array(f * p * d),
                                    v = new Float32Array(g * p * d);
                                for (let t = 0; t < d; t++) {
                                    const e = t % 3 * 2 / 3 - 1,
                                        i = t > 2 ? 0 : -1,
                                        n = [e, i, 0, e + 2 / 3, i, 0, e + 2 / 3, i + 1, 0, e, i, 0, e + 2 / 3, i + 1, 0, e, i + 1, 0];
                                    y.set(n, m * p * t), x.set(u, f * p * t);
                                    const r = [t, t, t, t, t, t];
                                    v.set(r, g * p * t)
                                }
                                const _ = new jr;
                                _.setAttribute("position", new Ir(y, m)), _.setAttribute("uv", new Ir(x, f)), _.setAttribute("faceIndex", new Ir(v, g)), e.push(_), r > 4 && r--
                            }
                            return {
                                lodPlanes: e,
                                sizeLods: i,
                                sigmas: n
                            }
                        }(n)), this._blurMaterial = function(t, e, i) {
                            const n = new Float32Array(Gs),
                                r = new fn(0, 1, 0);
                            return new fs({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: Gs,
                                    CUBEUV_TEXEL_WIDTH: 1 / e,
                                    CUBEUV_TEXEL_HEIGHT: 1 / i,
                                    CUBEUV_MAX_MIP: `${t}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: n
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: r
                                    }
                                },
                                vertexShader: ea(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            })
                        }(n, t, e)
                    }
                    return n
                }
                _compileMaterial(t) {
                    const e = new hs(this._lodPlanes[0], t);
                    this._renderer.compile(e, Ws)
                }
                _sceneToCubeUV(t, e, i, n) {
                    const r = new ys(90, 1, e, i),
                        s = [1, -1, 1, 1, 1, 1],
                        a = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        h = o.toneMapping;
                    o.getClearColor(js), o.toneMapping = 0, o.autoClear = !1;
                    const c = new Pr({
                            name: "PMREM.Background",
                            side: 1,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        u = new hs(new us, c);
                    let d = !1;
                    const p = t.background;
                    p ? p.isColor && (c.color.copy(p), t.background = null, d = !0) : (c.color.copy(js), d = !0);
                    for (let m = 0; m < 6; m++) {
                        const e = m % 3;
                        0 === e ? (r.up.set(0, s[m], 0), r.lookAt(a[m], 0, 0)) : 1 === e ? (r.up.set(0, 0, s[m]), r.lookAt(0, a[m], 0)) : (r.up.set(0, s[m], 0), r.lookAt(0, 0, a[m]));
                        const i = this._cubeSize;
                        Ks(n, e * i, m > 2 ? i : 0, i, i), o.setRenderTarget(n), d && o.render(u, r), o.render(t, r)
                    }
                    u.geometry.dispose(), u.material.dispose(), o.toneMapping = h, o.autoClear = l, t.background = p
                }
                _textureToCubeUV(t, e) {
                    const i = this._renderer,
                        n = t.mapping === Ge || t.mapping === We;
                    n ? (null === this._cubemapMaterial && (this._cubemapMaterial = ta()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = $s());
                    const r = n ? this._cubemapMaterial : this._equirectMaterial,
                        s = new hs(this._lodPlanes[0], r);
                    r.uniforms.envMap.value = t;
                    const a = this._cubeSize;
                    Ks(e, 0, 0, 3 * a, 2 * a), i.setRenderTarget(e), i.render(s, Ws)
                }
                _applyPMREM(t) {
                    const e = this._renderer,
                        i = e.autoClear;
                    e.autoClear = !1;
                    for (let n = 1; n < this._lodPlanes.length; n++) {
                        const e = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1]),
                            i = Js[(n - 1) % Js.length];
                        this._blur(t, n - 1, n, e, i)
                    }
                    e.autoClear = i
                }
                _blur(t, e, i, n, r) {
                    const s = this._pingPongRenderTarget;
                    this._halfBlur(t, s, e, i, n, "latitudinal", r), this._halfBlur(s, t, i, i, n, "longitudinal", r)
                }
                _halfBlur(t, e, i, n, r, s, a) {
                    const o = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                    const h = new hs(this._lodPlanes[n], l),
                        c = l.uniforms,
                        u = this._sizeLods[i] - 1,
                        d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                        p = r / d,
                        m = isFinite(r) ? 1 + Math.floor(3 * p) : Gs;
                    m > Gs && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                    const f = [];
                    let g = 0;
                    for (let v = 0; v < Gs; ++v) {
                        const t = v / p,
                            e = Math.exp(-t * t / 2);
                        f.push(e), 0 === v ? g += e : v < m && (g += 2 * e)
                    }
                    for (let v = 0; v < f.length; v++) f[v] = f[v] / g;
                    c.envMap.value = t.texture, c.samples.value = m, c.weights.value = f, c.latitudinal.value = "latitudinal" === s, a && (c.poleAxis.value = a);
                    const {
                        _lodMax: y
                    } = this;
                    c.dTheta.value = d, c.mipInt.value = y - i;
                    const x = this._sizeLods[n];
                    Ks(e, 3 * x * (n > y - 4 ? n - y + 4 : 0), 4 * (this._cubeSize - x), 3 * x, 2 * x), o.setRenderTarget(e), o.render(h, Ws)
                }
            }

            function Qs(t, e, i) {
                const n = new un(t, e, i);
                return n.texture.mapping = Xe, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
            }

            function Ks(t, e, i, n, r) {
                t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r)
            }

            function $s() {
                return new fs({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: ea(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function ta() {
                return new fs({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: ea(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function ea() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }

            function ia(t) {
                let e = new WeakMap,
                    i = null;

                function n(t) {
                    const i = t.target;
                    i.removeEventListener("dispose", n);
                    const r = e.get(i);
                    void 0 !== r && (e.delete(i), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture) {
                            const s = r.mapping,
                                a = s === je || s === qe,
                                o = s === Ge || s === We;
                            if (a || o) {
                                if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                    r.needsPMREMUpdate = !1;
                                    let n = e.get(r);
                                    return null === i && (i = new Zs(t)), n = a ? i.fromEquirectangular(r, n) : i.fromCubemap(r, n), e.set(r, n), n.texture
                                }
                                if (e.has(r)) return e.get(r).texture; {
                                    const s = r.image;
                                    if (a && s && s.height > 0 || o && s && function(t) {
                                            let e = 0;
                                            const i = 6;
                                            for (let n = 0; n < i; n++) void 0 !== t[n] && e++;
                                            return e === i
                                        }(s)) {
                                        null === i && (i = new Zs(t));
                                        const s = a ? i.fromEquirectangular(r) : i.fromCubemap(r);
                                        return e.set(r, s), r.addEventListener("dispose", n), s.texture
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        e = new WeakMap, null !== i && (i.dispose(), i = null)
                    }
                }
            }

            function na(t) {
                const e = {};

                function i(i) {
                    if (void 0 !== e[i]) return e[i];
                    let n;
                    switch (i) {
                        case "WEBGL_depth_texture":
                            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = t.getExtension(i)
                    }
                    return e[i] = n, n
                }
                return {
                    has: function(t) {
                        return null !== i(t)
                    },
                    init: function(t) {
                        t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(t) {
                        const e = i(t);
                        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                    }
                }
            }

            function ra(t, e, i, n) {
                const r = {},
                    s = new WeakMap;

                function a(t) {
                    const o = t.target;
                    null !== o.index && e.remove(o.index);
                    for (const i in o.attributes) e.remove(o.attributes[i]);
                    o.removeEventListener("dispose", a), delete r[o.id];
                    const l = s.get(o);
                    l && (e.remove(l), s.delete(o)), n.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, i.memory.geometries--
                }

                function o(t) {
                    const i = [],
                        n = t.index,
                        r = t.attributes.position;
                    let a = 0;
                    if (null !== n) {
                        const t = n.array;
                        a = n.version;
                        for (let e = 0, n = t.length; e < n; e += 3) {
                            const n = t[e + 0],
                                r = t[e + 1],
                                s = t[e + 2];
                            i.push(n, r, r, s, s, n)
                        }
                    } else {
                        const t = r.array;
                        a = r.version;
                        for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
                            const t = e + 0,
                                n = e + 1,
                                r = e + 2;
                            i.push(t, n, n, r, r, t)
                        }
                    }
                    const o = new(Wi(i) ? Or : Nr)(i, 1);
                    o.version = a;
                    const l = s.get(t);
                    l && e.remove(l), s.set(t, o)
                }
                return {
                    get: function(t, e) {
                        return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, i.memory.geometries++), e
                    },
                    update: function(t) {
                        const i = t.attributes;
                        for (const r in i) e.update(i[r], 34962);
                        const n = t.morphAttributes;
                        for (const r in n) {
                            const t = n[r];
                            for (let i = 0, n = t.length; i < n; i++) e.update(t[i], 34962)
                        }
                    },
                    getWireframeAttribute: function(t) {
                        const e = s.get(t);
                        if (e) {
                            const i = t.index;
                            null !== i && e.version < i.version && o(t)
                        } else o(t);
                        return s.get(t)
                    }
                }
            }

            function sa(t, e, i, n) {
                const r = n.isWebGL2;
                let s, a, o;
                this.setMode = function(t) {
                    s = t
                }, this.setIndex = function(t) {
                    a = t.type, o = t.bytesPerElement
                }, this.render = function(e, n) {
                    t.drawElements(s, n, a, e * o), i.update(n, s, 1)
                }, this.renderInstances = function(n, l, h) {
                    if (0 === h) return;
                    let c, u;
                    if (r) c = t, u = "drawElementsInstanced";
                    else if (c = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[u](s, l, a, n * o, h), i.update(l, s, h)
                }
            }

            function aa(t) {
                const e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(t, i, n) {
                        switch (e.calls++, i) {
                            case 4:
                                e.triangles += n * (t / 3);
                                break;
                            case 1:
                                e.lines += n * (t / 2);
                                break;
                            case 3:
                                e.lines += n * (t - 1);
                                break;
                            case 2:
                                e.lines += n * t;
                                break;
                            case 0:
                                e.points += n * t;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                        }
                    }
                }
            }

            function oa(t, e) {
                return t[0] - e[0]
            }

            function la(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function ha(t, e) {
                let i = 1;
                const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                n instanceof Int8Array ? i = 127 : n instanceof Int16Array ? i = 32767 : n instanceof Int32Array ? i = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n), t.divideScalar(i)
            }

            function ca(t, e, i) {
                const n = {},
                    r = new Float32Array(8),
                    s = new WeakMap,
                    a = new cn,
                    o = [];
                for (let l = 0; l < 8; l++) o[l] = [l, 0];
                return {
                    update: function(l, h, c, u) {
                        const d = l.morphTargetInfluences;
                        if (!0 === e.isWebGL2) {
                            const n = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color,
                                r = void 0 !== n ? n.length : 0;
                            let o = s.get(h);
                            if (void 0 === o || o.count !== r) {
                                void 0 !== o && o.texture.dispose();
                                const t = void 0 !== h.morphAttributes.position,
                                    i = void 0 !== h.morphAttributes.normal,
                                    n = void 0 !== h.morphAttributes.color,
                                    l = h.morphAttributes.position || [],
                                    c = h.morphAttributes.normal || [],
                                    u = h.morphAttributes.color || [];
                                let d = 0;
                                !0 === t && (d = 1), !0 === i && (d = 2), !0 === n && (d = 3);
                                let p = h.attributes.position.count * d,
                                    m = 1;
                                p > e.maxTextureSize && (m = Math.ceil(p / e.maxTextureSize), p = e.maxTextureSize);
                                const f = new Float32Array(p * m * 4 * r),
                                    g = new dn(f, p, m, r);
                                g.type = ai, g.needsUpdate = !0;
                                const y = 4 * d;
                                for (let e = 0; e < r; e++) {
                                    const r = l[e],
                                        s = c[e],
                                        o = u[e],
                                        h = p * m * 4 * e;
                                    for (let e = 0; e < r.count; e++) {
                                        const l = e * y;
                                        !0 === t && (a.fromBufferAttribute(r, e), !0 === r.normalized && ha(a, r), f[h + l + 0] = a.x, f[h + l + 1] = a.y, f[h + l + 2] = a.z, f[h + l + 3] = 0), !0 === i && (a.fromBufferAttribute(s, e), !0 === s.normalized && ha(a, s), f[h + l + 4] = a.x, f[h + l + 5] = a.y, f[h + l + 6] = a.z, f[h + l + 7] = 0), !0 === n && (a.fromBufferAttribute(o, e), !0 === o.normalized && ha(a, o), f[h + l + 8] = a.x, f[h + l + 9] = a.y, f[h + l + 10] = a.z, f[h + l + 11] = 4 === o.itemSize ? a.w : 1)
                                    }
                                }

                                function x() {
                                    g.dispose(), s.delete(h), h.removeEventListener("dispose", x)
                                }
                                o = {
                                    count: r,
                                    texture: g,
                                    size: new Vi(p, m)
                                }, s.set(h, o), h.addEventListener("dispose", x)
                            }
                            let l = 0;
                            for (let t = 0; t < d.length; t++) l += d[t];
                            const c = h.morphTargetsRelative ? 1 : 1 - l;
                            u.getUniforms().setValue(t, "morphTargetBaseInfluence", c), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", o.texture, i), u.getUniforms().setValue(t, "morphTargetsTextureSize", o.size)
                        } else {
                            const e = void 0 === d ? 0 : d.length;
                            let i = n[h.id];
                            if (void 0 === i || i.length !== e) {
                                i = [];
                                for (let t = 0; t < e; t++) i[t] = [t, 0];
                                n[h.id] = i
                            }
                            for (let t = 0; t < e; t++) {
                                const e = i[t];
                                e[0] = t, e[1] = d[t]
                            }
                            i.sort(la);
                            for (let t = 0; t < 8; t++) t < e && i[t][1] ? (o[t][0] = i[t][0], o[t][1] = i[t][1]) : (o[t][0] = Number.MAX_SAFE_INTEGER, o[t][1] = 0);
                            o.sort(oa);
                            const s = h.morphAttributes.position,
                                a = h.morphAttributes.normal;
                            let l = 0;
                            for (let t = 0; t < 8; t++) {
                                const e = o[t],
                                    i = e[0],
                                    n = e[1];
                                i !== Number.MAX_SAFE_INTEGER && n ? (s && h.getAttribute("morphTarget" + t) !== s[i] && h.setAttribute("morphTarget" + t, s[i]), a && h.getAttribute("morphNormal" + t) !== a[i] && h.setAttribute("morphNormal" + t, a[i]), r[t] = n, l += n) : (s && !0 === h.hasAttribute("morphTarget" + t) && h.deleteAttribute("morphTarget" + t), a && !0 === h.hasAttribute("morphNormal" + t) && h.deleteAttribute("morphNormal" + t), r[t] = 0)
                            }
                            const c = h.morphTargetsRelative ? 1 : 1 - l;
                            u.getUniforms().setValue(t, "morphTargetBaseInfluence", c), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                        }
                    }
                }
            }

            function ua(t, e, i, n) {
                let r = new WeakMap;

                function s(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", s), i.remove(e.instanceMatrix), null !== e.instanceColor && i.remove(e.instanceColor)
                }
                return {
                    update: function(t) {
                        const a = n.render.frame,
                            o = t.geometry,
                            l = e.get(t, o);
                        return r.get(l) !== a && (e.update(l), r.set(l, a)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), i.update(t.instanceMatrix, 34962), null !== t.instanceColor && i.update(t.instanceColor, 34962)), l
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }
            const da = new hn,
                pa = new dn,
                ma = new pn,
                fa = new _s,
                ga = [],
                ya = [],
                xa = new Float32Array(16),
                va = new Float32Array(9),
                _a = new Float32Array(4);

            function ba(t, e, i) {
                const n = t[0];
                if (n <= 0 || n > 0) return t;
                const r = e * i;
                let s = ga[r];
                if (void 0 === s && (s = new Float32Array(r), ga[r] = s), 0 !== e) {
                    n.toArray(s, 0);
                    for (let n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(s, r)
                }
                return s
            }

            function Ma(t, e) {
                if (t.length !== e.length) return !1;
                for (let i = 0, n = t.length; i < n; i++)
                    if (t[i] !== e[i]) return !1;
                return !0
            }

            function wa(t, e) {
                for (let i = 0, n = e.length; i < n; i++) t[i] = e[i]
            }

            function Sa(t, e) {
                let i = ya[e];
                void 0 === i && (i = new Int32Array(e), ya[e] = i);
                for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
                return i
            }

            function Ea(t, e) {
                const i = this.cache;
                i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
            }

            function Ta(t, e) {
                const i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                else {
                    if (Ma(i, e)) return;
                    t.uniform2fv(this.addr, e), wa(i, e)
                }
            }

            function Aa(t, e) {
                const i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
                else {
                    if (Ma(i, e)) return;
                    t.uniform3fv(this.addr, e), wa(i, e)
                }
            }

            function Ca(t, e) {
                const i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                else {
                    if (Ma(i, e)) return;
                    t.uniform4fv(this.addr, e), wa(i, e)
                }
            }

            function Ra(t, e) {
                const i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Ma(i, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), wa(i, e)
                } else {
                    if (Ma(i, n)) return;
                    _a.set(n), t.uniformMatrix2fv(this.addr, !1, _a), wa(i, n)
                }
            }

            function La(t, e) {
                const i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Ma(i, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), wa(i, e)
                } else {
                    if (Ma(i, n)) return;
                    va.set(n), t.uniformMatrix3fv(this.addr, !1, va), wa(i, n)
                }
            }

            function Pa(t, e) {
                const i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Ma(i, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), wa(i, e)
                } else {
                    if (Ma(i, n)) return;
                    xa.set(n), t.uniformMatrix4fv(this.addr, !1, xa), wa(i, n)
                }
            }

            function za(t, e) {
                const i = this.cache;
                i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
            }

            function Da(t, e) {
                const i = this.cache;
                Ma(i, e) || (t.uniform2iv(this.addr, e), wa(i, e))
            }

            function Ia(t, e) {
                const i = this.cache;
                Ma(i, e) || (t.uniform3iv(this.addr, e), wa(i, e))
            }

            function Na(t, e) {
                const i = this.cache;
                Ma(i, e) || (t.uniform4iv(this.addr, e), wa(i, e))
            }

            function Oa(t, e) {
                const i = this.cache;
                i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e)
            }

            function Ba(t, e) {
                const i = this.cache;
                Ma(i, e) || (t.uniform2uiv(this.addr, e), wa(i, e))
            }

            function Ha(t, e) {
                const i = this.cache;
                Ma(i, e) || (t.uniform3uiv(this.addr, e), wa(i, e))
            }

            function Ua(t, e) {
                const i = this.cache;
                Ma(i, e) || (t.uniform4uiv(this.addr, e), wa(i, e))
            }

            function Fa(t, e, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || da, r)
            }

            function ka(t, e, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || ma, r)
            }

            function Va(t, e, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || fa, r)
            }

            function Ga(t, e, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || pa, r)
            }

            function Wa(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function ja(t, e) {
                const i = ba(e, this.size, 2);
                t.uniform2fv(this.addr, i)
            }

            function qa(t, e) {
                const i = ba(e, this.size, 3);
                t.uniform3fv(this.addr, i)
            }

            function Xa(t, e) {
                const i = ba(e, this.size, 4);
                t.uniform4fv(this.addr, i)
            }

            function Ya(t, e) {
                const i = ba(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, i)
            }

            function Ja(t, e) {
                const i = ba(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, i)
            }

            function Za(t, e) {
                const i = ba(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, i)
            }

            function Qa(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function Ka(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function $a(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function to(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function eo(t, e) {
                t.uniform1uiv(this.addr, e)
            }

            function io(t, e) {
                t.uniform2uiv(this.addr, e)
            }

            function no(t, e) {
                t.uniform3uiv(this.addr, e)
            }

            function ro(t, e) {
                t.uniform4uiv(this.addr, e)
            }

            function so(t, e, i) {
                const n = e.length,
                    r = Sa(i, n);
                t.uniform1iv(this.addr, r);
                for (let s = 0; s !== n; ++s) i.setTexture2D(e[s] || da, r[s])
            }

            function ao(t, e, i) {
                const n = e.length,
                    r = Sa(i, n);
                t.uniform1iv(this.addr, r);
                for (let s = 0; s !== n; ++s) i.setTexture3D(e[s] || ma, r[s])
            }

            function oo(t, e, i) {
                const n = e.length,
                    r = Sa(i, n);
                t.uniform1iv(this.addr, r);
                for (let s = 0; s !== n; ++s) i.setTextureCube(e[s] || fa, r[s])
            }

            function lo(t, e, i) {
                const n = e.length,
                    r = Sa(i, n);
                t.uniform1iv(this.addr, r);
                for (let s = 0; s !== n; ++s) i.setTexture2DArray(e[s] || pa, r[s])
            }

            function ho(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Ea;
                        case 35664:
                            return Ta;
                        case 35665:
                            return Aa;
                        case 35666:
                            return Ca;
                        case 35674:
                            return Ra;
                        case 35675:
                            return La;
                        case 35676:
                            return Pa;
                        case 5124:
                        case 35670:
                            return za;
                        case 35667:
                        case 35671:
                            return Da;
                        case 35668:
                        case 35672:
                            return Ia;
                        case 35669:
                        case 35673:
                            return Na;
                        case 5125:
                            return Oa;
                        case 36294:
                            return Ba;
                        case 36295:
                            return Ha;
                        case 36296:
                            return Ua;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Fa;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ka;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Va;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Ga
                    }
                }(e.type)
            }

            function co(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Wa;
                        case 35664:
                            return ja;
                        case 35665:
                            return qa;
                        case 35666:
                            return Xa;
                        case 35674:
                            return Ya;
                        case 35675:
                            return Ja;
                        case 35676:
                            return Za;
                        case 5124:
                        case 35670:
                            return Qa;
                        case 35667:
                        case 35671:
                            return Ka;
                        case 35668:
                        case 35672:
                            return $a;
                        case 35669:
                        case 35673:
                            return to;
                        case 5125:
                            return eo;
                        case 36294:
                            return io;
                        case 36295:
                            return no;
                        case 36296:
                            return ro;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return so;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ao;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return oo;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return lo
                    }
                }(e.type)
            }

            function uo(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            co.prototype.updateCache = function(t) {
                const e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), wa(e, t)
            }, uo.prototype.setValue = function(t, e, i) {
                const n = this.seq;
                for (let r = 0, s = n.length; r !== s; ++r) {
                    const s = n[r];
                    s.setValue(t, e[s.id], i)
                }
            };
            const po = /(\w+)(\])?(\[|\.)?/g;

            function mo(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function fo(t, e, i) {
                const n = t.name,
                    r = n.length;
                for (po.lastIndex = 0;;) {
                    const s = po.exec(n),
                        a = po.lastIndex;
                    let o = s[1];
                    const l = "]" === s[2],
                        h = s[3];
                    if (l && (o |= 0), void 0 === h || "[" === h && a + 2 === r) {
                        mo(i, void 0 === h ? new ho(o, t, e) : new co(o, t, e));
                        break
                    } {
                        let t = i.map[o];
                        void 0 === t && (t = new uo(o), mo(i, t)), i = t
                    }
                }
            }

            function go(t, e) {
                this.seq = [], this.map = {};
                const i = t.getProgramParameter(e, 35718);
                for (let n = 0; n < i; ++n) {
                    const i = t.getActiveUniform(e, n);
                    fo(i, t.getUniformLocation(e, i.name), this)
                }
            }

            function yo(t, e, i) {
                const n = t.createShader(e);
                return t.shaderSource(n, i), t.compileShader(n), n
            }
            go.prototype.setValue = function(t, e, i, n) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, i, n)
            }, go.prototype.setOptional = function(t, e, i) {
                const n = e[i];
                void 0 !== n && this.setValue(t, i, n)
            }, go.upload = function(t, e, i, n) {
                for (let r = 0, s = e.length; r !== s; ++r) {
                    const s = e[r],
                        a = i[s.id];
                    !1 !== a.needsUpdate && s.setValue(t, a.value, n)
                }
            }, go.seqWithValue = function(t, e) {
                const i = [];
                for (let n = 0, r = t.length; n !== r; ++n) {
                    const r = t[n];
                    r.id in e && i.push(r)
                }
                return i
            };
            let xo = 0;

            function vo(t, e, i) {
                const n = t.getShaderParameter(e, 35713),
                    r = t.getShaderInfoLog(e).trim();
                if (n && "" === r) return "";
                const s = parseInt(/ERROR: 0:(\d+)/.exec(r)[1]);
                return i.toUpperCase() + "\n\n" + r + "\n\n" + function(t, e) {
                    const i = t.split("\n"),
                        n = [],
                        r = Math.max(e - 6, 0),
                        s = Math.min(e + 6, i.length);
                    for (let a = r; a < s; a++) n.push(a + 1 + ": " + i[a]);
                    return n.join("\n")
                }(t.getShaderSource(e), s)
            }

            function _o(t, e) {
                const i = function(t) {
                    switch (t) {
                        case wi:
                            return ["Linear", "( value )"];
                        case Si:
                            return ["sRGB", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                    }
                }(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
            }

            function bo(t, e) {
                let i;
                switch (e) {
                    case 1:
                        i = "Linear";
                        break;
                    case 2:
                        i = "Reinhard";
                        break;
                    case 3:
                        i = "OptimizedCineon";
                        break;
                    case 4:
                        i = "ACESFilmic";
                        break;
                    case 5:
                        i = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear"
                }
                return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
            }

            function Mo(t) {
                return "" !== t
            }

            function wo(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function So(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            const Eo = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function To(t) {
                return t.replace(Eo, Ao)
            }

            function Ao(t, e) {
                const i = zs[e];
                if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                return To(i)
            }
            const Co = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Ro = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function Lo(t) {
                return t.replace(Ro, zo).replace(Co, Po)
            }

            function Po(t, e, i, n) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), zo(t, e, i, n)
            }

            function zo(t, e, i, n) {
                let r = "";
                for (let s = parseInt(e); s < parseInt(i); s++) r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
                return r
            }

            function Do(t) {
                let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function Io(t, e, i, n) {
                const r = t.getContext(),
                    s = i.defines;
                let a = i.vertexShader,
                    o = i.fragmentShader;
                const l = function(t) {
                        let e = "SHADOWMAP_TYPE_BASIC";
                        return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                    }(i),
                    h = function(t) {
                        let e = "ENVMAP_TYPE_CUBE";
                        if (t.envMap) switch (t.envMapMode) {
                            case Ge:
                            case We:
                                e = "ENVMAP_TYPE_CUBE";
                                break;
                            case Xe:
                                e = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return e
                    }(i),
                    c = function(t) {
                        let e = "ENVMAP_MODE_REFLECTION";
                        t.envMap && t.envMapMode === We && (e = "ENVMAP_MODE_REFRACTION");
                        return e
                    }(i),
                    u = function(t) {
                        let e = "ENVMAP_BLENDING_NONE";
                        if (t.envMap) switch (t.combine) {
                            case 0:
                                e = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                e = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                e = "ENVMAP_BLENDING_ADD"
                        }
                        return e
                    }(i),
                    d = function(t) {
                        const e = t.envMapCubeUVHeight;
                        if (null === e) return null;
                        const i = Math.log2(e / 32 + 1) + 3,
                            n = 1 / e;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
                            texelHeight: n,
                            maxMip: i
                        }
                    }(i),
                    p = i.isWebGL2 ? "" : function(t) {
                        return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mo).join("\n")
                    }(i),
                    m = function(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            !1 !== n && e.push("#define " + i + " " + n)
                        }
                        return e.join("\n")
                    }(s),
                    f = r.createProgram();
                let g, y, x = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
                i.isRawShaderMaterial ? (g = [m].filter(Mo).join("\n"), g.length > 0 && (g += "\n"), y = [p, m].filter(Mo).join("\n"), y.length > 0 && (y += "\n")) : (g = [Do(i), "#define SHADER_NAME " + i.shaderName, m, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Mo).join("\n"), y = [p, Do(i), "#define SHADER_NAME " + i.shaderName, m, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? zs.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? bo("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", zs.encodings_pars_fragment, _o("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Mo).join("\n")), a = To(a), a = wo(a, i), a = So(a, i), o = To(o), o = wo(o, i), o = So(o, i), a = Lo(a), o = Lo(o), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (x = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, y = ["#define varying in", i.glslVersion === Li ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === Li ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
                const v = x + y + o,
                    _ = yo(r, 35633, x + g + a),
                    b = yo(r, 35632, v);
                if (r.attachShader(f, _), r.attachShader(f, b), void 0 !== i.index0AttributeName ? r.bindAttribLocation(f, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(f, 0, "position"), r.linkProgram(f), t.debug.checkShaderErrors) {
                    const t = r.getProgramInfoLog(f).trim(),
                        e = r.getShaderInfoLog(_).trim(),
                        i = r.getShaderInfoLog(b).trim();
                    let n = !0,
                        s = !0;
                    if (!1 === r.getProgramParameter(f, 35714)) {
                        n = !1;
                        const e = vo(r, _, "vertex"),
                            i = vo(r, b, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(f, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + i)
                    } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== i || (s = !1);
                    s && (this.diagnostics = {
                        runnable: n,
                        programLog: t,
                        vertexShader: {
                            log: e,
                            prefix: g
                        },
                        fragmentShader: {
                            log: i,
                            prefix: y
                        }
                    })
                }
                let M, w;
                return r.deleteShader(_), r.deleteShader(b), this.getUniforms = function() {
                    return void 0 === M && (M = new go(r, f)), M
                }, this.getAttributes = function() {
                    return void 0 === w && (w = function(t, e) {
                        const i = {},
                            n = t.getProgramParameter(e, 35721);
                        for (let r = 0; r < n; r++) {
                            const n = t.getActiveAttrib(e, r),
                                s = n.name;
                            let a = 1;
                            35674 === n.type && (a = 2), 35675 === n.type && (a = 3), 35676 === n.type && (a = 4), i[s] = {
                                type: n.type,
                                location: t.getAttribLocation(e, s),
                                locationSize: a
                            }
                        }
                        return i
                    }(r, f)), w
                }, this.destroy = function() {
                    n.releaseStatesOfProgram(this), r.deleteProgram(f), this.program = void 0
                }, this.name = i.shaderName, this.id = xo++, this.cacheKey = e, this.usedTimes = 1, this.program = f, this.vertexShader = _, this.fragmentShader = b, this
            }
            let No = 0;
            class Oo {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(t) {
                    const e = t.vertexShader,
                        i = t.fragmentShader,
                        n = this._getShaderStage(e),
                        r = this._getShaderStage(i),
                        s = this._getShaderCacheForMaterial(t);
                    return !1 === s.has(n) && (s.add(n), n.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
                }
                remove(t) {
                    const e = this.materialCache.get(t);
                    for (const i of e) i.usedTimes--, 0 === i.usedTimes && this.shaderCache.delete(i.code);
                    return this.materialCache.delete(t), this
                }
                getVertexShaderID(t) {
                    return this._getShaderStage(t.vertexShader).id
                }
                getFragmentShaderID(t) {
                    return this._getShaderStage(t.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(t) {
                    const e = this.materialCache;
                    return !1 === e.has(t) && e.set(t, new Set), e.get(t)
                }
                _getShaderStage(t) {
                    const e = this.shaderCache;
                    if (!1 === e.has(t)) {
                        const i = new Bo(t);
                        e.set(t, i)
                    }
                    return e.get(t)
                }
            }
            class Bo {
                constructor(t) {
                    this.id = No++, this.code = t, this.usedTimes = 0
                }
            }

            function Ho(t, e, i, n, r, s, a) {
                const o = new nr,
                    l = new Oo,
                    h = [],
                    c = r.isWebGL2,
                    u = r.logarithmicDepthBuffer,
                    d = r.floatVertexTextures,
                    p = r.maxVertexUniforms,
                    m = r.vertexTextures;
                let f = r.precision;
                const g = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                };
                return {
                    getParameters: function(s, o, h, y, x) {
                        const v = y.fog,
                            _ = x.geometry,
                            b = s.isMeshStandardMaterial ? y.environment : null,
                            M = (s.isMeshStandardMaterial ? i : e).get(s.envMap || b),
                            w = M && M.mapping === Xe ? M.image.height : null,
                            S = g[s.type],
                            E = x.isSkinnedMesh ? function(t) {
                                const e = t.skeleton.bones;
                                if (d) return 1024; {
                                    const t = p,
                                        i = Math.floor((t - 20) / 4),
                                        n = Math.min(i, e.length);
                                    return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n
                                }
                            }(x) : 0;
                        null !== s.precision && (f = r.getMaxPrecision(s.precision), f !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead."));
                        const T = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color,
                            A = void 0 !== T ? T.length : 0;
                        let C, R, L, P, z = 0;
                        if (void 0 !== _.morphAttributes.position && (z = 1), void 0 !== _.morphAttributes.normal && (z = 2), void 0 !== _.morphAttributes.color && (z = 3), S) {
                            const t = Is[S];
                            C = t.vertexShader, R = t.fragmentShader
                        } else C = s.vertexShader, R = s.fragmentShader, l.update(s), L = l.getVertexShaderID(s), P = l.getFragmentShaderID(s);
                        const D = t.getRenderTarget(),
                            I = s.alphaTest > 0,
                            N = s.clearcoat > 0;
                        return {
                            isWebGL2: c,
                            shaderID: S,
                            shaderName: s.type,
                            vertexShader: C,
                            fragmentShader: R,
                            defines: s.defines,
                            customVertexShaderID: L,
                            customFragmentShaderID: P,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: f,
                            instancing: !0 === x.isInstancedMesh,
                            instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor,
                            supportsVertexTextures: m,
                            outputEncoding: null === D ? t.outputEncoding : !0 === D.isXRRenderTarget ? D.texture.encoding : wi,
                            map: !!s.map,
                            matcap: !!s.matcap,
                            envMap: !!M,
                            envMapMode: M && M.mapping,
                            envMapCubeUVHeight: w,
                            lightMap: !!s.lightMap,
                            aoMap: !!s.aoMap,
                            emissiveMap: !!s.emissiveMap,
                            bumpMap: !!s.bumpMap,
                            normalMap: !!s.normalMap,
                            objectSpaceNormalMap: 1 === s.normalMapType,
                            tangentSpaceNormalMap: 0 === s.normalMapType,
                            decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === Si,
                            clearcoat: N,
                            clearcoatMap: N && !!s.clearcoatMap,
                            clearcoatRoughnessMap: N && !!s.clearcoatRoughnessMap,
                            clearcoatNormalMap: N && !!s.clearcoatNormalMap,
                            displacementMap: !!s.displacementMap,
                            roughnessMap: !!s.roughnessMap,
                            metalnessMap: !!s.metalnessMap,
                            specularMap: !!s.specularMap,
                            specularIntensityMap: !!s.specularIntensityMap,
                            specularColorMap: !!s.specularColorMap,
                            opaque: !1 === s.transparent && 1 === s.blending,
                            alphaMap: !!s.alphaMap,
                            alphaTest: I,
                            gradientMap: !!s.gradientMap,
                            sheen: s.sheen > 0,
                            sheenColorMap: !!s.sheenColorMap,
                            sheenRoughnessMap: !!s.sheenRoughnessMap,
                            transmission: s.transmission > 0,
                            transmissionMap: !!s.transmissionMap,
                            thicknessMap: !!s.thicknessMap,
                            combine: s.combine,
                            vertexTangents: !!s.normalMap && !!_.attributes.tangent,
                            vertexColors: s.vertexColors,
                            vertexAlphas: !0 === s.vertexColors && !!_.attributes.color && 4 === _.attributes.color.itemSize,
                            vertexUvs: !!s.map || !!s.bumpMap || !!s.normalMap || !!s.specularMap || !!s.alphaMap || !!s.emissiveMap || !!s.roughnessMap || !!s.metalnessMap || !!s.clearcoatMap || !!s.clearcoatRoughnessMap || !!s.clearcoatNormalMap || !!s.displacementMap || !!s.transmissionMap || !!s.thicknessMap || !!s.specularIntensityMap || !!s.specularColorMap || !!s.sheenColorMap || !!s.sheenRoughnessMap,
                            uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap) && !!s.displacementMap,
                            fog: !!v,
                            useFog: s.fog,
                            fogExp2: v && v.isFogExp2,
                            flatShading: !!s.flatShading,
                            sizeAttenuation: s.sizeAttenuation,
                            logarithmicDepthBuffer: u,
                            skinning: !0 === x.isSkinnedMesh && E > 0,
                            maxBones: E,
                            useVertexTexture: d,
                            morphTargets: void 0 !== _.morphAttributes.position,
                            morphNormals: void 0 !== _.morphAttributes.normal,
                            morphColors: void 0 !== _.morphAttributes.color,
                            morphTargetsCount: A,
                            morphTextureStride: z,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: a.numPlanes,
                            numClipIntersection: a.numIntersection,
                            dithering: s.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: s.toneMapped ? t.toneMapping : 0,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: 2 === s.side,
                            flipSided: 1 === s.side,
                            depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                            index0AttributeName: s.index0AttributeName,
                            extensionDerivatives: s.extensions && s.extensions.derivatives,
                            extensionFragDepth: s.extensions && s.extensions.fragDepth,
                            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                            extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: c || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: s.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(e) {
                        const i = [];
                        if (e.shaderID ? i.push(e.shaderID) : (i.push(e.customVertexShaderID), i.push(e.customFragmentShaderID)), void 0 !== e.defines)
                            for (const t in e.defines) i.push(t), i.push(e.defines[t]);
                        return !1 === e.isRawShaderMaterial && (! function(t, e) {
                            t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.maxBones), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection)
                        }(i, e), function(t, e) {
                            o.disableAll(), e.isWebGL2 && o.enable(0);
                            e.supportsVertexTextures && o.enable(1);
                            e.instancing && o.enable(2);
                            e.instancingColor && o.enable(3);
                            e.map && o.enable(4);
                            e.matcap && o.enable(5);
                            e.envMap && o.enable(6);
                            e.lightMap && o.enable(7);
                            e.aoMap && o.enable(8);
                            e.emissiveMap && o.enable(9);
                            e.bumpMap && o.enable(10);
                            e.normalMap && o.enable(11);
                            e.objectSpaceNormalMap && o.enable(12);
                            e.tangentSpaceNormalMap && o.enable(13);
                            e.clearcoat && o.enable(14);
                            e.clearcoatMap && o.enable(15);
                            e.clearcoatRoughnessMap && o.enable(16);
                            e.clearcoatNormalMap && o.enable(17);
                            e.displacementMap && o.enable(18);
                            e.specularMap && o.enable(19);
                            e.roughnessMap && o.enable(20);
                            e.metalnessMap && o.enable(21);
                            e.gradientMap && o.enable(22);
                            e.alphaMap && o.enable(23);
                            e.alphaTest && o.enable(24);
                            e.vertexColors && o.enable(25);
                            e.vertexAlphas && o.enable(26);
                            e.vertexUvs && o.enable(27);
                            e.vertexTangents && o.enable(28);
                            e.uvsVertexOnly && o.enable(29);
                            e.fog && o.enable(30);
                            t.push(o.mask), o.disableAll(), e.useFog && o.enable(0);
                            e.flatShading && o.enable(1);
                            e.logarithmicDepthBuffer && o.enable(2);
                            e.skinning && o.enable(3);
                            e.useVertexTexture && o.enable(4);
                            e.morphTargets && o.enable(5);
                            e.morphNormals && o.enable(6);
                            e.morphColors && o.enable(7);
                            e.premultipliedAlpha && o.enable(8);
                            e.shadowMapEnabled && o.enable(9);
                            e.physicallyCorrectLights && o.enable(10);
                            e.doubleSided && o.enable(11);
                            e.flipSided && o.enable(12);
                            e.depthPacking && o.enable(13);
                            e.dithering && o.enable(14);
                            e.specularIntensityMap && o.enable(15);
                            e.specularColorMap && o.enable(16);
                            e.transmission && o.enable(17);
                            e.transmissionMap && o.enable(18);
                            e.thicknessMap && o.enable(19);
                            e.sheen && o.enable(20);
                            e.sheenColorMap && o.enable(21);
                            e.sheenRoughnessMap && o.enable(22);
                            e.decodeVideoTexture && o.enable(23);
                            e.opaque && o.enable(24);
                            t.push(o.mask)
                        }(i, e), i.push(t.outputEncoding)), i.push(e.customProgramCacheKey), i.join()
                    },
                    getUniforms: function(t) {
                        const e = g[t.type];
                        let i;
                        if (e) {
                            const t = Is[e];
                            i = ms.clone(t.uniforms)
                        } else i = t.uniforms;
                        return i
                    },
                    acquireProgram: function(e, i) {
                        let n;
                        for (let t = 0, r = h.length; t < r; t++) {
                            const e = h[t];
                            if (e.cacheKey === i) {
                                n = e, ++n.usedTimes;
                                break
                            }
                        }
                        return void 0 === n && (n = new Io(t, i, e, s), h.push(n)), n
                    },
                    releaseProgram: function(t) {
                        if (0 === --t.usedTimes) {
                            const e = h.indexOf(t);
                            h[e] = h[h.length - 1], h.pop(), t.destroy()
                        }
                    },
                    releaseShaderCache: function(t) {
                        l.remove(t)
                    },
                    programs: h,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }

            function Uo() {
                let t = new WeakMap;
                return {
                    get: function(e) {
                        let i = t.get(e);
                        return void 0 === i && (i = {}, t.set(e, i)), i
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, i, n) {
                        t.get(e)[i] = n
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function Fo(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function ko(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Vo() {
                const t = [];
                let e = 0;
                const i = [],
                    n = [],
                    r = [];

                function s(i, n, r, s, a, o) {
                    let l = t[e];
                    return void 0 === l ? (l = {
                        id: i.id,
                        object: i,
                        geometry: n,
                        material: r,
                        groupOrder: s,
                        renderOrder: i.renderOrder,
                        z: a,
                        group: o
                    }, t[e] = l) : (l.id = i.id, l.object = i, l.geometry = n, l.material = r, l.groupOrder = s, l.renderOrder = i.renderOrder, l.z = a, l.group = o), e++, l
                }
                return {
                    opaque: i,
                    transmissive: n,
                    transparent: r,
                    init: function() {
                        e = 0, i.length = 0, n.length = 0, r.length = 0
                    },
                    push: function(t, e, a, o, l, h) {
                        const c = s(t, e, a, o, l, h);
                        a.transmission > 0 ? n.push(c) : !0 === a.transparent ? r.push(c) : i.push(c)
                    },
                    unshift: function(t, e, a, o, l, h) {
                        const c = s(t, e, a, o, l, h);
                        a.transmission > 0 ? n.unshift(c) : !0 === a.transparent ? r.unshift(c) : i.unshift(c)
                    },
                    finish: function() {
                        for (let i = e, n = t.length; i < n; i++) {
                            const e = t[i];
                            if (null === e.id) break;
                            e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                        }
                    },
                    sort: function(t, e) {
                        i.length > 1 && i.sort(t || Fo), n.length > 1 && n.sort(e || ko), r.length > 1 && r.sort(e || ko)
                    }
                }
            }

            function Go() {
                let t = new WeakMap;
                return {
                    get: function(e, i) {
                        let n;
                        return !1 === t.has(e) ? (n = new Vo, t.set(e, [n])) : i >= t.get(e).length ? (n = new Vo, t.get(e).push(n)) : n = t.get(e)[i], n
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function Wo() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let i;
                        switch (e.type) {
                            case "DirectionalLight":
                                i = {
                                    direction: new fn,
                                    color: new nn
                                };
                                break;
                            case "SpotLight":
                                i = {
                                    position: new fn,
                                    direction: new fn,
                                    color: new nn,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                i = {
                                    position: new fn,
                                    color: new nn,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                i = {
                                    direction: new fn,
                                    skyColor: new nn,
                                    groundColor: new nn
                                };
                                break;
                            case "RectAreaLight":
                                i = {
                                    color: new nn,
                                    position: new fn,
                                    halfWidth: new fn,
                                    halfHeight: new fn
                                }
                        }
                        return t[e.id] = i, i
                    }
                }
            }
            let jo = 0;

            function qo(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function Xo(t, e) {
                const i = new Wo,
                    n = function() {
                        const t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let i;
                                switch (e.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        i = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Vi
                                        };
                                        break;
                                    case "PointLight":
                                        i = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Vi,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return t[e.id] = i, i
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let l = 0; l < 9; l++) r.probe.push(new fn);
                const s = new fn,
                    a = new qn,
                    o = new qn;
                return {
                    setup: function(s, a) {
                        let o = 0,
                            l = 0,
                            h = 0;
                        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                        let c = 0,
                            u = 0,
                            d = 0,
                            p = 0,
                            m = 0,
                            f = 0,
                            g = 0,
                            y = 0;
                        s.sort(qo);
                        const x = !0 !== a ? Math.PI : 1;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t],
                                a = e.color,
                                v = e.intensity,
                                _ = e.distance,
                                b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                            if (e.isAmbientLight) o += a.r * v * x, l += a.g * v * x, h += a.b * v * x;
                            else if (e.isLightProbe)
                                for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], v);
                            else if (e.isDirectionalLight) {
                                const t = i.get(e);
                                if (t.color.copy(e.color).multiplyScalar(e.intensity * x), e.castShadow) {
                                    const t = e.shadow,
                                        i = n.get(e);
                                    i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, r.directionalShadow[c] = i, r.directionalShadowMap[c] = b, r.directionalShadowMatrix[c] = e.shadow.matrix, f++
                                }
                                r.directional[c] = t, c++
                            } else if (e.isSpotLight) {
                                const t = i.get(e);
                                if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(a).multiplyScalar(v * x), t.distance = _, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                    const t = e.shadow,
                                        i = n.get(e);
                                    i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, r.spotShadow[d] = i, r.spotShadowMap[d] = b, r.spotShadowMatrix[d] = e.shadow.matrix, y++
                                }
                                r.spot[d] = t, d++
                            } else if (e.isRectAreaLight) {
                                const t = i.get(e);
                                t.color.copy(a).multiplyScalar(v), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[p] = t, p++
                            } else if (e.isPointLight) {
                                const t = i.get(e);
                                if (t.color.copy(e.color).multiplyScalar(e.intensity * x), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                    const t = e.shadow,
                                        i = n.get(e);
                                    i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, r.pointShadow[u] = i, r.pointShadowMap[u] = b, r.pointShadowMatrix[u] = e.shadow.matrix, g++
                                }
                                r.point[u] = t, u++
                            } else if (e.isHemisphereLight) {
                                const t = i.get(e);
                                t.skyColor.copy(e.color).multiplyScalar(v * x), t.groundColor.copy(e.groundColor).multiplyScalar(v * x), r.hemi[m] = t, m++
                            }
                        }
                        p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Ds.LTC_FLOAT_1, r.rectAreaLTC2 = Ds.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Ds.LTC_HALF_1, r.rectAreaLTC2 = Ds.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = h;
                        const v = r.hash;
                        v.directionalLength === c && v.pointLength === u && v.spotLength === d && v.rectAreaLength === p && v.hemiLength === m && v.numDirectionalShadows === f && v.numPointShadows === g && v.numSpotShadows === y || (r.directional.length = c, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = y, r.spotShadowMap.length = y, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = y, v.directionalLength = c, v.pointLength = u, v.spotLength = d, v.rectAreaLength = p, v.hemiLength = m, v.numDirectionalShadows = f, v.numPointShadows = g, v.numSpotShadows = y, r.version = jo++)
                    },
                    setupView: function(t, e) {
                        let i = 0,
                            n = 0,
                            l = 0,
                            h = 0,
                            c = 0;
                        const u = e.matrixWorldInverse;
                        for (let d = 0, p = t.length; d < p; d++) {
                            const e = t[d];
                            if (e.isDirectionalLight) {
                                const t = r.directional[i];
                                t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), i++
                            } else if (e.isSpotLight) {
                                const t = r.spot[l];
                                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
                            } else if (e.isRectAreaLight) {
                                const t = r.rectArea[h];
                                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), o.identity(), a.copy(e.matrixWorld), a.premultiply(u), o.extractRotation(a), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(o), t.halfHeight.applyMatrix4(o), h++
                            } else if (e.isPointLight) {
                                const t = r.point[n];
                                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), n++
                            } else if (e.isHemisphereLight) {
                                const t = r.hemi[c];
                                t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), c++
                            }
                        }
                    },
                    state: r
                }
            }

            function Yo(t, e) {
                const i = new Xo(t, e),
                    n = [],
                    r = [];
                return {
                    init: function() {
                        n.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: n,
                        shadowsArray: r,
                        lights: i
                    },
                    setupLights: function(t) {
                        i.setup(n, t)
                    },
                    setupLightsView: function(t) {
                        i.setupView(n, t)
                    },
                    pushLight: function(t) {
                        n.push(t)
                    },
                    pushShadow: function(t) {
                        r.push(t)
                    }
                }
            }

            function Jo(t, e) {
                let i = new WeakMap;
                return {
                    get: function(n, r = 0) {
                        let s;
                        return !1 === i.has(n) ? (s = new Yo(t, e), i.set(n, [s])) : r >= i.get(n).length ? (s = new Yo(t, e), i.get(n).push(s)) : s = i.get(n)[r], s
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            class Zo extends Lr {
                constructor(t) {
                    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                }
            }
            Zo.prototype.isMeshDepthMaterial = !0;
            class Qo extends Lr {
                constructor(t) {
                    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new fn, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                }
            }
            Qo.prototype.isMeshDistanceMaterial = !0;

            function Ko(t, e, i) {
                let n = new Cs;
                const r = new Vi,
                    s = new Vi,
                    a = new cn,
                    o = new Zo({
                        depthPacking: 3201
                    }),
                    l = new Qo,
                    h = {},
                    c = i.maxTextureSize,
                    u = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    d = new fs({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Vi
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    p = d.clone();
                p.defines.HORIZONTAL_PASS = 1;
                const m = new jr;
                m.setAttribute("position", new Ir(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const f = new hs(m, d),
                    g = this;

                function y(i, n) {
                    const r = e.update(f);
                    d.defines.VSM_SAMPLES !== i.blurSamples && (d.defines.VSM_SAMPLES = i.blurSamples, p.defines.VSM_SAMPLES = i.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), d.uniforms.shadow_pass.value = i.map.texture, d.uniforms.resolution.value = i.mapSize, d.uniforms.radius.value = i.radius, t.setRenderTarget(i.mapPass), t.clear(), t.renderBufferDirect(n, null, r, d, f, null), p.uniforms.shadow_pass.value = i.mapPass.texture, p.uniforms.resolution.value = i.mapSize, p.uniforms.radius.value = i.radius, t.setRenderTarget(i.map), t.clear(), t.renderBufferDirect(n, null, r, p, f, null)
                }

                function x(e, i, n, r, s, a) {
                    let c = null;
                    const d = !0 === n.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                    if (c = void 0 !== d ? d : !0 === n.isPointLight ? l : o, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                        const t = c.uuid,
                            e = i.uuid;
                        let n = h[t];
                        void 0 === n && (n = {}, h[t] = n);
                        let r = n[e];
                        void 0 === r && (r = c.clone(), n[e] = r), c = r
                    }
                    return c.visible = i.visible, c.wireframe = i.wireframe, c.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], c.alphaMap = i.alphaMap, c.alphaTest = i.alphaTest, c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.displacementMap = i.displacementMap, c.displacementScale = i.displacementScale, c.displacementBias = i.displacementBias, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === n.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(n.matrixWorld), c.nearDistance = r, c.farDistance = s), c
                }

                function v(i, r, s, a, o) {
                    if (!1 === i.visible) return;
                    if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === o) && (!i.frustumCulled || n.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                        const n = e.update(i),
                            r = i.material;
                        if (Array.isArray(r)) {
                            const e = n.groups;
                            for (let l = 0, h = e.length; l < h; l++) {
                                const h = e[l],
                                    c = r[h.materialIndex];
                                if (c && c.visible) {
                                    const e = x(i, c, a, s.near, s.far, o);
                                    t.renderBufferDirect(s, null, n, e, i, h)
                                }
                            }
                        } else if (r.visible) {
                            const e = x(i, r, a, s.near, s.far, o);
                            t.renderBufferDirect(s, null, n, e, i, null)
                        }
                    }
                    const l = i.children;
                    for (let t = 0, e = l.length; t < e; t++) v(l[t], r, s, a, o)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, i, o) {
                    if (!1 === g.enabled) return;
                    if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                    if (0 === e.length) return;
                    const l = t.getRenderTarget(),
                        h = t.getActiveCubeFace(),
                        u = t.getActiveMipmapLevel(),
                        d = t.state;
                    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (let p = 0, m = e.length; p < m; p++) {
                        const l = e[p],
                            h = l.shadow;
                        if (void 0 === h) {
                            console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                            continue
                        }
                        if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                        r.copy(h.mapSize);
                        const u = h.getFrameExtents();
                        if (r.multiply(u), s.copy(h.mapSize), (r.x > c || r.y > c) && (r.x > c && (s.x = Math.floor(c / u.x), r.x = s.x * u.x, h.mapSize.x = s.x), r.y > c && (s.y = Math.floor(c / u.y), r.y = s.y * u.y, h.mapSize.y = s.y)), null !== h.map || h.isPointLightShadow || 3 !== this.type || (h.map = new un(r.x, r.y), h.map.texture.name = l.name + ".shadowMap", h.mapPass = new un(r.x, r.y), h.camera.updateProjectionMatrix()), null === h.map) {
                            const t = {
                                minFilter: Qe,
                                magFilter: Qe,
                                format: hi
                            };
                            h.map = new un(r.x, r.y, t), h.map.texture.name = l.name + ".shadowMap", h.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(h.map), t.clear();
                        const m = h.getViewportCount();
                        for (let t = 0; t < m; t++) {
                            const e = h.getViewport(t);
                            a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(a), h.updateMatrices(l, t), n = h.getFrustum(), v(i, o, h.camera, l, this.type)
                        }
                        h.isPointLightShadow || 3 !== this.type || y(h, o), h.needsUpdate = !1
                    }
                    g.needsUpdate = !1, t.setRenderTarget(l, h, u)
                }
            }

            function $o(t, e, i) {
                const n = i.isWebGL2;
                const r = new function() {
                        let e = !1;
                        const i = new cn;
                        let n = null;
                        const r = new cn(0, 0, 0, 0);
                        return {
                            setMask: function(i) {
                                n === i || e || (t.colorMask(i, i, i, i), n = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, n, s, a, o) {
                                !0 === o && (e *= a, n *= a, s *= a), i.set(e, n, s, a), !1 === r.equals(i) && (t.clearColor(e, n, s, a), r.copy(i))
                            },
                            reset: function() {
                                e = !1, n = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    s = new function() {
                        let e = !1,
                            i = null,
                            n = null,
                            r = null;
                        return {
                            setTest: function(t) {
                                t ? H(2929) : U(2929)
                            },
                            setMask: function(n) {
                                i === n || e || (t.depthMask(n), i = n)
                            },
                            setFunc: function(e) {
                                if (n !== e) {
                                    if (e) switch (e) {
                                        case 0:
                                            t.depthFunc(512);
                                            break;
                                        case 1:
                                            t.depthFunc(519);
                                            break;
                                        case 2:
                                            t.depthFunc(513);
                                            break;
                                        case 3:
                                        default:
                                            t.depthFunc(515);
                                            break;
                                        case 4:
                                            t.depthFunc(514);
                                            break;
                                        case 5:
                                            t.depthFunc(518);
                                            break;
                                        case 6:
                                            t.depthFunc(516);
                                            break;
                                        case 7:
                                            t.depthFunc(517)
                                    } else t.depthFunc(515);
                                    n = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                r !== e && (t.clearDepth(e), r = e)
                            },
                            reset: function() {
                                e = !1, i = null, n = null, r = null
                            }
                        }
                    },
                    a = new function() {
                        let e = !1,
                            i = null,
                            n = null,
                            r = null,
                            s = null,
                            a = null,
                            o = null,
                            l = null,
                            h = null;
                        return {
                            setTest: function(t) {
                                e || (t ? H(2960) : U(2960))
                            },
                            setMask: function(n) {
                                i === n || e || (t.stencilMask(n), i = n)
                            },
                            setFunc: function(e, i, a) {
                                n === e && r === i && s === a || (t.stencilFunc(e, i, a), n = e, r = i, s = a)
                            },
                            setOp: function(e, i, n) {
                                a === e && o === i && l === n || (t.stencilOp(e, i, n), a = e, o = i, l = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                h !== e && (t.clearStencil(e), h = e)
                            },
                            reset: function() {
                                e = !1, i = null, n = null, r = null, s = null, a = null, o = null, l = null, h = null
                            }
                        }
                    };
                let o = {},
                    l = {},
                    h = new WeakMap,
                    c = [],
                    u = null,
                    d = !1,
                    p = null,
                    m = null,
                    f = null,
                    g = null,
                    y = null,
                    x = null,
                    v = null,
                    _ = !1,
                    b = null,
                    M = null,
                    w = null,
                    S = null,
                    E = null;
                const T = t.getParameter(35661);
                let A = !1,
                    C = 0;
                const R = t.getParameter(7938); - 1 !== R.indexOf("WebGL") ? (C = parseFloat(/^WebGL (\d)/.exec(R)[1]), A = C >= 1) : -1 !== R.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL ES (\d)/.exec(R)[1]), A = C >= 2);
                let L = null,
                    P = {};
                const z = t.getParameter(3088),
                    D = t.getParameter(2978),
                    I = (new cn).fromArray(z),
                    N = (new cn).fromArray(D);

                function O(e, i, n) {
                    const r = new Uint8Array(4),
                        s = t.createTexture();
                    t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let a = 0; a < n; a++) t.texImage2D(i + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return s
                }
                const B = {};

                function H(e) {
                    !0 !== o[e] && (t.enable(e), o[e] = !0)
                }

                function U(e) {
                    !1 !== o[e] && (t.disable(e), o[e] = !1)
                }
                B[3553] = O(3553, 3553, 1), B[34067] = O(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), H(2929), s.setFunc(3), G(!1), W(1), H(2884), V(0);
                const F = {
                    [Ve]: 32774,
                    101: 32778,
                    102: 32779
                };
                if (n) F[103] = 32775, F[104] = 32776;
                else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && (F[103] = t.MIN_EXT, F[104] = t.MAX_EXT)
                }
                const k = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773
                };

                function V(e, i, n, r, s, a, o, l) {
                    if (0 !== e) {
                        if (!1 === d && (H(3042), d = !0), 5 === e) s = s || i, a = a || n, o = o || r, i === m && s === y || (t.blendEquationSeparate(F[i], F[s]), m = i, y = s), n === f && r === g && a === x && o === v || (t.blendFuncSeparate(k[n], k[r], k[a], k[o]), f = n, g = r, x = a, v = o), p = e, _ = null;
                        else if (e !== p || l !== _) {
                            if (m === Ve && y === Ve || (t.blendEquation(32774), m = Ve, y = Ve), l) switch (e) {
                                case 1:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(1, 1);
                                    break;
                                case 3:
                                    t.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case 4:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case 1:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(770, 1);
                                    break;
                                case 3:
                                    t.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case 4:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            f = null, g = null, x = null, v = null, p = e, _ = l
                        }
                    } else !0 === d && (U(3042), d = !1)
                }

                function G(e) {
                    b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), b = e)
                }

                function W(e) {
                    0 !== e ? (H(2884), e !== M && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : U(2884), M = e
                }

                function j(e, i, n) {
                    e ? (H(32823), S === i && E === n || (t.polygonOffset(i, n), S = i, E = n)) : U(32823)
                }

                function q(e) {
                    void 0 === e && (e = 33984 + T - 1), L !== e && (t.activeTexture(e), L = e)
                }
                return {
                    buffers: {
                        color: r,
                        depth: s,
                        stencil: a
                    },
                    enable: H,
                    disable: U,
                    bindFramebuffer: function(e, i) {
                        return l[e] !== i && (t.bindFramebuffer(e, i), l[e] = i, n && (36009 === e && (l[36160] = i), 36160 === e && (l[36009] = i)), !0)
                    },
                    drawBuffers: function(n, r) {
                        let s = c,
                            a = !1;
                        if (n)
                            if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), n.isWebGLMultipleRenderTargets) {
                                const t = n.texture;
                                if (s.length !== t.length || 36064 !== s[0]) {
                                    for (let e = 0, i = t.length; e < i; e++) s[e] = 36064 + e;
                                    s.length = t.length, a = !0
                                }
                            } else 36064 !== s[0] && (s[0] = 36064, a = !0);
                        else 1029 !== s[0] && (s[0] = 1029, a = !0);
                        a && (i.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                    },
                    useProgram: function(e) {
                        return u !== e && (t.useProgram(e), u = e, !0)
                    },
                    setBlending: V,
                    setMaterial: function(t, e) {
                        2 === t.side ? U(2884) : H(2884);
                        let i = 1 === t.side;
                        e && (i = !i), G(i), 1 === t.blending && !1 === t.transparent ? V(0) : V(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                        const n = t.stencilWrite;
                        a.setTest(n), n && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? H(32926) : U(32926)
                    },
                    setFlipSided: G,
                    setCullFace: W,
                    setLineWidth: function(e) {
                        e !== w && (A && t.lineWidth(e), w = e)
                    },
                    setPolygonOffset: j,
                    setScissorTest: function(t) {
                        t ? H(3089) : U(3089)
                    },
                    activeTexture: q,
                    bindTexture: function(e, i) {
                        null === L && q();
                        let n = P[L];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        }, P[L] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || B[e]), n.type = e, n.texture = i)
                    },
                    unbindTexture: function() {
                        const e = P[L];
                        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage2D: function() {
                        try {
                            t.texStorage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            t.texStorage3D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            t.texSubImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            t.texSubImage3D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            t.compressedTexSubImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(e) {
                        !1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), I.copy(e))
                    },
                    viewport: function(e) {
                        !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e))
                    },
                    reset: function() {
                        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === n && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), o = {}, L = null, P = {}, l = {}, h = new WeakMap, c = [], u = null, d = !1, p = null, m = null, f = null, g = null, y = null, x = null, v = null, _ = !1, b = null, M = null, w = null, S = null, E = null, I.set(0, 0, t.canvas.width, t.canvas.height), N.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), a.reset()
                    }
                }
            }

            function tl(t, e, i, n, r, s, a) {
                const o = r.isWebGL2,
                    l = r.maxTextures,
                    h = r.maxCubemapSize,
                    c = r.maxTextureSize,
                    u = r.maxSamples,
                    d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                    p = /OculusBrowser/g.test(navigator.userAgent),
                    m = new WeakMap;
                let f;
                const g = new WeakMap;
                let y = !1;
                try {
                    y = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (V) {}

                function x(t, e) {
                    return y ? new OffscreenCanvas(t, e) : ji("canvas")
                }

                function v(t, e, i, n) {
                    let r = 1;
                    if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                        if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                            const n = e ? ki : Math.floor,
                                s = n(r * t.width),
                                a = n(r * t.height);
                            void 0 === f && (f = x(s, a));
                            const o = i ? x(s, a) : f;
                            o.width = s, o.height = a;
                            return o.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), o
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function _(t) {
                    return Fi(t.width) && Fi(t.height)
                }

                function b(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== Qe && t.minFilter !== ti
                }

                function M(e) {
                    t.generateMipmap(e)
                }

                function w(i, n, r, s, a = !1) {
                    if (!1 === o) return n;
                    if (null !== i) {
                        if (void 0 !== t[i]) return t[i];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
                    }
                    let l = n;
                    return 6403 === n && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === n && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === n && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === Si && !1 === a ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l
                }

                function S(t, e, i) {
                    return !0 === b(t, i) || t.isFramebufferTexture && t.minFilter !== Qe && t.minFilter !== ti ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                }

                function E(t) {
                    return t === Qe || t === Ke || t === $e ? 9728 : 9729
                }

                function T(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", T),
                        function(t) {
                            const e = n.get(t);
                            if (void 0 === e.__webglInit) return;
                            const i = t.source,
                                r = g.get(i);
                            if (r) {
                                const n = r[e.__cacheKey];
                                n.usedTimes--, 0 === n.usedTimes && C(t), 0 === Object.keys(r).length && g.delete(i)
                            }
                            n.remove(t)
                        }(e), e.isVideoTexture && m.delete(e)
                }

                function A(e) {
                    const i = e.target;
                    i.removeEventListener("dispose", A),
                        function(e) {
                            const i = e.texture,
                                r = n.get(e),
                                s = n.get(i);
                            void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLCubeRenderTarget)
                                for (let n = 0; n < 6; n++) t.deleteFramebuffer(r.__webglFramebuffer[n]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[n]);
                            else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                            if (e.isWebGLMultipleRenderTargets)
                                for (let o = 0, l = i.length; o < l; o++) {
                                    const e = n.get(i[o]);
                                    e.__webglTexture && (t.deleteTexture(e.__webglTexture), a.memory.textures--), n.remove(i[o])
                                }
                            n.remove(i), n.remove(e)
                        }(i)
                }

                function C(e) {
                    const i = n.get(e);
                    t.deleteTexture(i.__webglTexture);
                    const r = e.source;
                    delete g.get(r)[i.__cacheKey], a.memory.textures--
                }
                let R = 0;

                function L(t, e) {
                    const r = n.get(t);
                    if (t.isVideoTexture && function(t) {
                            const e = a.render.frame;
                            m.get(t) !== e && (m.set(t, e), t.update())
                        }(t), !1 === t.isRenderTargetTexture && t.version > 0 && r.__version !== t.version) {
                        const i = t.image;
                        if (null === i) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else {
                            if (!1 !== i.complete) return void N(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
                }
                const P = {
                        [Ye]: 10497,
                        [Je]: 33071,
                        [Ze]: 33648
                    },
                    z = {
                        [Qe]: 9728,
                        [Ke]: 9984,
                        [$e]: 9986,
                        [ti]: 9729,
                        [ei]: 9985,
                        [ii]: 9987
                    };

                function D(i, s, a) {
                    if (a ? (t.texParameteri(i, 10242, P[s.wrapS]), t.texParameteri(i, 10243, P[s.wrapT]), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, P[s.wrapR]), t.texParameteri(i, 10240, z[s.magFilter]), t.texParameteri(i, 10241, z[s.minFilter])) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), s.wrapS === Je && s.wrapT === Je || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, E(s.magFilter)), t.texParameteri(i, 10241, E(s.minFilter)), s.minFilter !== Qe && s.minFilter !== ti && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                        const a = e.get("EXT_texture_filter_anisotropic");
                        if (s.type === ai && !1 === e.has("OES_texture_float_linear")) return;
                        if (!1 === o && s.type === oi && !1 === e.has("OES_texture_half_float_linear")) return;
                        (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy)
                    }
                }

                function I(e, i) {
                    let n = !1;
                    void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", T));
                    const r = i.source;
                    let s = g.get(r);
                    void 0 === s && (s = {}, g.set(r, s));
                    const o = function(t) {
                        const e = [];
                        return e.push(t.wrapS), e.push(t.wrapT), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.encoding), e.join()
                    }(i);
                    if (o !== e.__cacheKey) {
                        void 0 === s[o] && (s[o] = {
                            texture: t.createTexture(),
                            usedTimes: 0
                        }, a.memory.textures++, n = !0), s[o].usedTimes++;
                        const r = s[e.__cacheKey];
                        void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && C(i)), e.__cacheKey = o, e.__webglTexture = s[o].texture
                    }
                    return n
                }

                function N(e, n, r) {
                    let a = 3553;
                    n.isDataArrayTexture && (a = 35866), n.isData3DTexture && (a = 32879);
                    const l = I(e, n),
                        h = n.source;
                    if (i.activeTexture(33984 + r), i.bindTexture(a, e.__webglTexture), h.version !== h.__currentVersion || !0 === l) {
                        t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
                        const r = function(t) {
                            return !o && (t.wrapS !== Je || t.wrapT !== Je || t.minFilter !== Qe && t.minFilter !== ti)
                        }(n) && !1 === _(n.image);
                        let l = v(n.image, r, !1, c);
                        l = k(n, l);
                        const u = _(l) || o,
                            d = s.convert(n.format, n.encoding);
                        let p, m = s.convert(n.type),
                            f = w(n.internalFormat, d, m, n.encoding, n.isVideoTexture);
                        D(a, n, u);
                        const g = n.mipmaps,
                            y = o && !0 !== n.isVideoTexture,
                            x = void 0 === e.__version,
                            E = S(n, l, u);
                        if (n.isDepthTexture) f = 6402, o ? f = n.type === ai ? 36012 : n.type === si ? 33190 : n.type === li ? 35056 : 33189 : n.type === ai && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === ci && 6402 === f && n.type !== ri && n.type !== si && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = ri, m = s.convert(n.type)), n.format === ui && 6402 === f && (f = 34041, n.type !== li && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = li, m = s.convert(n.type))), y && x ? i.texStorage2D(3553, 1, f, l.width, l.height) : i.texImage2D(3553, 0, f, l.width, l.height, 0, d, m, null);
                        else if (n.isDataTexture)
                            if (g.length > 0 && u) {
                                y && x && i.texStorage2D(3553, E, f, g[0].width, g[0].height);
                                for (let t = 0, e = g.length; t < e; t++) p = g[t], y ? i.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, m, p.data) : i.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                                n.generateMipmaps = !1
                            } else y ? (x && i.texStorage2D(3553, E, f, l.width, l.height), i.texSubImage2D(3553, 0, 0, 0, l.width, l.height, d, m, l.data)) : i.texImage2D(3553, 0, f, l.width, l.height, 0, d, m, l.data);
                        else if (n.isCompressedTexture) {
                            y && x && i.texStorage2D(3553, E, f, g[0].width, g[0].height);
                            for (let t = 0, e = g.length; t < e; t++) p = g[t], n.format !== hi ? null !== d ? y ? i.compressedTexSubImage2D(3553, t, 0, 0, p.width, p.height, d, p.data) : i.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : y ? i.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, m, p.data) : i.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data)
                        } else if (n.isDataArrayTexture) y ? (x && i.texStorage3D(35866, E, f, l.width, l.height, l.depth), i.texSubImage3D(35866, 0, 0, 0, 0, l.width, l.height, l.depth, d, m, l.data)) : i.texImage3D(35866, 0, f, l.width, l.height, l.depth, 0, d, m, l.data);
                        else if (n.isData3DTexture) y ? (x && i.texStorage3D(32879, E, f, l.width, l.height, l.depth), i.texSubImage3D(32879, 0, 0, 0, 0, l.width, l.height, l.depth, d, m, l.data)) : i.texImage3D(32879, 0, f, l.width, l.height, l.depth, 0, d, m, l.data);
                        else if (n.isFramebufferTexture) y && x ? i.texStorage2D(3553, E, f, l.width, l.height) : i.texImage2D(3553, 0, f, l.width, l.height, 0, d, m, null);
                        else if (g.length > 0 && u) {
                            y && x && i.texStorage2D(3553, E, f, g[0].width, g[0].height);
                            for (let t = 0, e = g.length; t < e; t++) p = g[t], y ? i.texSubImage2D(3553, t, 0, 0, d, m, p) : i.texImage2D(3553, t, f, d, m, p);
                            n.generateMipmaps = !1
                        } else y ? (x && i.texStorage2D(3553, E, f, l.width, l.height), i.texSubImage2D(3553, 0, 0, 0, d, m, l)) : i.texImage2D(3553, 0, f, d, m, l);
                        b(n, u) && M(a), h.__currentVersion = h.version, n.onUpdate && n.onUpdate(n)
                    }
                    e.__version = n.version
                }

                function O(e, r, a, o, l) {
                    const h = s.convert(a.format, a.encoding),
                        c = s.convert(a.type),
                        u = w(a.internalFormat, h, c, a.encoding);
                    n.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, h, c, null) : i.texImage2D(l, 0, u, r.width, r.height, 0, h, c, null)), i.bindFramebuffer(36160, e), F(r) ? d.framebufferTexture2DMultisampleEXT(36160, o, l, n.get(a).__webglTexture, 0, U(r)) : t.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0), i.bindFramebuffer(36160, null)
                }

                function B(e, i, n) {
                    if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) {
                        let r = 33189;
                        if (n || F(i)) {
                            const e = i.depthTexture;
                            e && e.isDepthTexture && (e.type === ai ? r = 36012 : e.type === si && (r = 33190));
                            const n = U(i);
                            F(i) ? d.renderbufferStorageMultisampleEXT(36161, n, r, i.width, i.height) : t.renderbufferStorageMultisample(36161, n, r, i.width, i.height)
                        } else t.renderbufferStorage(36161, r, i.width, i.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (i.depthBuffer && i.stencilBuffer) {
                        const r = U(i);
                        n && !1 === F(i) ? t.renderbufferStorageMultisample(36161, r, 35056, i.width, i.height) : F(i) ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, i.width, i.height) : t.renderbufferStorage(36161, 34041, i.width, i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        const e = !0 === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture,
                            r = s.convert(e.format, e.encoding),
                            a = s.convert(e.type),
                            o = w(e.internalFormat, r, a, e.encoding),
                            l = U(i);
                        n && !1 === F(i) ? t.renderbufferStorageMultisample(36161, l, o, i.width, i.height) : F(i) ? d.renderbufferStorageMultisampleEXT(36161, l, o, i.width, i.height) : t.renderbufferStorage(36161, o, i.width, i.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function H(e) {
                    const r = n.get(e),
                        s = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                        if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, r) {
                            if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (i.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), L(r.depthTexture, 0);
                            const s = n.get(r.depthTexture).__webglTexture,
                                a = U(r);
                            if (r.depthTexture.format === ci) F(r) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                            else {
                                if (r.depthTexture.format !== ui) throw new Error("Unknown depthTexture format");
                                F(r) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                            }
                        }(r.__webglFramebuffer, e)
                    } else if (s) {
                        r.__webglDepthbuffer = [];
                        for (let n = 0; n < 6; n++) i.bindFramebuffer(36160, r.__webglFramebuffer[n]), r.__webglDepthbuffer[n] = t.createRenderbuffer(), B(r.__webglDepthbuffer[n], e, !1)
                    } else i.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), B(r.__webglDepthbuffer, e, !1);
                    i.bindFramebuffer(36160, null)
                }

                function U(t) {
                    return Math.min(u, t.samples)
                }

                function F(t) {
                    const i = n.get(t);
                    return o && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture
                }

                function k(t, i) {
                    const n = t.encoding,
                        r = t.format,
                        s = t.type;
                    return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === Pi || n !== wi && (n === Si ? !1 === o ? !0 === e.has("EXT_sRGB") && r === hi ? (t.format = Pi, t.minFilter = ti, t.generateMipmaps = !1) : i = sn.sRGBToLinear(i) : r === hi && s === ni || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)), i
                }
                this.allocateTextureUnit = function() {
                    const t = R;
                    return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), R += 1, t
                }, this.resetTextureUnits = function() {
                    R = 0
                }, this.setTexture2D = L, this.setTexture2DArray = function(t, e) {
                    const r = n.get(t);
                    t.version > 0 && r.__version !== t.version ? N(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function(t, e) {
                    const r = n.get(t);
                    t.version > 0 && r.__version !== t.version ? N(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = function(e, r) {
                    const a = n.get(e);
                    e.version > 0 && a.__version !== e.version ? function(e, n, r) {
                        if (6 !== n.image.length) return;
                        const a = I(e, n),
                            l = n.source;
                        if (i.activeTexture(33984 + r), i.bindTexture(34067, e.__webglTexture), l.version !== l.__currentVersion || !0 === a) {
                            t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
                            const r = n.isCompressedTexture || n.image[0].isCompressedTexture,
                                a = n.image[0] && n.image[0].isDataTexture,
                                c = [];
                            for (let t = 0; t < 6; t++) c[t] = r || a ? a ? n.image[t].image : n.image[t] : v(n.image[t], !1, !0, h), c[t] = k(n, c[t]);
                            const u = c[0],
                                d = _(u) || o,
                                p = s.convert(n.format, n.encoding),
                                m = s.convert(n.type),
                                f = w(n.internalFormat, p, m, n.encoding),
                                g = o && !0 !== n.isVideoTexture,
                                y = void 0 === e.__version;
                            let x, E = S(n, u, d);
                            if (D(34067, n, d), r) {
                                g && y && i.texStorage2D(34067, E, f, u.width, u.height);
                                for (let t = 0; t < 6; t++) {
                                    x = c[t].mipmaps;
                                    for (let e = 0; e < x.length; e++) {
                                        const r = x[e];
                                        n.format !== hi ? null !== p ? g ? i.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, r.data) : i.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? i.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, m, r.data) : i.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                    }
                                }
                            } else {
                                x = n.mipmaps, g && y && (x.length > 0 && E++, i.texStorage2D(34067, E, f, c[0].width, c[0].height));
                                for (let t = 0; t < 6; t++)
                                    if (a) {
                                        g ? i.texSubImage2D(34069 + t, 0, 0, 0, c[t].width, c[t].height, p, m, c[t].data) : i.texImage2D(34069 + t, 0, f, c[t].width, c[t].height, 0, p, m, c[t].data);
                                        for (let e = 0; e < x.length; e++) {
                                            const n = x[e].image[t].image;
                                            g ? i.texSubImage2D(34069 + t, e + 1, 0, 0, n.width, n.height, p, m, n.data) : i.texImage2D(34069 + t, e + 1, f, n.width, n.height, 0, p, m, n.data)
                                        }
                                    } else {
                                        g ? i.texSubImage2D(34069 + t, 0, 0, 0, p, m, c[t]) : i.texImage2D(34069 + t, 0, f, p, m, c[t]);
                                        for (let e = 0; e < x.length; e++) {
                                            const n = x[e];
                                            g ? i.texSubImage2D(34069 + t, e + 1, 0, 0, p, m, n.image[t]) : i.texImage2D(34069 + t, e + 1, f, p, m, n.image[t])
                                        }
                                    }
                            }
                            b(n, d) && M(34067), l.__currentVersion = l.version, n.onUpdate && n.onUpdate(n)
                        }
                        e.__version = n.version
                    }(a, e, r) : (i.activeTexture(33984 + r), i.bindTexture(34067, a.__webglTexture))
                }, this.rebindTextures = function(t, e, i) {
                    const r = n.get(t);
                    void 0 !== e && O(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== i && H(t)
                }, this.setupRenderTarget = function(e) {
                    const l = e.texture,
                        h = n.get(e),
                        c = n.get(l);
                    e.addEventListener("dispose", A), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()), c.__version = l.version, a.memory.textures++);
                    const u = !0 === e.isWebGLCubeRenderTarget,
                        d = !0 === e.isWebGLMultipleRenderTargets,
                        p = _(e) || o;
                    if (u) {
                        h.__webglFramebuffer = [];
                        for (let e = 0; e < 6; e++) h.__webglFramebuffer[e] = t.createFramebuffer()
                    } else if (h.__webglFramebuffer = t.createFramebuffer(), d)
                        if (r.drawBuffers) {
                            const i = e.texture;
                            for (let e = 0, r = i.length; e < r; e++) {
                                const r = n.get(i[e]);
                                void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), a.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    else if (o && e.samples > 0 && !1 === F(e)) {
                        h.__webglMultisampledFramebuffer = t.createFramebuffer(), h.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, h.__webglColorRenderbuffer);
                        const n = s.convert(l.format, l.encoding),
                            r = s.convert(l.type),
                            a = w(l.internalFormat, n, r, l.encoding),
                            o = U(e);
                        t.renderbufferStorageMultisample(36161, o, a, e.width, e.height), i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, h.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (h.__webglDepthRenderbuffer = t.createRenderbuffer(), B(h.__webglDepthRenderbuffer, e, !0)), i.bindFramebuffer(36160, null)
                    }
                    if (u) {
                        i.bindTexture(34067, c.__webglTexture), D(34067, l, p);
                        for (let t = 0; t < 6; t++) O(h.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                        b(l, p) && M(34067), i.unbindTexture()
                    } else if (d) {
                        const t = e.texture;
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r],
                                a = n.get(s);
                            i.bindTexture(3553, a.__webglTexture), D(3553, s, p), O(h.__webglFramebuffer, e, s, 36064 + r, 3553), b(s, p) && M(3553)
                        }
                        i.unbindTexture()
                    } else {
                        let t = 3553;
                        (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (o ? t = e.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), i.bindTexture(t, c.__webglTexture), D(t, l, p), O(h.__webglFramebuffer, e, l, 36064, t), b(l, p) && M(t), i.unbindTexture()
                    }
                    e.depthBuffer && H(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    const e = _(t) || o,
                        r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                    for (let s = 0, a = r.length; s < a; s++) {
                        const a = r[s];
                        if (b(a, e)) {
                            const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                r = n.get(a).__webglTexture;
                            i.bindTexture(e, r), M(e), i.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (o && e.samples > 0 && !1 === F(e)) {
                        const r = e.width,
                            s = e.height;
                        let a = 16384;
                        const o = [36064],
                            l = e.stencilBuffer ? 33306 : 36096;
                        e.depthBuffer && o.push(l);
                        const h = n.get(e),
                            c = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                        !1 === c && (e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024)), i.bindFramebuffer(36008, h.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, h.__webglFramebuffer), !0 === c && (t.invalidateFramebuffer(36008, [l]), t.invalidateFramebuffer(36009, [l])), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), p && t.invalidateFramebuffer(36008, o), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, h.__webglMultisampledFramebuffer)
                    }
                }, this.setupDepthRenderbuffer = H, this.setupFrameBufferTexture = O, this.useMultisampledRTT = F
            }

            function el(t, e, i) {
                const n = i.isWebGL2;
                return {
                    convert: function(t, i = null) {
                        let r;
                        if (t === ni) return 5121;
                        if (1017 === t) return 32819;
                        if (1018 === t) return 32820;
                        if (1010 === t) return 5120;
                        if (1011 === t) return 5122;
                        if (t === ri) return 5123;
                        if (1013 === t) return 5124;
                        if (t === si) return 5125;
                        if (t === ai) return 5126;
                        if (t === oi) return n ? 5131 : (r = e.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
                        if (1021 === t) return 6406;
                        if (t === hi) return 6408;
                        if (1024 === t) return 6409;
                        if (1025 === t) return 6410;
                        if (t === ci) return 6402;
                        if (t === ui) return 34041;
                        if (1028 === t) return 6403;
                        if (1022 === t) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                        if (t === Pi) return r = e.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null;
                        if (1029 === t) return 36244;
                        if (1030 === t) return 33319;
                        if (1031 === t) return 33320;
                        if (1033 === t) return 36249;
                        if (t === di || t === pi || t === mi || t === fi)
                            if (i === Si) {
                                if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
                                if (t === di) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (t === pi) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (t === mi) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (t === fi) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (r = e.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                                if (t === di) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (t === pi) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (t === mi) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (t === fi) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                            if (r = e.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                            if (35840 === t) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === t) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === t) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === t) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === t) return r = e.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (37492 === t || 37496 === t) {
                            if (r = e.get("WEBGL_compressed_texture_etc"), null === r) return null;
                            if (37492 === t) return i === Si ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                            if (37496 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
                            if (r = e.get("WEBGL_compressed_texture_astc"), null === r) return null;
                            if (37808 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (37809 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (37810 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (37811 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (37812 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (37813 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (37814 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (37815 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (37816 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (37817 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (37818 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (37819 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (37820 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (37821 === t) return i === Si ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (36492 === t) {
                            if (r = e.get("EXT_texture_compression_bptc"), null === r) return null;
                            if (36492 === t) return i === Si ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        return t === li ? n ? 34042 : (r = e.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }
            class il extends ys {
                constructor(t = []) {
                    super(), this.cameras = t
                }
            }
            il.prototype.isArrayCamera = !0;
            class nl extends yr {
                constructor() {
                    super(), this.type = "Group"
                }
            }
            nl.prototype.isGroup = !0;
            const rl = {
                type: "move"
            };
            class sl {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new nl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new nl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new fn, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new fn), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new nl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new fn, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new fn), this._grip
                }
                dispatchEvent(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                }
                disconnect(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(t, e, i) {
                    let n = null,
                        r = null,
                        s = null;
                    const a = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState)
                        if (null !== a && (n = e.getPose(t.targetRaySpace, i), null !== n && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(rl))), l && t.hand) {
                            s = !0;
                            for (const s of t.hand.values()) {
                                const t = e.getJointPose(s, i);
                                if (void 0 === l.joints[s.jointName]) {
                                    const t = new nl;
                                    t.matrixAutoUpdate = !1, t.visible = !1, l.joints[s.jointName] = t, l.add(t)
                                }
                                const n = l.joints[s.jointName];
                                null !== t && (n.matrix.fromArray(t.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.jointRadius = t.radius), n.visible = null !== t
                            }
                            const n = l.joints["index-finger-tip"],
                                r = l.joints["thumb-tip"],
                                a = n.position.distanceTo(r.position),
                                o = .02,
                                h = .005;
                            l.inputState.pinching && a > o + h ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: t.handedness,
                                target: this
                            })) : !l.inputState.pinching && a <= o - h && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: t.handedness,
                                target: this
                            }))
                        } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    return null !== a && (a.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                }
            }
            class al extends hn {
                constructor(t, e, i, n, r, s, a, o, l, h) {
                    if ((h = void 0 !== h ? h : ci) !== ci && h !== ui) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === i && h === ci && (i = ri), void 0 === i && h === ui && (i = li), super(null, n, r, s, a, o, h, i, l), this.image = {
                        width: t,
                        height: e
                    }, this.magFilter = void 0 !== a ? a : Qe, this.minFilter = void 0 !== o ? o : Qe, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            al.prototype.isDepthTexture = !0;
            class ol extends zi {
                constructor(t, e) {
                    super();
                    const i = this;
                    let n = null,
                        r = 1,
                        s = null,
                        a = "local-floor",
                        o = null,
                        l = null,
                        h = null,
                        c = null,
                        u = null;
                    const d = e.getContextAttributes();
                    let p = null,
                        m = null;
                    const f = [],
                        g = new Map,
                        y = new ys;
                    y.layers.enable(1), y.viewport = new cn;
                    const x = new ys;
                    x.layers.enable(2), x.viewport = new cn;
                    const v = [y, x],
                        _ = new il;
                    _.layers.enable(1), _.layers.enable(2);
                    let b = null,
                        M = null;

                    function w(t) {
                        const e = g.get(t.inputSource);
                        e && e.dispatchEvent({
                            type: t.type,
                            data: t.inputSource
                        })
                    }

                    function S() {
                        g.forEach((function(t, e) {
                            t.disconnect(e)
                        })), g.clear(), b = null, M = null, t.setRenderTarget(p), c = null, h = null, l = null, n = null, m = null, L.stop(), i.isPresenting = !1, i.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function E(t) {
                        const e = n.inputSources;
                        for (let i = 0; i < f.length; i++) g.set(e[i], f[i]);
                        for (let i = 0; i < t.removed.length; i++) {
                            const e = t.removed[i],
                                n = g.get(e);
                            n && (n.dispatchEvent({
                                type: "disconnected",
                                data: e
                            }), g.delete(e))
                        }
                        for (let i = 0; i < t.added.length; i++) {
                            const e = t.added[i],
                                n = g.get(e);
                            n && n.dispatchEvent({
                                type: "connected",
                                data: e
                            })
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                        let e = f[t];
                        return void 0 === e && (e = new sl, f[t] = e), e.getTargetRaySpace()
                    }, this.getControllerGrip = function(t) {
                        let e = f[t];
                        return void 0 === e && (e = new sl, f[t] = e), e.getGripSpace()
                    }, this.getHand = function(t) {
                        let e = f[t];
                        return void 0 === e && (e = new sl, f[t] = e), e.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(t) {
                        r = t, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function(t) {
                        a = t, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function() {
                        return s
                    }, this.getBaseLayer = function() {
                        return null !== h ? h : c
                    }, this.getBinding = function() {
                        return l
                    }, this.getFrame = function() {
                        return u
                    }, this.getSession = function() {
                        return n
                    }, this.setSession = async function(o) {
                        if (n = o, null !== n) {
                            if (p = t.getRenderTarget(), n.addEventListener("select", w), n.addEventListener("selectstart", w), n.addEventListener("selectend", w), n.addEventListener("squeeze", w), n.addEventListener("squeezestart", w), n.addEventListener("squeezeend", w), n.addEventListener("end", S), n.addEventListener("inputsourceschange", E), !0 !== d.xrCompatible && await e.makeXRCompatible(), void 0 === n.renderState.layers || !1 === t.capabilities.isWebGL2) {
                                const i = {
                                    antialias: void 0 !== n.renderState.layers || d.antialias,
                                    alpha: d.alpha,
                                    depth: d.depth,
                                    stencil: d.stencil,
                                    framebufferScaleFactor: r
                                };
                                c = new XRWebGLLayer(n, e, i), n.updateRenderState({
                                    baseLayer: c
                                }), m = new un(c.framebufferWidth, c.framebufferHeight, {
                                    format: hi,
                                    type: ni,
                                    encoding: t.outputEncoding
                                })
                            } else {
                                let i = null,
                                    s = null,
                                    a = null;
                                d.depth && (a = d.stencil ? 35056 : 33190, i = d.stencil ? ui : ci, s = d.stencil ? li : ri);
                                const o = {
                                    colorFormat: t.outputEncoding === Si ? 35907 : 32856,
                                    depthFormat: a,
                                    scaleFactor: r
                                };
                                l = new XRWebGLBinding(n, e), h = l.createProjectionLayer(o), n.updateRenderState({
                                    layers: [h]
                                }), m = new un(h.textureWidth, h.textureHeight, {
                                    format: hi,
                                    type: ni,
                                    depthTexture: new al(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, i),
                                    stencilBuffer: d.stencil,
                                    encoding: t.outputEncoding,
                                    samples: d.antialias ? 4 : 0
                                });
                                t.properties.get(m).__ignoreDepthValues = h.ignoreDepthValues
                            }
                            m.isXRRenderTarget = !0, this.setFoveation(1), s = await n.requestReferenceSpace(a), L.setContext(n), L.start(), i.isPresenting = !0, i.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    const T = new fn,
                        A = new fn;

                    function C(t, e) {
                        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                    }
                    this.updateCamera = function(t) {
                        if (null === n) return;
                        _.near = x.near = y.near = t.near, _.far = x.far = y.far = t.far, b === _.near && M === _.far || (n.updateRenderState({
                            depthNear: _.near,
                            depthFar: _.far
                        }), b = _.near, M = _.far);
                        const e = t.parent,
                            i = _.cameras;
                        C(_, e);
                        for (let n = 0; n < i.length; n++) C(i[n], e);
                        _.matrixWorld.decompose(_.position, _.quaternion, _.scale), t.position.copy(_.position), t.quaternion.copy(_.quaternion), t.scale.copy(_.scale), t.matrix.copy(_.matrix), t.matrixWorld.copy(_.matrixWorld);
                        const r = t.children;
                        for (let n = 0, s = r.length; n < s; n++) r[n].updateMatrixWorld(!0);
                        2 === i.length ? function(t, e, i) {
                            T.setFromMatrixPosition(e.matrixWorld), A.setFromMatrixPosition(i.matrixWorld);
                            const n = T.distanceTo(A),
                                r = e.projectionMatrix.elements,
                                s = i.projectionMatrix.elements,
                                a = r[14] / (r[10] - 1),
                                o = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                h = (r[9] - 1) / r[5],
                                c = (r[8] - 1) / r[0],
                                u = (s[8] + 1) / s[0],
                                d = a * c,
                                p = a * u,
                                m = n / (-c + u),
                                f = m * -c;
                            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                            const g = a + m,
                                y = o + m,
                                x = d - f,
                                v = p + (n - f),
                                _ = l * o / y * g,
                                b = h * o / y * g;
                            t.projectionMatrix.makePerspective(x, v, _, b, g, y)
                        }(_, y, x) : _.projectionMatrix.copy(y.projectionMatrix)
                    }, this.getCamera = function() {
                        return _
                    }, this.getFoveation = function() {
                        return null !== h ? h.fixedFoveation : null !== c ? c.fixedFoveation : void 0
                    }, this.setFoveation = function(t) {
                        null !== h && (h.fixedFoveation = t), null !== c && void 0 !== c.fixedFoveation && (c.fixedFoveation = t)
                    };
                    let R = null;
                    const L = new Rs;
                    L.setAnimationLoop((function(e, i) {
                        if (o = i.getViewerPose(s), u = i, null !== o) {
                            const e = o.views;
                            null !== c && (t.setRenderTargetFramebuffer(m, c.framebuffer), t.setRenderTarget(m));
                            let i = !1;
                            e.length !== _.cameras.length && (_.cameras.length = 0, i = !0);
                            for (let n = 0; n < e.length; n++) {
                                const r = e[n];
                                let s = null;
                                if (null !== c) s = c.getViewport(r);
                                else {
                                    const e = l.getViewSubImage(h, r);
                                    s = e.viewport, 0 === n && (t.setRenderTargetTextures(m, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(m))
                                }
                                const a = v[n];
                                a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === n && _.matrix.copy(a.matrix), !0 === i && _.cameras.push(a)
                            }
                        }
                        const r = n.inputSources;
                        for (let t = 0; t < f.length; t++) {
                            const e = f[t],
                                n = r[t];
                            e.update(n, i, s)
                        }
                        R && R(e, i), u = null
                    })), this.setAnimationLoop = function(t) {
                        R = t
                    }, this.dispose = function() {}
                }
            }

            function ll(t, e) {
                function i(i, n) {
                    i.opacity.value = n.opacity, n.color && i.diffuse.value.copy(n.color), n.emissive && i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (i.map.value = n.map), n.alphaMap && (i.alphaMap.value = n.alphaMap), n.bumpMap && (i.bumpMap.value = n.bumpMap, i.bumpScale.value = n.bumpScale, 1 === n.side && (i.bumpScale.value *= -1)), n.displacementMap && (i.displacementMap.value = n.displacementMap, i.displacementScale.value = n.displacementScale, i.displacementBias.value = n.displacementBias), n.emissiveMap && (i.emissiveMap.value = n.emissiveMap), n.normalMap && (i.normalMap.value = n.normalMap, i.normalScale.value.copy(n.normalScale), 1 === n.side && i.normalScale.value.negate()), n.specularMap && (i.specularMap.value = n.specularMap), n.alphaTest > 0 && (i.alphaTest.value = n.alphaTest);
                    const r = e.get(n).envMap;
                    if (r && (i.envMap.value = r, i.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = n.reflectivity, i.ior.value = n.ior, i.refractionRatio.value = n.refractionRatio), n.lightMap) {
                        i.lightMap.value = n.lightMap;
                        const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1;
                        i.lightMapIntensity.value = n.lightMapIntensity * e
                    }
                    let s, a;
                    n.aoMap && (i.aoMap.value = n.aoMap, i.aoMapIntensity.value = n.aoMapIntensity), n.map ? s = n.map : n.specularMap ? s = n.specularMap : n.displacementMap ? s = n.displacementMap : n.normalMap ? s = n.normalMap : n.bumpMap ? s = n.bumpMap : n.roughnessMap ? s = n.roughnessMap : n.metalnessMap ? s = n.metalnessMap : n.alphaMap ? s = n.alphaMap : n.emissiveMap ? s = n.emissiveMap : n.clearcoatMap ? s = n.clearcoatMap : n.clearcoatNormalMap ? s = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? s = n.clearcoatRoughnessMap : n.specularIntensityMap ? s = n.specularIntensityMap : n.specularColorMap ? s = n.specularColorMap : n.transmissionMap ? s = n.transmissionMap : n.thicknessMap ? s = n.thicknessMap : n.sheenColorMap ? s = n.sheenColorMap : n.sheenRoughnessMap && (s = n.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), i.uvTransform.value.copy(s.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), i.uv2Transform.value.copy(a.matrix))
                }
                return {
                    refreshFogUniforms: function(t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    },
                    refreshMaterialUniforms: function(t, n, r, s, a) {
                        n.isMeshBasicMaterial || n.isMeshLambertMaterial ? i(t, n) : n.isMeshToonMaterial ? (i(t, n), function(t, e) {
                            e.gradientMap && (t.gradientMap.value = e.gradientMap)
                        }(t, n)) : n.isMeshPhongMaterial ? (i(t, n), function(t, e) {
                            t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                        }(t, n)) : n.isMeshStandardMaterial ? (i(t, n), function(t, i) {
                            t.roughness.value = i.roughness, t.metalness.value = i.metalness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap);
                            i.metalnessMap && (t.metalnessMap.value = i.metalnessMap);
                            e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity)
                        }(t, n), n.isMeshPhysicalMaterial && function(t, e, i) {
                            t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap));
                            e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()));
                            e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
                            t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
                            e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                        }(t, n, a)) : n.isMeshMatcapMaterial ? (i(t, n), function(t, e) {
                            e.matcap && (t.matcap.value = e.matcap)
                        }(t, n)) : n.isMeshDepthMaterial ? i(t, n) : n.isMeshDistanceMaterial ? (i(t, n), function(t, e) {
                            t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                        }(t, n)) : n.isMeshNormalMaterial ? i(t, n) : n.isLineBasicMaterial ? (function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                        }(t, n), n.isLineDashedMaterial && function(t, e) {
                            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                        }(t, n)) : n.isPointsMaterial ? function(t, e, i, n) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * n, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                            let r;
                            e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                        }(t, n, r, s) : n.isSpriteMaterial ? function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                            let i;
                            e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                            void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                        }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
                    }
                }
            }

            function hl(t = {}) {
                const e = void 0 !== t.canvas ? t.canvas : function() {
                        const t = ji("canvas");
                        return t.style.display = "block", t
                    }(),
                    i = void 0 !== t.context ? t.context : null,
                    n = void 0 === t.depth || t.depth,
                    r = void 0 === t.stencil || t.stencil,
                    s = void 0 !== t.antialias && t.antialias,
                    a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    o = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let c;
                c = void 0 !== t.context ? i.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha;
                let u = null,
                    d = null;
                const p = [],
                    m = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = wi, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                const f = this;
                let g = !1,
                    y = 0,
                    x = 0,
                    v = null,
                    _ = -1,
                    b = null;
                const M = new cn,
                    w = new cn;
                let S = null,
                    E = e.width,
                    T = e.height,
                    A = 1,
                    C = null,
                    R = null;
                const L = new cn(0, 0, E, T),
                    P = new cn(0, 0, E, T);
                let z = !1;
                const D = new Cs;
                let I = !1,
                    N = !1,
                    O = null;
                const B = new qn,
                    H = new Vi,
                    U = new fn,
                    F = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function k() {
                    return null === v ? A : 1
                }
                let V, G, W, j, q, X, Y, J, Z, Q, K, $, tt, et, it, nt, rt, st, at, ot, lt, ht, ct, ut = i;

                function dt(t, i) {
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n],
                            s = e.getContext(r, i);
                        if (null !== s) return s
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: n,
                        stencil: r,
                        antialias: s,
                        premultipliedAlpha: a,
                        preserveDrawingBuffer: o,
                        powerPreference: l,
                        failIfMajorPerformanceCaveat: h
                    };
                    if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r139"), e.addEventListener("webglcontextlost", ft, !1), e.addEventListener("webglcontextrestored", gt, !1), null === ut) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === f.isWebGL1Renderer && e.shift(), ut = dt(e, t), null === ut) throw dt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === ut.getShaderPrecisionFormat && (ut.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (Ct) {
                    throw console.error("THREE.WebGLRenderer: " + Ct.message), Ct
                }

                function pt() {
                    V = new na(ut), G = new Hs(ut, V, t), V.init(G), ht = new el(ut, V, G), W = new $o(ut, V, G), j = new aa(ut), q = new Uo, X = new tl(ut, V, W, q, G, ht, j), Y = new Fs(f), J = new ia(f), Z = new Ls(ut, G), ct = new Os(ut, V, Z, G), Q = new ra(ut, Z, j, ct), K = new ua(ut, Q, Z, j), at = new ca(ut, G, X), nt = new Us(q), $ = new Ho(f, Y, J, V, G, ct, nt), tt = new ll(f, q), et = new Go, it = new Jo(V, G), st = new Ns(f, Y, W, K, c, a), rt = new Ko(f, K, G), ot = new Bs(ut, V, j, G), lt = new sa(ut, V, j, G), j.programs = $.programs, f.capabilities = G, f.extensions = V, f.properties = q, f.renderLists = et, f.shadowMap = rt, f.state = W, f.info = j
                }
                pt();
                const mt = new ol(f, ut);

                function ft(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
                }

                function gt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                    const t = j.autoReset,
                        e = rt.enabled,
                        i = rt.autoUpdate,
                        n = rt.needsUpdate,
                        r = rt.type;
                    pt(), j.autoReset = t, rt.enabled = e, rt.autoUpdate = i, rt.needsUpdate = n, rt.type = r
                }

                function yt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", yt),
                        function(t) {
                            (function(t) {
                                const e = q.get(t).programs;
                                void 0 !== e && (e.forEach((function(t) {
                                    $.releaseProgram(t)
                                })), t.isShaderMaterial && $.releaseShaderCache(t))
                            })(t), q.remove(t)
                        }(e)
                }
                this.xr = mt, this.getContext = function() {
                    return ut
                }, this.getContextAttributes = function() {
                    return ut.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const t = V.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    const t = V.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return A
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (A = t, this.setSize(E, T, !1))
                }, this.getSize = function(t) {
                    return t.set(E, T)
                }, this.setSize = function(t, i, n) {
                    mt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, T = i, e.width = Math.floor(t * A), e.height = Math.floor(i * A), !1 !== n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i))
                }, this.getDrawingBufferSize = function(t) {
                    return t.set(E * A, T * A).floor()
                }, this.setDrawingBufferSize = function(t, i, n) {
                    E = t, T = i, A = n, e.width = Math.floor(t * n), e.height = Math.floor(i * n), this.setViewport(0, 0, t, i)
                }, this.getCurrentViewport = function(t) {
                    return t.copy(M)
                }, this.getViewport = function(t) {
                    return t.copy(L)
                }, this.setViewport = function(t, e, i, n) {
                    t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, i, n), W.viewport(M.copy(L).multiplyScalar(A).floor())
                }, this.getScissor = function(t) {
                    return t.copy(P)
                }, this.setScissor = function(t, e, i, n) {
                    t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, i, n), W.scissor(w.copy(P).multiplyScalar(A).floor())
                }, this.getScissorTest = function() {
                    return z
                }, this.setScissorTest = function(t) {
                    W.setScissorTest(z = t)
                }, this.setOpaqueSort = function(t) {
                    C = t
                }, this.setTransparentSort = function(t) {
                    R = t
                }, this.getClearColor = function(t) {
                    return t.copy(st.getClearColor())
                }, this.setClearColor = function() {
                    st.setClearColor.apply(st, arguments)
                }, this.getClearAlpha = function() {
                    return st.getClearAlpha()
                }, this.setClearAlpha = function() {
                    st.setClearAlpha.apply(st, arguments)
                }, this.clear = function(t = !0, e = !0, i = !0) {
                    let n = 0;
                    t && (n |= 16384), e && (n |= 256), i && (n |= 1024), ut.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", ft, !1), e.removeEventListener("webglcontextrestored", gt, !1), et.dispose(), it.dispose(), q.dispose(), Y.dispose(), J.dispose(), K.dispose(), ct.dispose(), $.dispose(), mt.dispose(), mt.removeEventListener("sessionstart", vt), mt.removeEventListener("sessionend", _t), O && (O.dispose(), O = null), bt.stop()
                }, this.renderBufferDirect = function(t, e, i, n, r, s) {
                    null === e && (e = F);
                    const a = r.isMesh && r.matrixWorld.determinant() < 0,
                        o = function(t, e, i, n, r) {
                            !0 !== e.isScene && (e = F);
                            X.resetTextureUnits();
                            const s = e.fog,
                                a = n.isMeshStandardMaterial ? e.environment : null,
                                o = null === v ? f.outputEncoding : !0 === v.isXRRenderTarget ? v.texture.encoding : wi,
                                l = (n.isMeshStandardMaterial ? J : Y).get(n.envMap || a),
                                h = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize,
                                c = !!n.normalMap && !!i.attributes.tangent,
                                u = !!i.morphAttributes.position,
                                p = !!i.morphAttributes.normal,
                                m = !!i.morphAttributes.color,
                                g = n.toneMapped ? f.toneMapping : 0,
                                y = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color,
                                x = void 0 !== y ? y.length : 0,
                                M = q.get(n),
                                w = d.state.lights;
                            if (!0 === I && (!0 === N || t !== b)) {
                                const e = t === b && n.id === _;
                                nt.setState(n, t, e)
                            }
                            let S = !1;
                            n.version === M.__version ? M.needsLights && M.lightsStateVersion !== w.state.version || M.outputEncoding !== o || r.isInstancedMesh && !1 === M.instancing ? S = !0 : r.isInstancedMesh || !0 !== M.instancing ? r.isSkinnedMesh && !1 === M.skinning ? S = !0 : r.isSkinnedMesh || !0 !== M.skinning ? M.envMap !== l || n.fog && M.fog !== s ? S = !0 : void 0 === M.numClippingPlanes || M.numClippingPlanes === nt.numPlanes && M.numIntersection === nt.numIntersection ? (M.vertexAlphas !== h || M.vertexTangents !== c || M.morphTargets !== u || M.morphNormals !== p || M.morphColors !== m || M.toneMapping !== g || !0 === G.isWebGL2 && M.morphTargetsCount !== x) && (S = !0) : S = !0 : S = !0 : S = !0 : (S = !0, M.__version = n.version);
                            let E = M.currentProgram;
                            !0 === S && (E = Tt(n, e, r));
                            let C = !1,
                                R = !1,
                                L = !1;
                            const P = E.getUniforms(),
                                z = M.uniforms;
                            W.useProgram(E.program) && (C = !0, R = !0, L = !0);
                            n.id !== _ && (_ = n.id, R = !0);
                            if (C || b !== t) {
                                if (P.setValue(ut, "projectionMatrix", t.projectionMatrix), G.logarithmicDepthBuffer && P.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, R = !0, L = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                                    const e = P.map.cameraPosition;
                                    void 0 !== e && e.setValue(ut, U.setFromMatrixPosition(t.matrixWorld))
                                }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && P.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && P.setValue(ut, "viewMatrix", t.matrixWorldInverse)
                            }
                            if (r.isSkinnedMesh) {
                                P.setOptional(ut, r, "bindMatrix"), P.setOptional(ut, r, "bindMatrixInverse");
                                const t = r.skeleton;
                                t && (G.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), P.setValue(ut, "boneTexture", t.boneTexture, X), P.setValue(ut, "boneTextureSize", t.boneTextureSize)) : P.setOptional(ut, t, "boneMatrices"))
                            }
                            const D = i.morphAttributes;
                            (void 0 !== D.position || void 0 !== D.normal || void 0 !== D.color && !0 === G.isWebGL2) && at.update(r, i, n, E);
                            (R || M.receiveShadow !== r.receiveShadow) && (M.receiveShadow = r.receiveShadow, P.setValue(ut, "receiveShadow", r.receiveShadow));
                            R && (P.setValue(ut, "toneMappingExposure", f.toneMappingExposure), M.needsLights && (H = L, (B = z).ambientLightColor.needsUpdate = H, B.lightProbe.needsUpdate = H, B.directionalLights.needsUpdate = H, B.directionalLightShadows.needsUpdate = H, B.pointLights.needsUpdate = H, B.pointLightShadows.needsUpdate = H, B.spotLights.needsUpdate = H, B.spotLightShadows.needsUpdate = H, B.rectAreaLights.needsUpdate = H, B.hemisphereLights.needsUpdate = H), s && n.fog && tt.refreshFogUniforms(z, s), tt.refreshMaterialUniforms(z, n, A, T, O), go.upload(ut, M.uniformsList, z, X));
                            var B, H;
                            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (go.upload(ut, M.uniformsList, z, X), n.uniformsNeedUpdate = !1);
                            n.isSpriteMaterial && P.setValue(ut, "center", r.center);
                            return P.setValue(ut, "modelViewMatrix", r.modelViewMatrix), P.setValue(ut, "normalMatrix", r.normalMatrix), P.setValue(ut, "modelMatrix", r.matrixWorld), E
                        }(t, e, i, n, r);
                    W.setMaterial(n, a);
                    let l = i.index;
                    const h = i.attributes.position;
                    if (null === l) {
                        if (void 0 === h || 0 === h.count) return
                    } else if (0 === l.count) return;
                    let c, u = 1;
                    !0 === n.wireframe && (l = Q.getWireframeAttribute(i), u = 2), ct.setup(r, n, o, i, l);
                    let p = ot;
                    null !== l && (c = Z.get(l), p = lt, p.setIndex(c));
                    const m = null !== l ? l.count : h.count,
                        g = i.drawRange.start * u,
                        y = i.drawRange.count * u,
                        x = null !== s ? s.start * u : 0,
                        M = null !== s ? s.count * u : 1 / 0,
                        w = Math.max(g, x),
                        S = Math.min(m, g + y, x + M) - 1,
                        E = Math.max(0, S - w + 1);
                    if (0 !== E) {
                        if (r.isMesh) !0 === n.wireframe ? (W.setLineWidth(n.wireframeLinewidth * k()), p.setMode(1)) : p.setMode(4);
                        else if (r.isLine) {
                            let t = n.linewidth;
                            void 0 === t && (t = 1), W.setLineWidth(t * k()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                        } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                        if (r.isInstancedMesh) p.renderInstances(w, E, r.count);
                        else if (i.isInstancedBufferGeometry) {
                            const t = Math.min(i.instanceCount, i._maxInstanceCount);
                            p.renderInstances(w, E, t)
                        } else p.render(w, E)
                    }
                }, this.compile = function(t, e) {
                    d = it.get(t), d.init(), m.push(d), t.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                    })), d.setupLights(f.physicallyCorrectLights), t.traverse((function(e) {
                        const i = e.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let n = 0; n < i.length; n++) {
                                    Tt(i[n], t, e)
                                } else Tt(i, t, e)
                    })), m.pop(), d = null
                };
                let xt = null;

                function vt() {
                    bt.stop()
                }

                function _t() {
                    bt.start()
                }
                const bt = new Rs;

                function Mt(t, e, i, n) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) i = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || D.intersectsSprite(t)) {
                            n && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                            const e = K.update(t),
                                r = t.material;
                            r.visible && u.push(t, e, r, i, U.z, null)
                        }
                    } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || D.intersectsObject(t))) {
                        n && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                        const e = K.update(t),
                            r = t.material;
                        if (Array.isArray(r)) {
                            const n = e.groups;
                            for (let s = 0, a = n.length; s < a; s++) {
                                const a = n[s],
                                    o = r[a.materialIndex];
                                o && o.visible && u.push(t, e, o, i, U.z, a)
                            }
                        } else r.visible && u.push(t, e, r, i, U.z, null)
                    }
                    const r = t.children;
                    for (let s = 0, a = r.length; s < a; s++) Mt(r[s], e, i, n)
                }

                function wt(t, e, i, n) {
                    const r = t.opaque,
                        a = t.transmissive,
                        o = t.transparent;
                    d.setupLightsView(i), a.length > 0 && function(t, e, i) {
                        const n = G.isWebGL2;
                        null === O && (O = new un(1, 1, {
                            generateMipmaps: !0,
                            type: null !== ht.convert(oi) ? oi : ni,
                            minFilter: ii,
                            samples: n && !0 === s ? 4 : 0
                        }));
                        f.getDrawingBufferSize(H), n ? O.setSize(H.x, H.y) : O.setSize(ki(H.x), ki(H.y));
                        const r = f.getRenderTarget();
                        f.setRenderTarget(O), f.clear();
                        const a = f.toneMapping;
                        f.toneMapping = 0, St(t, e, i), f.toneMapping = a, X.updateMultisampleRenderTarget(O), X.updateRenderTargetMipmap(O), f.setRenderTarget(r)
                    }(r, e, i), n && W.viewport(M.copy(n)), r.length > 0 && St(r, e, i), a.length > 0 && St(a, e, i), o.length > 0 && St(o, e, i), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1)
                }

                function St(t, e, i) {
                    const n = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r],
                            a = s.object,
                            o = s.geometry,
                            l = null === n ? s.material : n,
                            h = s.group;
                        a.layers.test(i.layers) && Et(a, e, i, o, l, h)
                    }
                }

                function Et(t, e, i, n, r, s) {
                    t.onBeforeRender(f, e, i, n, r, s), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(f, e, i, n, t, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, f.renderBufferDirect(i, e, n, r, t, s), r.side = 0, r.needsUpdate = !0, f.renderBufferDirect(i, e, n, r, t, s), r.side = 2) : f.renderBufferDirect(i, e, n, r, t, s), t.onAfterRender(f, e, i, n, r, s)
                }

                function Tt(t, e, i) {
                    !0 !== e.isScene && (e = F);
                    const n = q.get(t),
                        r = d.state.lights,
                        s = d.state.shadowsArray,
                        a = r.state.version,
                        o = $.getParameters(t, r.state, s, e, i),
                        l = $.getProgramCacheKey(o);
                    let h = n.programs;
                    n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (t.isMeshStandardMaterial ? J : Y).get(t.envMap || n.environment), void 0 === h && (t.addEventListener("dispose", yt), h = new Map, n.programs = h);
                    let c = h.get(l);
                    if (void 0 !== c) {
                        if (n.currentProgram === c && n.lightsStateVersion === a) return At(t, o), c
                    } else o.uniforms = $.getUniforms(t), t.onBuild(i, o, f), t.onBeforeCompile(o, f), c = $.acquireProgram(o, l), h.set(l, c), n.uniforms = o.uniforms;
                    const u = n.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = nt.uniform), At(t, o), n.needsLights = function(t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), n.lightsStateVersion = a, n.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const p = c.getUniforms(),
                        m = go.seqWithValue(p.seq, u);
                    return n.currentProgram = c, n.uniformsList = m, c
                }

                function At(t, e) {
                    const i = q.get(t);
                    i.outputEncoding = e.outputEncoding, i.instancing = e.instancing, i.skinning = e.skinning, i.morphTargets = e.morphTargets, i.morphNormals = e.morphNormals, i.morphColors = e.morphColors, i.morphTargetsCount = e.morphTargetsCount, i.numClippingPlanes = e.numClippingPlanes, i.numIntersection = e.numClipIntersection, i.vertexAlphas = e.vertexAlphas, i.vertexTangents = e.vertexTangents, i.toneMapping = e.toneMapping
                }
                bt.setAnimationLoop((function(t) {
                    xt && xt(t)
                })), "undefined" !== typeof self && bt.setContext(self), this.setAnimationLoop = function(t) {
                    xt = t, mt.setAnimationLoop(t), null === t ? bt.stop() : bt.start()
                }, mt.addEventListener("sessionstart", vt), mt.addEventListener("sessionend", _t), this.render = function(t, e) {
                    if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === g) return;
                    !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === mt.enabled && !0 === mt.isPresenting && (!0 === mt.cameraAutoUpdate && mt.updateCamera(e), e = mt.getCamera()), !0 === t.isScene && t.onBeforeRender(f, t, e, v), d = it.get(t, m.length), d.init(), m.push(d), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromProjectionMatrix(B), N = this.localClippingEnabled, I = nt.init(this.clippingPlanes, N, e), u = et.get(t, p.length), u.init(), p.push(u), Mt(t, e, 0, f.sortObjects), u.finish(), !0 === f.sortObjects && u.sort(C, R), !0 === I && nt.beginShadows();
                    const i = d.state.shadowsArray;
                    if (rt.render(i, t, e), !0 === I && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), st.render(u, t), d.setupLights(f.physicallyCorrectLights), e.isArrayCamera) {
                        const i = e.cameras;
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            wt(u, t, n, n.viewport)
                        }
                    } else wt(u, t, e);
                    null !== v && (X.updateMultisampleRenderTarget(v), X.updateRenderTargetMipmap(v)), !0 === t.isScene && t.onAfterRender(f, t, e), ct.resetDefaultState(), _ = -1, b = null, m.pop(), d = m.length > 0 ? m[m.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return y
                }, this.getActiveMipmapLevel = function() {
                    return x
                }, this.getRenderTarget = function() {
                    return v
                }, this.setRenderTargetTextures = function(t, e, i) {
                    q.get(t.texture).__webglTexture = e, q.get(t.depthTexture).__webglTexture = i;
                    const n = q.get(t);
                    n.__hasExternalTextures = !0, n.__hasExternalTextures && (n.__autoAllocateDepthBuffer = void 0 === i, n.__autoAllocateDepthBuffer || !0 === V.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function(t, e) {
                    const i = q.get(t);
                    i.__webglFramebuffer = e, i.__useDefaultFramebuffer = void 0 === e
                }, this.setRenderTarget = function(t, e = 0, i = 0) {
                    v = t, y = e, x = i;
                    let n = !0;
                    if (t) {
                        const e = q.get(t);
                        void 0 !== e.__useDefaultFramebuffer ? (W.bindFramebuffer(36160, null), n = !1) : void 0 === e.__webglFramebuffer ? X.setupRenderTarget(t) : e.__hasExternalTextures && X.rebindTextures(t, q.get(t.texture).__webglTexture, q.get(t.depthTexture).__webglTexture)
                    }
                    let r = null,
                        s = !1,
                        a = !1;
                    if (t) {
                        const i = t.texture;
                        (i.isData3DTexture || i.isDataArrayTexture) && (a = !0);
                        const n = q.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (r = n[e], s = !0) : r = G.isWebGL2 && t.samples > 0 && !1 === X.useMultisampledRTT(t) ? q.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), w.copy(t.scissor), S = t.scissorTest
                    } else M.copy(L).multiplyScalar(A).floor(), w.copy(P).multiplyScalar(A).floor(), S = z;
                    if (W.bindFramebuffer(36160, r) && G.drawBuffers && n && W.drawBuffers(t, r), W.viewport(M), W.scissor(w), W.setScissorTest(S), s) {
                        const n = q.get(t.texture);
                        ut.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i)
                    } else if (a) {
                        const n = q.get(t.texture),
                            r = e || 0;
                        ut.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r)
                    }
                    _ = -1
                }, this.readRenderTargetPixels = function(t, e, i, n, r, s, a) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = q.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                        W.bindFramebuffer(36160, o);
                        try {
                            const a = t.texture,
                                o = a.format,
                                l = a.type;
                            if (o !== hi && ht.convert(o) !== ut.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const h = l === oi && (V.has("EXT_color_buffer_half_float") || G.isWebGL2 && V.has("EXT_color_buffer_float"));
                            if (l !== ni && ht.convert(l) !== ut.getParameter(35738) && (l !== ai || !(G.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float"))) && !h) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && ut.readPixels(e, i, n, r, ht.convert(o), ht.convert(l), s)
                        } finally {
                            const t = null !== v ? q.get(v).__webglFramebuffer : null;
                            W.bindFramebuffer(36160, t)
                        }
                    }
                }, this.copyFramebufferToTexture = function(t, e, i = 0) {
                    if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                    const n = Math.pow(2, -i),
                        r = Math.floor(e.image.width * n),
                        s = Math.floor(e.image.height * n);
                    X.setTexture2D(e, 0), ut.copyTexSubImage2D(3553, i, 0, 0, t.x, t.y, r, s), W.unbindTexture()
                }, this.copyTextureToTexture = function(t, e, i, n = 0) {
                    const r = e.image.width,
                        s = e.image.height,
                        a = ht.convert(i.format),
                        o = ht.convert(i.type);
                    X.setTexture2D(i, 0), ut.pixelStorei(37440, i.flipY), ut.pixelStorei(37441, i.premultiplyAlpha), ut.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? ut.texSubImage2D(3553, n, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : ut.texSubImage2D(3553, n, t.x, t.y, a, o, e.image), 0 === n && i.generateMipmaps && ut.generateMipmap(3553), W.unbindTexture()
                }, this.copyTextureToTexture3D = function(t, e, i, n, r = 0) {
                    if (f.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const s = t.max.x - t.min.x + 1,
                        a = t.max.y - t.min.y + 1,
                        o = t.max.z - t.min.z + 1,
                        l = ht.convert(n.format),
                        h = ht.convert(n.type);
                    let c;
                    if (n.isData3DTexture) X.setTexture3D(n, 0), c = 32879;
                    else {
                        if (!n.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        X.setTexture2DArray(n, 0), c = 35866
                    }
                    ut.pixelStorei(37440, n.flipY), ut.pixelStorei(37441, n.premultiplyAlpha), ut.pixelStorei(3317, n.unpackAlignment);
                    const u = ut.getParameter(3314),
                        d = ut.getParameter(32878),
                        p = ut.getParameter(3316),
                        m = ut.getParameter(3315),
                        g = ut.getParameter(32877),
                        y = i.isCompressedTexture ? i.mipmaps[0] : i.image;
                    ut.pixelStorei(3314, y.width), ut.pixelStorei(32878, y.height), ut.pixelStorei(3316, t.min.x), ut.pixelStorei(3315, t.min.y), ut.pixelStorei(32877, t.min.z), i.isDataTexture || i.isData3DTexture ? ut.texSubImage3D(c, r, e.x, e.y, e.z, s, a, o, l, h, y.data) : i.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ut.compressedTexSubImage3D(c, r, e.x, e.y, e.z, s, a, o, l, y.data)) : ut.texSubImage3D(c, r, e.x, e.y, e.z, s, a, o, l, h, y), ut.pixelStorei(3314, u), ut.pixelStorei(32878, d), ut.pixelStorei(3316, p), ut.pixelStorei(3315, m), ut.pixelStorei(32877, g), 0 === r && n.generateMipmaps && ut.generateMipmap(c), W.unbindTexture()
                }, this.initTexture = function(t) {
                    X.setTexture2D(t, 0), W.unbindTexture()
                }, this.resetState = function() {
                    y = 0, x = 0, v = null, W.reset(), ct.reset()
                }, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            hl.prototype.isWebGLRenderer = !0;
            (class extends hl {}).prototype.isWebGL1Renderer = !0;
            class cl {
                constructor(t, e = 25e-5) {
                    this.name = "", this.color = new nn(t), this.density = e
                }
                clone() {
                    return new cl(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            cl.prototype.isFogExp2 = !0;
            class ul {
                constructor(t, e = 1, i = 1e3) {
                    this.name = "", this.color = new nn(t), this.near = e, this.far = i
                }
                clone() {
                    return new ul(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            ul.prototype.isFog = !0;
            class dl extends yr {
                constructor() {
                    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(t, e) {
                    return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }
            dl.prototype.isScene = !0;
            class pl {
                constructor(t, e) {
                    this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Ci, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = Oi()
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                copy(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                }
                copyAt(t, e, i) {
                    t *= this.stride, i *= e.stride;
                    for (let n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                clone(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Oi()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                        i = new this.constructor(e, this.stride);
                    return i.setUsage(this.usage), i
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                toJSON(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Oi()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            pl.prototype.isInterleavedBuffer = !0;
            const ml = new fn;
            class fl {
                constructor(t, e, i, n = !1) {
                    this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(t) {
                    this.data.needsUpdate = t
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.data.count; e < i; e++) ml.fromBufferAttribute(this, e), ml.applyMatrix4(t), this.setXYZ(e, ml.x, ml.y, ml.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) ml.fromBufferAttribute(this, e), ml.applyNormalMatrix(t), this.setXYZ(e, ml.x, ml.y, ml.z);
                    return this
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) ml.fromBufferAttribute(this, e), ml.transformDirection(t), this.setXYZ(e, ml.x, ml.y, ml.z);
                    return this
                }
                setX(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                }
                setY(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                }
                setZ(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                }
                setW(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                }
                getX(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                }
                getY(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                }
                getZ(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                }
                getW(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                }
                setXY(t, e, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
                }
                setXYZ(t, e, i, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
                }
                setXYZW(t, e, i, n, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
                }
                clone(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const i = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
                        }
                        return new Ir(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new fl(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                }
                toJSON(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const i = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            fl.prototype.isInterleavedBufferAttribute = !0;
            class gl extends Lr {
                constructor(t) {
                    super(), this.type = "SpriteMaterial", this.color = new nn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                }
            }
            let yl;
            gl.prototype.isSpriteMaterial = !0;
            const xl = new fn,
                vl = new fn,
                _l = new fn,
                bl = new Vi,
                Ml = new Vi,
                wl = new qn,
                Sl = new fn,
                El = new fn,
                Tl = new fn,
                Al = new Vi,
                Cl = new Vi,
                Rl = new Vi;
            class Ll extends yr {
                constructor(t) {
                    if (super(), this.type = "Sprite", void 0 === yl) {
                        yl = new jr;
                        const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                            e = new pl(t, 5);
                        yl.setIndex([0, 1, 2, 0, 2, 3]), yl.setAttribute("position", new fl(e, 3, 0, !1)), yl.setAttribute("uv", new fl(e, 2, 3, !1))
                    }
                    this.geometry = yl, this.material = void 0 !== t ? t : new gl, this.center = new Vi(.5, .5)
                }
                raycast(t, e) {
                    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), vl.setFromMatrixScale(this.matrixWorld), wl.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), _l.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && vl.multiplyScalar(-_l.z);
                    const i = this.material.rotation;
                    let n, r;
                    0 !== i && (r = Math.cos(i), n = Math.sin(i));
                    const s = this.center;
                    Pl(Sl.set(-.5, -.5, 0), _l, s, vl, n, r), Pl(El.set(.5, -.5, 0), _l, s, vl, n, r), Pl(Tl.set(.5, .5, 0), _l, s, vl, n, r), Al.set(0, 0), Cl.set(1, 0), Rl.set(1, 1);
                    let a = t.ray.intersectTriangle(Sl, El, Tl, !1, xl);
                    if (null === a && (Pl(El.set(-.5, .5, 0), _l, s, vl, n, r), Cl.set(0, 1), a = t.ray.intersectTriangle(Sl, Tl, El, !1, xl), null === a)) return;
                    const o = t.ray.origin.distanceTo(xl);
                    o < t.near || o > t.far || e.push({
                        distance: o,
                        point: xl.clone(),
                        uv: Cr.getUV(xl, Sl, El, Tl, Al, Cl, Rl, new Vi),
                        face: null,
                        object: this
                    })
                }
                copy(t) {
                    return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                }
            }

            function Pl(t, e, i, n, r, s) {
                bl.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (Ml.x = s * bl.x - r * bl.y, Ml.y = r * bl.x + s * bl.y) : Ml.copy(bl), t.copy(e), t.x += Ml.x, t.y += Ml.y, t.applyMatrix4(wl)
            }
            Ll.prototype.isSprite = !0;
            const zl = new fn,
                Dl = new cn,
                Il = new cn,
                Nl = new fn,
                Ol = new qn;
            class Bl extends hs {
                constructor(t, e) {
                    super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new qn, this.bindMatrixInverse = new qn
                }
                copy(t) {
                    return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                }
                bind(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const t = new cn,
                        e = this.geometry.attributes.skinWeight;
                    for (let i = 0, n = e.count; i < n; i++) {
                        t.fromBufferAttribute(e, i);
                        const n = 1 / t.manhattanLength();
                        n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                    }
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(t, e) {
                    const i = this.skeleton,
                        n = this.geometry;
                    Dl.fromBufferAttribute(n.attributes.skinIndex, t), Il.fromBufferAttribute(n.attributes.skinWeight, t), zl.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                    for (let r = 0; r < 4; r++) {
                        const t = Il.getComponent(r);
                        if (0 !== t) {
                            const n = Dl.getComponent(r);
                            Ol.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]), e.addScaledVector(Nl.copy(zl).applyMatrix4(Ol), t)
                        }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse)
                }
            }
            Bl.prototype.isSkinnedMesh = !0;
            class Hl extends yr {
                constructor() {
                    super(), this.type = "Bone"
                }
            }
            Hl.prototype.isBone = !0;
            class Ul extends hn {
                constructor(t = null, e = 1, i = 1, n, r, s, a, o, l = 1003, h = 1003, c, u) {
                    super(null, s, a, o, l, h, n, r, c, u), this.image = {
                        data: t,
                        width: e,
                        height: i
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            Ul.prototype.isDataTexture = !0;
            class Fl extends Ir {
                constructor(t, e, i, n = 1) {
                    "number" === typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, i), this.meshPerAttribute = n
                }
                copy(t) {
                    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }
            Fl.prototype.isInstancedBufferAttribute = !0;
            const kl = new qn,
                Vl = new qn,
                Gl = [],
                Wl = new hs;
            class jl extends hs {
                constructor(t, e, i) {
                    super(t, e), this.instanceMatrix = new Fl(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1
                }
                copy(t) {
                    return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                }
                getColorAt(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t)
                }
                getMatrixAt(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                }
                raycast(t, e) {
                    const i = this.matrixWorld,
                        n = this.count;
                    if (Wl.geometry = this.geometry, Wl.material = this.material, void 0 !== Wl.material)
                        for (let r = 0; r < n; r++) {
                            this.getMatrixAt(r, kl), Vl.multiplyMatrices(i, kl), Wl.matrixWorld = Vl, Wl.raycast(t, Gl);
                            for (let t = 0, i = Gl.length; t < i; t++) {
                                const i = Gl[t];
                                i.instanceId = r, i.object = this, e.push(i)
                            }
                            Gl.length = 0
                        }
                }
                setColorAt(t, e) {
                    null === this.instanceColor && (this.instanceColor = new Fl(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                }
                setMatrixAt(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            jl.prototype.isInstancedMesh = !0;
            class ql extends Lr {
                constructor(t) {
                    super(), this.type = "LineBasicMaterial", this.color = new nn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
                }
            }
            ql.prototype.isLineBasicMaterial = !0;
            const Xl = new fn,
                Yl = new fn,
                Jl = new qn,
                Zl = new jn,
                Ql = new Bn;
            class Kl extends yr {
                constructor(t = new jr, e = new ql) {
                    super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(t) {
                    return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                i = [0];
                            for (let t = 1, n = e.count; t < n; t++) Xl.fromBufferAttribute(e, t - 1), Yl.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += Xl.distanceTo(Yl);
                            t.setAttribute("lineDistance", new Br(i, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.matrixWorld,
                        r = t.params.Line.threshold,
                        s = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), Ql.copy(i.boundingSphere), Ql.applyMatrix4(n), Ql.radius += r, !1 === t.ray.intersectsSphere(Ql)) return;
                    Jl.copy(n).invert(), Zl.copy(t.ray).applyMatrix4(Jl);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        l = new fn,
                        h = new fn,
                        c = new fn,
                        u = new fn,
                        d = this.isLineSegments ? 2 : 1;
                    if (i.isBufferGeometry) {
                        const n = i.index,
                            r = i.attributes.position;
                        if (null !== n) {
                            for (let i = Math.max(0, s.start), a = Math.min(n.count, s.start + s.count) - 1; i < a; i += d) {
                                const s = n.getX(i),
                                    a = n.getX(i + 1);
                                l.fromBufferAttribute(r, s), h.fromBufferAttribute(r, a);
                                if (Zl.distanceSqToSegment(l, h, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const d = t.ray.origin.distanceTo(u);
                                d < t.near || d > t.far || e.push({
                                    distance: d,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else {
                            for (let i = Math.max(0, s.start), n = Math.min(r.count, s.start + s.count) - 1; i < n; i += d) {
                                l.fromBufferAttribute(r, i), h.fromBufferAttribute(r, i + 1);
                                if (Zl.distanceSqToSegment(l, h, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const n = t.ray.origin.distanceTo(u);
                                n < t.near || n > t.far || e.push({
                                    distance: n,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }
            Kl.prototype.isLine = !0;
            const $l = new fn,
                th = new fn;
            class eh extends Kl {
                constructor(t, e) {
                    super(t, e), this.type = "LineSegments"
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                i = [];
                            for (let t = 0, n = e.count; t < n; t += 2) $l.fromBufferAttribute(e, t), th.fromBufferAttribute(e, t + 1), i[t] = 0 === t ? 0 : i[t - 1], i[t + 1] = i[t] + $l.distanceTo(th);
                            t.setAttribute("lineDistance", new Br(i, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
            }
            eh.prototype.isLineSegments = !0;
            class ih extends Kl {
                constructor(t, e) {
                    super(t, e), this.type = "LineLoop"
                }
            }
            ih.prototype.isLineLoop = !0;
            class nh extends Lr {
                constructor(t) {
                    super(), this.type = "PointsMaterial", this.color = new nn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
                }
            }
            nh.prototype.isPointsMaterial = !0;
            const rh = new qn,
                sh = new jn,
                ah = new Bn,
                oh = new fn;
            class lh extends yr {
                constructor(t = new jr, e = new nh) {
                    super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(t) {
                    return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.matrixWorld,
                        r = t.params.Points.threshold,
                        s = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), ah.copy(i.boundingSphere), ah.applyMatrix4(n), ah.radius += r, !1 === t.ray.intersectsSphere(ah)) return;
                    rh.copy(n).invert(), sh.copy(t.ray).applyMatrix4(rh);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a;
                    if (i.isBufferGeometry) {
                        const r = i.index,
                            a = i.attributes.position;
                        if (null !== r) {
                            for (let i = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); i < l; i++) {
                                const s = r.getX(i);
                                oh.fromBufferAttribute(a, s), hh(oh, s, o, n, t, e, this)
                            }
                        } else {
                            for (let i = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); i < r; i++) oh.fromBufferAttribute(a, i), hh(oh, i, o, n, t, e, this)
                        }
                    } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }

            function hh(t, e, i, n, r, s, a) {
                const o = sh.distanceSqToPoint(t);
                if (o < i) {
                    const i = new fn;
                    sh.closestPointToPoint(t, i), i.applyMatrix4(n);
                    const l = r.ray.origin.distanceTo(i);
                    if (l < r.near || l > r.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(o),
                        point: i,
                        index: e,
                        face: null,
                        object: a
                    })
                }
            }
            lh.prototype.isPoints = !0;
            (class extends hn {
                constructor(t, e, i, n, r, s, a, o, l) {
                    super(t, e, i, n, r, s, a, o, l), this.minFilter = void 0 !== s ? s : ti, this.magFilter = void 0 !== r ? r : ti, this.generateMipmaps = !1;
                    const h = this;
                    "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                        h.needsUpdate = !0, t.requestVideoFrameCallback(e)
                    }))
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    const t = this.image;
                    !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }).prototype.isVideoTexture = !0;
            (class extends hn {
                constructor(t, e, i) {
                    super({
                        width: t,
                        height: e
                    }), this.format = i, this.magFilter = Qe, this.minFilter = Qe, this.generateMipmaps = !1, this.needsUpdate = !0
                }
            }).prototype.isFramebufferTexture = !0;
            class ch extends hn {
                constructor(t, e, i, n, r, s, a, o, l, h, c, u) {
                    super(null, s, a, o, l, h, n, r, c, u), this.image = {
                        width: e,
                        height: i
                    }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            ch.prototype.isCompressedTexture = !0;
            (class extends hn {
                constructor(t, e, i, n, r, s, a, o, l) {
                    super(t, e, i, n, r, s, a, o, l), this.needsUpdate = !0
                }
            }).prototype.isCanvasTexture = !0;
            class uh {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(t, e) {
                    const i = this.getUtoTmapping(t);
                    return this.getPoint(i, e)
                }
                getPoints(t = 5) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return e
                }
                getSpacedPoints(t = 5) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                    return e
                }
                getLength() {
                    const t = this.getLengths();
                    return t[t.length - 1]
                }
                getLengths(t = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let i, n = this.getPoint(0),
                        r = 0;
                    e.push(0);
                    for (let s = 1; s <= t; s++) i = this.getPoint(s / t), r += i.distanceTo(n), e.push(r), n = i;
                    return this.cacheArcLengths = e, e
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(t, e) {
                    const i = this.getLengths();
                    let n = 0;
                    const r = i.length;
                    let s;
                    s = e || t * i[r - 1];
                    let a, o = 0,
                        l = r - 1;
                    for (; o <= l;)
                        if (n = Math.floor(o + (l - o) / 2), a = i[n] - s, a < 0) o = n + 1;
                        else {
                            if (!(a > 0)) {
                                l = n;
                                break
                            }
                            l = n - 1
                        }
                    if (n = l, i[n] === s) return n / (r - 1);
                    const h = i[n];
                    return (n + (s - h) / (i[n + 1] - h)) / (r - 1)
                }
                getTangent(t, e) {
                    const i = 1e-4;
                    let n = t - i,
                        r = t + i;
                    n < 0 && (n = 0), r > 1 && (r = 1);
                    const s = this.getPoint(n),
                        a = this.getPoint(r),
                        o = e || (s.isVector2 ? new Vi : new fn);
                    return o.copy(a).sub(s).normalize(), o
                }
                getTangentAt(t, e) {
                    const i = this.getUtoTmapping(t);
                    return this.getTangent(i, e)
                }
                computeFrenetFrames(t, e) {
                    const i = new fn,
                        n = [],
                        r = [],
                        s = [],
                        a = new fn,
                        o = new qn;
                    for (let d = 0; d <= t; d++) {
                        const e = d / t;
                        n[d] = this.getTangentAt(e, new fn)
                    }
                    r[0] = new fn, s[0] = new fn;
                    let l = Number.MAX_VALUE;
                    const h = Math.abs(n[0].x),
                        c = Math.abs(n[0].y),
                        u = Math.abs(n[0].z);
                    h <= l && (l = h, i.set(1, 0, 0)), c <= l && (l = c, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), s[0].crossVectors(n[0], r[0]);
                    for (let d = 1; d <= t; d++) {
                        if (r[d] = r[d - 1].clone(), s[d] = s[d - 1].clone(), a.crossVectors(n[d - 1], n[d]), a.length() > Number.EPSILON) {
                            a.normalize();
                            const t = Math.acos(Bi(n[d - 1].dot(n[d]), -1, 1));
                            r[d].applyMatrix4(o.makeRotationAxis(a, t))
                        }
                        s[d].crossVectors(n[d], r[d])
                    }
                    if (!0 === e) {
                        let e = Math.acos(Bi(r[0].dot(r[t]), -1, 1));
                        e /= t, n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                        for (let i = 1; i <= t; i++) r[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)), s[i].crossVectors(n[i], r[i])
                    }
                    return {
                        tangents: n,
                        normals: r,
                        binormals: s
                    }
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
                toJSON() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                }
                fromJSON(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }
            class dh extends uh {
                constructor(t = 0, e = 0, i = 1, n = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                    super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                }
                getPoint(t, e) {
                    const i = e || new Vi,
                        n = 2 * Math.PI;
                    let r = this.aEndAngle - this.aStartAngle;
                    const s = Math.abs(r) < Number.EPSILON;
                    for (; r < 0;) r += n;
                    for (; r > n;) r -= n;
                    r < Number.EPSILON && (r = s ? 0 : n), !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
                    const a = this.aStartAngle + t * r;
                    let o = this.aX + this.xRadius * Math.cos(a),
                        l = this.aY + this.yRadius * Math.sin(a);
                    if (0 !== this.aRotation) {
                        const t = Math.cos(this.aRotation),
                            e = Math.sin(this.aRotation),
                            i = o - this.aX,
                            n = l - this.aY;
                        o = i * t - n * e + this.aX, l = i * e + n * t + this.aY
                    }
                    return i.set(o, l)
                }
                copy(t) {
                    return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
            }
            dh.prototype.isEllipseCurve = !0;
            class ph extends dh {
                constructor(t, e, i, n, r, s) {
                    super(t, e, i, i, n, r, s), this.type = "ArcCurve"
                }
            }

            function mh() {
                let t = 0,
                    e = 0,
                    i = 0,
                    n = 0;

                function r(r, s, a, o) {
                    t = r, e = a, i = -3 * r + 3 * s - 2 * a - o, n = 2 * r - 2 * s + a + o
                }
                return {
                    initCatmullRom: function(t, e, i, n, s) {
                        r(e, i, s * (i - t), s * (n - e))
                    },
                    initNonuniformCatmullRom: function(t, e, i, n, s, a, o) {
                        let l = (e - t) / s - (i - t) / (s + a) + (i - e) / a,
                            h = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                        l *= a, h *= a, r(e, i, l, h)
                    },
                    calc: function(r) {
                        const s = r * r;
                        return t + e * r + i * s + n * (s * r)
                    }
                }
            }
            ph.prototype.isArcCurve = !0;
            const fh = new fn,
                gh = new mh,
                yh = new mh,
                xh = new mh;
            class vh extends uh {
                constructor(t = [], e = !1, i = "centripetal", n = .5) {
                    super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n
                }
                getPoint(t, e = new fn) {
                    const i = e,
                        n = this.points,
                        r = n.length,
                        s = (r - (this.closed ? 0 : 1)) * t;
                    let a, o, l = Math.floor(s),
                        h = s - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2, h = 1), this.closed || l > 0 ? a = n[(l - 1) % r] : (fh.subVectors(n[0], n[1]).add(n[0]), a = fh);
                    const c = n[l % r],
                        u = n[(l + 1) % r];
                    if (this.closed || l + 2 < r ? o = n[(l + 2) % r] : (fh.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), o = fh), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const t = "chordal" === this.curveType ? .5 : .25;
                        let e = Math.pow(a.distanceToSquared(c), t),
                            i = Math.pow(c.distanceToSquared(u), t),
                            n = Math.pow(u.distanceToSquared(o), t);
                        i < 1e-4 && (i = 1), e < 1e-4 && (e = i), n < 1e-4 && (n = i), gh.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, e, i, n), yh.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, e, i, n), xh.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, e, i, n)
                    } else "catmullrom" === this.curveType && (gh.initCatmullRom(a.x, c.x, u.x, o.x, this.tension), yh.initCatmullRom(a.y, c.y, u.y, o.y, this.tension), xh.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
                    return i.set(gh.calc(h), yh.calc(h), xh.calc(h)), i
                }
                copy(t) {
                    super.copy(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push(i.clone())
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, i = this.points.length; e < i; e++) {
                        const i = this.points[e];
                        t.points.push(i.toArray())
                    }
                    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push((new fn).fromArray(i))
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
            }

            function _h(t, e, i, n, r) {
                const s = .5 * (n - e),
                    a = .5 * (r - i),
                    o = t * t;
                return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
            }

            function bh(t, e, i, n) {
                return function(t, e) {
                    const i = 1 - t;
                    return i * i * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, i) + function(t, e) {
                    return t * t * e
                }(t, n)
            }

            function Mh(t, e, i, n, r) {
                return function(t, e) {
                    const i = 1 - t;
                    return i * i * i * e
                }(t, e) + function(t, e) {
                    const i = 1 - t;
                    return 3 * i * i * t * e
                }(t, i) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, n) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }
            vh.prototype.isCatmullRomCurve3 = !0;
            class wh extends uh {
                constructor(t = new Vi, e = new Vi, i = new Vi, n = new Vi) {
                    super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
                }
                getPoint(t, e = new Vi) {
                    const i = e,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2,
                        a = this.v3;
                    return i.set(Mh(t, n.x, r.x, s.x, a.x), Mh(t, n.y, r.y, s.y, a.y)), i
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            wh.prototype.isCubicBezierCurve = !0;
            class Sh extends uh {
                constructor(t = new fn, e = new fn, i = new fn, n = new fn) {
                    super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
                }
                getPoint(t, e = new fn) {
                    const i = e,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2,
                        a = this.v3;
                    return i.set(Mh(t, n.x, r.x, s.x, a.x), Mh(t, n.y, r.y, s.y, a.y), Mh(t, n.z, r.z, s.z, a.z)), i
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            Sh.prototype.isCubicBezierCurve3 = !0;
            class Eh extends uh {
                constructor(t = new Vi, e = new Vi) {
                    super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new Vi) {
                    const i = e;
                    return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                getTangent(t, e) {
                    const i = e || new Vi;
                    return i.copy(this.v2).sub(this.v1).normalize(), i
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Eh.prototype.isLineCurve = !0;
            class Th extends uh {
                constructor(t = new Vi, e = new Vi, i = new Vi) {
                    super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i
                }
                getPoint(t, e = new Vi) {
                    const i = e,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return i.set(bh(t, n.x, r.x, s.x), bh(t, n.y, r.y, s.y)), i
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Th.prototype.isQuadraticBezierCurve = !0;
            class Ah extends uh {
                constructor(t = new fn, e = new fn, i = new fn) {
                    super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i
                }
                getPoint(t, e = new fn) {
                    const i = e,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return i.set(bh(t, n.x, r.x, s.x), bh(t, n.y, r.y, s.y), bh(t, n.z, r.z, s.z)), i
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Ah.prototype.isQuadraticBezierCurve3 = !0;
            class Ch extends uh {
                constructor(t = []) {
                    super(), this.type = "SplineCurve", this.points = t
                }
                getPoint(t, e = new Vi) {
                    const i = e,
                        n = this.points,
                        r = (n.length - 1) * t,
                        s = Math.floor(r),
                        a = r - s,
                        o = n[0 === s ? s : s - 1],
                        l = n[s],
                        h = n[s > n.length - 2 ? n.length - 1 : s + 1],
                        c = n[s > n.length - 3 ? n.length - 1 : s + 2];
                    return i.set(_h(a, o.x, l.x, h.x, c.x), _h(a, o.y, l.y, h.y, c.y)), i
                }
                copy(t) {
                    super.copy(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push(i.clone())
                    }
                    return this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, i = this.points.length; e < i; e++) {
                        const i = this.points[e];
                        t.points.push(i.toArray())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push((new Vi).fromArray(i))
                    }
                    return this
                }
            }
            Ch.prototype.isSplineCurve = !0;
            var Rh = Object.freeze({
                __proto__: null,
                ArcCurve: ph,
                CatmullRomCurve3: vh,
                CubicBezierCurve: wh,
                CubicBezierCurve3: Sh,
                EllipseCurve: dh,
                LineCurve: Eh,
                LineCurve3: class extends uh {
                    constructor(t = new fn, e = new fn) {
                        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                    }
                    getPoint(t, e = new fn) {
                        const i = e;
                        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                },
                QuadraticBezierCurve: Th,
                QuadraticBezierCurve3: Ah,
                SplineCurve: Ch
            });
            class Lh extends uh {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(t) {
                    this.curves.push(t)
                }
                closePath() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Eh(e, t))
                }
                getPoint(t, e) {
                    const i = t * this.getLength(),
                        n = this.getCurveLengths();
                    let r = 0;
                    for (; r < n.length;) {
                        if (n[r] >= i) {
                            const t = n[r] - i,
                                s = this.curves[r],
                                a = s.getLength(),
                                o = 0 === a ? 0 : 1 - t / a;
                            return s.getPointAt(o, e)
                        }
                        r++
                    }
                    return null
                }
                getLength() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                }
                getSpacedPoints(t = 40) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e
                }
                getPoints(t = 12) {
                    const e = [];
                    let i;
                    for (let n = 0, r = this.curves; n < r.length; n++) {
                        const s = r[n],
                            a = s.isEllipseCurve ? 2 * t : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? t * s.points.length : t,
                            o = s.getPoints(a);
                        for (let t = 0; t < o.length; t++) {
                            const n = o[t];
                            i && i.equals(n) || (e.push(n), i = n)
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                }
                copy(t) {
                    super.copy(t), this.curves = [];
                    for (let e = 0, i = t.curves.length; e < i; e++) {
                        const i = t.curves[e];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = t.autoClose, this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.autoClose = this.autoClose, t.curves = [];
                    for (let e = 0, i = this.curves.length; e < i; e++) {
                        const i = this.curves[e];
                        t.curves.push(i.toJSON())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                    for (let e = 0, i = t.curves.length; e < i; e++) {
                        const i = t.curves[e];
                        this.curves.push((new Rh[i.type]).fromJSON(i))
                    }
                    return this
                }
            }
            class Ph extends Lh {
                constructor(t) {
                    super(), this.type = "Path", this.currentPoint = new Vi, t && this.setFromPoints(t)
                }
                setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                    return this
                }
                moveTo(t, e) {
                    return this.currentPoint.set(t, e), this
                }
                lineTo(t, e) {
                    const i = new Eh(this.currentPoint.clone(), new Vi(t, e));
                    return this.curves.push(i), this.currentPoint.set(t, e), this
                }
                quadraticCurveTo(t, e, i, n) {
                    const r = new Th(this.currentPoint.clone(), new Vi(t, e), new Vi(i, n));
                    return this.curves.push(r), this.currentPoint.set(i, n), this
                }
                bezierCurveTo(t, e, i, n, r, s) {
                    const a = new wh(this.currentPoint.clone(), new Vi(t, e), new Vi(i, n), new Vi(r, s));
                    return this.curves.push(a), this.currentPoint.set(r, s), this
                }
                splineThru(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                        i = new Ch(e);
                    return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
                }
                arc(t, e, i, n, r, s) {
                    const a = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(t + a, e + o, i, n, r, s), this
                }
                absarc(t, e, i, n, r, s) {
                    return this.absellipse(t, e, i, i, n, r, s), this
                }
                ellipse(t, e, i, n, r, s, a, o) {
                    const l = this.currentPoint.x,
                        h = this.currentPoint.y;
                    return this.absellipse(t + l, e + h, i, n, r, s, a, o), this
                }
                absellipse(t, e, i, n, r, s, a, o) {
                    const l = new dh(t, e, i, n, r, s, a, o);
                    if (this.curves.length > 0) {
                        const t = l.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                    }
                    this.curves.push(l);
                    const h = l.getPoint(1);
                    return this.currentPoint.copy(h), this
                }
                copy(t) {
                    return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.currentPoint = this.currentPoint.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }
            class zh extends jr {
                constructor(t = [], e = [], i = 1, n = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: t,
                        indices: e,
                        radius: i,
                        detail: n
                    };
                    const r = [],
                        s = [];

                    function a(t, e, i, n) {
                        const r = n + 1,
                            s = [];
                        for (let a = 0; a <= r; a++) {
                            s[a] = [];
                            const n = t.clone().lerp(i, a / r),
                                o = e.clone().lerp(i, a / r),
                                l = r - a;
                            for (let t = 0; t <= l; t++) s[a][t] = 0 === t && a === r ? n : n.clone().lerp(o, t / l)
                        }
                        for (let a = 0; a < r; a++)
                            for (let t = 0; t < 2 * (r - a) - 1; t++) {
                                const e = Math.floor(t / 2);
                                t % 2 === 0 ? (o(s[a][e + 1]), o(s[a + 1][e]), o(s[a][e])) : (o(s[a][e + 1]), o(s[a + 1][e + 1]), o(s[a + 1][e]))
                            }
                    }

                    function o(t) {
                        r.push(t.x, t.y, t.z)
                    }

                    function l(e, i) {
                        const n = 3 * e;
                        i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
                    }

                    function h(t, e, i, n) {
                        n < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === i.x && 0 === i.z && (s[e] = n / 2 / Math.PI + .5)
                    }

                    function c(t) {
                        return Math.atan2(t.z, -t.x)
                    }! function(t) {
                        const i = new fn,
                            n = new fn,
                            r = new fn;
                        for (let s = 0; s < e.length; s += 3) l(e[s + 0], i), l(e[s + 1], n), l(e[s + 2], r), a(i, n, r, t)
                    }(n),
                    function(t) {
                        const e = new fn;
                        for (let i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
                    }(i),
                    function() {
                        const t = new fn;
                        for (let i = 0; i < r.length; i += 3) {
                            t.x = r[i + 0], t.y = r[i + 1], t.z = r[i + 2];
                            const n = c(t) / 2 / Math.PI + .5,
                                a = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                            s.push(n, 1 - a)
                        }
                        var e;
                        (function() {
                            const t = new fn,
                                e = new fn,
                                i = new fn,
                                n = new fn,
                                a = new Vi,
                                o = new Vi,
                                l = new Vi;
                            for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[u + 6], r[u + 7], r[u + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                                const p = c(n);
                                h(a, d + 0, t, p), h(o, d + 2, e, p), h(l, d + 4, i, p)
                            }
                        })(),
                        function() {
                            for (let t = 0; t < s.length; t += 6) {
                                const e = s[t + 0],
                                    i = s[t + 2],
                                    n = s[t + 4],
                                    r = Math.max(e, i, n),
                                    a = Math.min(e, i, n);
                                r > .9 && a < .1 && (e < .2 && (s[t + 0] += 1), i < .2 && (s[t + 2] += 1), n < .2 && (s[t + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new Br(r, 3)), this.setAttribute("normal", new Br(r.slice(), 3)), this.setAttribute("uv", new Br(s, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
                }
                static fromJSON(t) {
                    return new zh(t.vertices, t.indices, t.radius, t.details)
                }
            }
            new fn, new fn, new fn, new Cr;
            class Dh extends Ph {
                constructor(t) {
                    super(t), this.uuid = Oi(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(t) {
                    const e = [];
                    for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                    return e
                }
                extractPoints(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                }
                copy(t) {
                    super.copy(t), this.holes = [];
                    for (let e = 0, i = t.holes.length; e < i; e++) {
                        const i = t.holes[e];
                        this.holes.push(i.clone())
                    }
                    return this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.uuid = this.uuid, t.holes = [];
                    for (let e = 0, i = this.holes.length; e < i; e++) {
                        const i = this.holes[e];
                        t.holes.push(i.toJSON())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                    for (let e = 0, i = t.holes.length; e < i; e++) {
                        const i = t.holes[e];
                        this.holes.push((new Ph).fromJSON(i))
                    }
                    return this
                }
            }
            const Ih = function(t, e, i = 2) {
                const n = e && e.length,
                    r = n ? e[0] * i : t.length;
                let s = Nh(t, 0, r, i, !0);
                const a = [];
                if (!s || s.next === s.prev) return a;
                let o, l, h, c, u, d, p;
                if (n && (s = function(t, e, i, n) {
                        const r = [];
                        let s, a, o, l, h;
                        for (s = 0, a = e.length; s < a; s++) o = e[s] * n, l = s < a - 1 ? e[s + 1] * n : t.length, h = Nh(t, o, l, n, !1), h === h.next && (h.steiner = !0), r.push(qh(h));
                        for (r.sort(Vh), s = 0; s < r.length; s++) Gh(r[s], i), i = Oh(i, i.next);
                        return i
                    }(t, e, s, i)), t.length > 80 * i) {
                    o = h = t[0], l = c = t[1];
                    for (let e = i; e < r; e += i) u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > h && (h = u), d > c && (c = d);
                    p = Math.max(h - o, c - l), p = 0 !== p ? 1 / p : 0
                }
                return Bh(s, a, i, o, l, p), a
            };

            function Nh(t, e, i, n, r) {
                let s, a;
                if (r === function(t, e, i, n) {
                        let r = 0;
                        for (let s = e, a = i - n; s < i; s += n) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                        return r
                    }(t, e, i, n) > 0)
                    for (s = e; s < i; s += n) a = ic(s, t[s], t[s + 1], a);
                else
                    for (s = i - n; s >= e; s -= n) a = ic(s, t[s], t[s + 1], a);
                return a && Zh(a, a.next) && (nc(a), a = a.next), a
            }

            function Oh(t, e) {
                if (!t) return t;
                e || (e = t);
                let i, n = t;
                do {
                    if (i = !1, n.steiner || !Zh(n, n.next) && 0 !== Jh(n.prev, n, n.next)) n = n.next;
                    else {
                        if (nc(n), n = e = n.prev, n === n.next) break;
                        i = !0
                    }
                } while (i || n !== e);
                return e
            }

            function Bh(t, e, i, n, r, s, a) {
                if (!t) return;
                !a && s && function(t, e, i, n) {
                    let r = t;
                    do {
                        null === r.z && (r.z = jh(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== t);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function(t) {
                            let e, i, n, r, s, a, o, l, h = 1;
                            do {
                                for (i = t, t = null, s = null, a = 0; i;) {
                                    for (a++, n = i, o = 0, e = 0; e < h && (o++, n = n.nextZ, n); e++);
                                    for (l = h; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                    i = n
                                }
                                s.nextZ = null, h *= 2
                            } while (a > 1)
                        }(r)
                }(t, n, r, s);
                let o, l, h = t;
                for (; t.prev !== t.next;)
                    if (o = t.prev, l = t.next, s ? Uh(t, n, r, s) : Hh(t)) e.push(o.i / i), e.push(t.i / i), e.push(l.i / i), nc(t), t = l.next, h = l.next;
                    else if ((t = l) === h) {
                    a ? 1 === a ? Bh(t = Fh(Oh(t), e, i), e, i, n, r, s, 2) : 2 === a && kh(t, e, i, n, r, s) : Bh(Oh(t), e, i, n, r, s, 1);
                    break
                }
            }

            function Hh(t) {
                const e = t.prev,
                    i = t,
                    n = t.next;
                if (Jh(e, i, n) >= 0) return !1;
                let r = t.next.next;
                for (; r !== t.prev;) {
                    if (Xh(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && Jh(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function Uh(t, e, i, n) {
                const r = t.prev,
                    s = t,
                    a = t.next;
                if (Jh(r, s, a) >= 0) return !1;
                const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
                    l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
                    h = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
                    c = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y,
                    u = jh(o, l, e, i, n),
                    d = jh(h, c, e, i, n);
                let p = t.prevZ,
                    m = t.nextZ;
                for (; p && p.z >= u && m && m.z <= d;) {
                    if (p !== t.prev && p !== t.next && Xh(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Jh(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, m !== t.prev && m !== t.next && Xh(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Jh(m.prev, m, m.next) >= 0) return !1;
                    m = m.nextZ
                }
                for (; p && p.z >= u;) {
                    if (p !== t.prev && p !== t.next && Xh(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Jh(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                for (; m && m.z <= d;) {
                    if (m !== t.prev && m !== t.next && Xh(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Jh(m.prev, m, m.next) >= 0) return !1;
                    m = m.nextZ
                }
                return !0
            }

            function Fh(t, e, i) {
                let n = t;
                do {
                    const r = n.prev,
                        s = n.next.next;
                    !Zh(r, s) && Qh(r, n, n.next, s) && tc(r, s) && tc(s, r) && (e.push(r.i / i), e.push(n.i / i), e.push(s.i / i), nc(n), nc(n.next), n = t = s), n = n.next
                } while (n !== t);
                return Oh(n)
            }

            function kh(t, e, i, n, r, s) {
                let a = t;
                do {
                    let t = a.next.next;
                    for (; t !== a.prev;) {
                        if (a.i !== t.i && Yh(a, t)) {
                            let o = ec(a, t);
                            return a = Oh(a, a.next), o = Oh(o, o.next), Bh(a, e, i, n, r, s), void Bh(o, e, i, n, r, s)
                        }
                        t = t.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function Vh(t, e) {
                return t.x - e.x
            }

            function Gh(t, e) {
                if (e = function(t, e) {
                        let i = e;
                        const n = t.x,
                            r = t.y;
                        let s, a = -1 / 0;
                        do {
                            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                                const t = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (t <= n && t > a) {
                                    if (a = t, t === n) {
                                        if (r === i.y) return i;
                                        if (r === i.next.y) return i.next
                                    }
                                    s = i.x < i.next.x ? i : i.next
                                }
                            }
                            i = i.next
                        } while (i !== e);
                        if (!s) return null;
                        if (n === a) return s;
                        const o = s,
                            l = s.x,
                            h = s.y;
                        let c, u = 1 / 0;
                        i = s;
                        do {
                            n >= i.x && i.x >= l && n !== i.x && Xh(r < h ? n : a, r, l, h, r < h ? a : n, r, i.x, i.y) && (c = Math.abs(r - i.y) / (n - i.x), tc(i, t) && (c < u || c === u && (i.x > s.x || i.x === s.x && Wh(s, i))) && (s = i, u = c)), i = i.next
                        } while (i !== o);
                        return s
                    }(t, e), e) {
                    const i = ec(e, t);
                    Oh(e, e.next), Oh(i, i.next)
                }
            }

            function Wh(t, e) {
                return Jh(t.prev, t, e.prev) < 0 && Jh(e.next, t, t.next) < 0
            }

            function jh(t, e, i, n, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function qh(t) {
                let e = t,
                    i = t;
                do {
                    (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next
                } while (e !== t);
                return i
            }

            function Xh(t, e, i, n, r, s, a, o) {
                return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (i - a) * (e - o) >= 0 && (i - a) * (s - o) - (r - a) * (n - o) >= 0
            }

            function Yh(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    let i = t;
                    do {
                        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Qh(i, i.next, t, e)) return !0;
                        i = i.next
                    } while (i !== t);
                    return !1
                }(t, e) && (tc(t, e) && tc(e, t) && function(t, e) {
                    let i = t,
                        n = !1;
                    const r = (t.x + e.x) / 2,
                        s = (t.y + e.y) / 2;
                    do {
                        i.y > s !== i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                    } while (i !== t);
                    return n
                }(t, e) && (Jh(t.prev, t, e.prev) || Jh(t, e.prev, e)) || Zh(t, e) && Jh(t.prev, t, t.next) > 0 && Jh(e.prev, e, e.next) > 0)
            }

            function Jh(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }

            function Zh(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function Qh(t, e, i, n) {
                const r = $h(Jh(t, e, i)),
                    s = $h(Jh(t, e, n)),
                    a = $h(Jh(i, n, t)),
                    o = $h(Jh(i, n, e));
                return r !== s && a !== o || (!(0 !== r || !Kh(t, i, e)) || (!(0 !== s || !Kh(t, n, e)) || (!(0 !== a || !Kh(i, t, n)) || !(0 !== o || !Kh(i, e, n)))))
            }

            function Kh(t, e, i) {
                return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
            }

            function $h(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function tc(t, e) {
                return Jh(t.prev, t, t.next) < 0 ? Jh(t, e, t.next) >= 0 && Jh(t, t.prev, e) >= 0 : Jh(t, e, t.prev) < 0 || Jh(t, t.next, e) < 0
            }

            function ec(t, e) {
                const i = new rc(t.i, t.x, t.y),
                    n = new rc(e.i, e.x, e.y),
                    r = t.next,
                    s = e.prev;
                return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n
            }

            function ic(t, e, i, n) {
                const r = new rc(t, e, i);
                return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
            }

            function nc(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function rc(t, e, i) {
                this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class sc {
                static area(t) {
                    const e = t.length;
                    let i = 0;
                    for (let n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                    return .5 * i
                }
                static isClockWise(t) {
                    return sc.area(t) < 0
                }
                static triangulateShape(t, e) {
                    const i = [],
                        n = [],
                        r = [];
                    ac(t), oc(i, t);
                    let s = t.length;
                    e.forEach(ac);
                    for (let o = 0; o < e.length; o++) n.push(s), s += e[o].length, oc(i, e[o]);
                    const a = Ih(i, n);
                    for (let o = 0; o < a.length; o += 3) r.push(a.slice(o, o + 3));
                    return r
                }
            }

            function ac(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function oc(t, e) {
                for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
            }
            class lc extends jr {
                constructor(t = new Dh([new Vi(.5, .5), new Vi(-.5, .5), new Vi(-.5, -.5), new Vi(.5, -.5)]), e = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, t = Array.isArray(t) ? t : [t];
                    const i = this,
                        n = [],
                        r = [];
                    for (let a = 0, o = t.length; a < o; a++) {
                        s(t[a])
                    }

                    function s(t) {
                        const s = [],
                            a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            o = void 0 !== e.steps ? e.steps : 1;
                        let l = void 0 !== e.depth ? e.depth : 1,
                            h = void 0 === e.bevelEnabled || e.bevelEnabled,
                            c = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                            u = void 0 !== e.bevelSize ? e.bevelSize : c - .1,
                            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const m = e.extrudePath,
                            f = void 0 !== e.UVGenerator ? e.UVGenerator : hc;
                        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                        let g, y, x, v, _, b = !1;
                        m && (g = m.getSpacedPoints(o), b = !0, h = !1, y = m.computeFrenetFrames(o, !1), x = new fn, v = new fn, _ = new fn), h || (p = 0, c = 0, u = 0, d = 0);
                        const M = t.extractPoints(a);
                        let w = M.shape;
                        const S = M.holes;
                        if (!sc.isClockWise(w)) {
                            w = w.reverse();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                sc.isClockWise(e) && (S[t] = e.reverse())
                            }
                        }
                        const E = sc.triangulateShape(w, S),
                            T = w;
                        for (let e = 0, i = S.length; e < i; e++) {
                            const t = S[e];
                            w = w.concat(t)
                        }

                        function A(t, e, i) {
                            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
                        }
                        const C = w.length,
                            R = E.length;

                        function L(t, e, i) {
                            let n, r, s;
                            const a = t.x - e.x,
                                o = t.y - e.y,
                                l = i.x - t.x,
                                h = i.y - t.y,
                                c = a * a + o * o,
                                u = a * h - o * l;
                            if (Math.abs(u) > Number.EPSILON) {
                                const u = Math.sqrt(c),
                                    d = Math.sqrt(l * l + h * h),
                                    p = e.x - o / u,
                                    m = e.y + a / u,
                                    f = ((i.x - h / d - p) * h - (i.y + l / d - m) * l) / (a * h - o * l);
                                n = p + a * f - t.x, r = m + o * f - t.y;
                                const g = n * n + r * r;
                                if (g <= 2) return new Vi(n, r);
                                s = Math.sqrt(g / 2)
                            } else {
                                let t = !1;
                                a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(h) && (t = !0), t ? (n = -o, r = a, s = Math.sqrt(c)) : (n = a, r = o, s = Math.sqrt(c / 2))
                            }
                            return new Vi(n / s, r / s)
                        }
                        const P = [];
                        for (let e = 0, i = T.length, n = i - 1, r = e + 1; e < i; e++, n++, r++) n === i && (n = 0), r === i && (r = 0), P[e] = L(T[e], T[n], T[r]);
                        const z = [];
                        let D, I = P.concat();
                        for (let e = 0, i = S.length; e < i; e++) {
                            const t = S[e];
                            D = [];
                            for (let e = 0, i = t.length, n = i - 1, r = e + 1; e < i; e++, n++, r++) n === i && (n = 0), r === i && (r = 0), D[e] = L(t[e], t[n], t[r]);
                            z.push(D), I = I.concat(D)
                        }
                        for (let e = 0; e < p; e++) {
                            const t = e / p,
                                i = c * Math.cos(t * Math.PI / 2),
                                n = u * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, r = T.length; e < r; e++) {
                                const t = A(T[e], P[e], n);
                                B(t.x, t.y, -i)
                            }
                            for (let e = 0, r = S.length; e < r; e++) {
                                const t = S[e];
                                D = z[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = A(t[e], D[e], n);
                                    B(r.x, r.y, -i)
                                }
                            }
                        }
                        const N = u + d;
                        for (let e = 0; e < C; e++) {
                            const t = h ? A(w[e], I[e], N) : w[e];
                            b ? (v.copy(y.normals[0]).multiplyScalar(t.x), x.copy(y.binormals[0]).multiplyScalar(t.y), _.copy(g[0]).add(v).add(x), B(_.x, _.y, _.z)) : B(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= o; e++)
                            for (let t = 0; t < C; t++) {
                                const i = h ? A(w[t], I[t], N) : w[t];
                                b ? (v.copy(y.normals[e]).multiplyScalar(i.x), x.copy(y.binormals[e]).multiplyScalar(i.y), _.copy(g[e]).add(v).add(x), B(_.x, _.y, _.z)) : B(i.x, i.y, l / o * e)
                            }
                        for (let e = p - 1; e >= 0; e--) {
                            const t = e / p,
                                i = c * Math.cos(t * Math.PI / 2),
                                n = u * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, r = T.length; e < r; e++) {
                                const t = A(T[e], P[e], n);
                                B(t.x, t.y, l + i)
                            }
                            for (let e = 0, r = S.length; e < r; e++) {
                                const t = S[e];
                                D = z[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = A(t[e], D[e], n);
                                    b ? B(r.x, r.y + g[o - 1].y, g[o - 1].x + i) : B(r.x, r.y, l + i)
                                }
                            }
                        }

                        function O(t, e) {
                            let i = t.length;
                            for (; --i >= 0;) {
                                const n = i;
                                let r = i - 1;
                                r < 0 && (r = t.length - 1);
                                for (let t = 0, i = o + 2 * p; t < i; t++) {
                                    const i = C * t,
                                        s = C * (t + 1);
                                    U(e + n + i, e + r + i, e + r + s, e + n + s)
                                }
                            }
                        }

                        function B(t, e, i) {
                            s.push(t), s.push(e), s.push(i)
                        }

                        function H(t, e, r) {
                            F(t), F(e), F(r);
                            const s = n.length / 3,
                                a = f.generateTopUV(i, n, s - 3, s - 2, s - 1);
                            k(a[0]), k(a[1]), k(a[2])
                        }

                        function U(t, e, r, s) {
                            F(t), F(e), F(s), F(e), F(r), F(s);
                            const a = n.length / 3,
                                o = f.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                            k(o[0]), k(o[1]), k(o[3]), k(o[1]), k(o[2]), k(o[3])
                        }

                        function F(t) {
                            n.push(s[3 * t + 0]), n.push(s[3 * t + 1]), n.push(s[3 * t + 2])
                        }

                        function k(t) {
                            r.push(t.x), r.push(t.y)
                        }! function() {
                            const t = n.length / 3;
                            if (h) {
                                let t = 0,
                                    e = C * t;
                                for (let i = 0; i < R; i++) {
                                    const t = E[i];
                                    H(t[2] + e, t[1] + e, t[0] + e)
                                }
                                t = o + 2 * p, e = C * t;
                                for (let i = 0; i < R; i++) {
                                    const t = E[i];
                                    H(t[0] + e, t[1] + e, t[2] + e)
                                }
                            } else {
                                for (let t = 0; t < R; t++) {
                                    const e = E[t];
                                    H(e[2], e[1], e[0])
                                }
                                for (let t = 0; t < R; t++) {
                                    const e = E[t];
                                    H(e[0] + C * o, e[1] + C * o, e[2] + C * o)
                                }
                            }
                            i.addGroup(t, n.length / 3 - t, 0)
                        }(),
                        function() {
                            const t = n.length / 3;
                            let e = 0;
                            O(T, e), e += T.length;
                            for (let i = 0, n = S.length; i < n; i++) {
                                const t = S[i];
                                O(t, e), e += t.length
                            }
                            i.addGroup(t, n.length / 3 - t, 1)
                        }()
                    }
                    this.setAttribute("position", new Br(n, 3)), this.setAttribute("uv", new Br(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const t = super.toJSON();
                    return function(t, e, i) {
                        if (i.shapes = [], Array.isArray(t))
                            for (let n = 0, r = t.length; n < r; n++) {
                                const e = t[n];
                                i.shapes.push(e.uuid)
                            } else i.shapes.push(t.uuid);
                        void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON());
                        return i
                    }(this.parameters.shapes, this.parameters.options, t)
                }
                static fromJSON(t, e) {
                    const i = [];
                    for (let r = 0, s = t.shapes.length; r < s; r++) {
                        const n = e[t.shapes[r]];
                        i.push(n)
                    }
                    const n = t.options.extrudePath;
                    return void 0 !== n && (t.options.extrudePath = (new Rh[n.type]).fromJSON(n)), new lc(i, t.options)
                }
            }
            const hc = {
                generateTopUV: function(t, e, i, n, r) {
                    const s = e[3 * i],
                        a = e[3 * i + 1],
                        o = e[3 * n],
                        l = e[3 * n + 1],
                        h = e[3 * r],
                        c = e[3 * r + 1];
                    return [new Vi(s, a), new Vi(o, l), new Vi(h, c)]
                },
                generateSideWallUV: function(t, e, i, n, r, s) {
                    const a = e[3 * i],
                        o = e[3 * i + 1],
                        l = e[3 * i + 2],
                        h = e[3 * n],
                        c = e[3 * n + 1],
                        u = e[3 * n + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        m = e[3 * r + 2],
                        f = e[3 * s],
                        g = e[3 * s + 1],
                        y = e[3 * s + 2];
                    return Math.abs(o - c) < Math.abs(a - h) ? [new Vi(a, 1 - l), new Vi(h, 1 - u), new Vi(d, 1 - m), new Vi(f, 1 - y)] : [new Vi(o, 1 - l), new Vi(c, 1 - u), new Vi(p, 1 - m), new Vi(g, 1 - y)]
                }
            };
            class cc extends zh {
                constructor(t = 1, e = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                static fromJSON(t) {
                    return new cc(t.radius, t.detail)
                }
            }
            class uc extends jr {
                constructor(t = new Dh([new Vi(0, .5), new Vi(-.5, -.5), new Vi(.5, -.5)]), e = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: t,
                        curveSegments: e
                    };
                    const i = [],
                        n = [],
                        r = [],
                        s = [];
                    let a = 0,
                        o = 0;
                    if (!1 === Array.isArray(t)) l(t);
                    else
                        for (let h = 0; h < t.length; h++) l(t[h]), this.addGroup(a, o, h), a += o, o = 0;

                    function l(t) {
                        const a = n.length / 3,
                            l = t.extractPoints(e);
                        let h = l.shape;
                        const c = l.holes;
                        !1 === sc.isClockWise(h) && (h = h.reverse());
                        for (let e = 0, i = c.length; e < i; e++) {
                            const t = c[e];
                            !0 === sc.isClockWise(t) && (c[e] = t.reverse())
                        }
                        const u = sc.triangulateShape(h, c);
                        for (let e = 0, i = c.length; e < i; e++) {
                            const t = c[e];
                            h = h.concat(t)
                        }
                        for (let e = 0, i = h.length; e < i; e++) {
                            const t = h[e];
                            n.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y)
                        }
                        for (let e = 0, n = u.length; e < n; e++) {
                            const t = u[e],
                                n = t[0] + a,
                                r = t[1] + a,
                                s = t[2] + a;
                            i.push(n, r, s), o += 3
                        }
                    }
                    this.setIndex(i), this.setAttribute("position", new Br(n, 3)), this.setAttribute("normal", new Br(r, 3)), this.setAttribute("uv", new Br(s, 2))
                }
                toJSON() {
                    const t = super.toJSON();
                    return function(t, e) {
                        if (e.shapes = [], Array.isArray(t))
                            for (let i = 0, n = t.length; i < n; i++) {
                                const n = t[i];
                                e.shapes.push(n.uuid)
                            } else e.shapes.push(t.uuid);
                        return e
                    }(this.parameters.shapes, t)
                }
                static fromJSON(t, e) {
                    const i = [];
                    for (let n = 0, r = t.shapes.length; n < r; n++) {
                        const r = e[t.shapes[n]];
                        i.push(r)
                    }
                    return new uc(i, t.curveSegments)
                }
            }
            class dc extends Lr {
                constructor(t) {
                    super(), this.type = "ShadowMaterial", this.color = new nn(0), this.transparent = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this
                }
            }
            dc.prototype.isShadowMaterial = !0;
            class pc extends fs {
                constructor(t) {
                    super(t), this.type = "RawShaderMaterial"
                }
            }
            pc.prototype.isRawShaderMaterial = !0;
            class mc extends Lr {
                constructor(t) {
                    super(), this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new nn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                }
            }
            mc.prototype.isMeshStandardMaterial = !0;
            class fc extends mc {
                constructor(t) {
                    super(), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vi(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return Bi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(t) {
                            this.ior = (1 + .4 * t) / (1 - .4 * t)
                        }
                    }), this.sheenColor = new nn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new nn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new nn(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(t) {
                    this._sheen > 0 !== t > 0 && this.version++, this._sheen = t
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(t) {
                    this._clearcoat > 0 !== t > 0 && this.version++, this._clearcoat = t
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(t) {
                    this._transmission > 0 !== t > 0 && this.version++, this._transmission = t
                }
                copy(t) {
                    return super.copy(t), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                }
            }
            fc.prototype.isMeshPhysicalMaterial = !0;
            class gc extends Lr {
                constructor(t) {
                    super(), this.type = "MeshPhongMaterial", this.color = new nn(16777215), this.specular = new nn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                }
            }
            gc.prototype.isMeshPhongMaterial = !0;
            class yc extends Lr {
                constructor(t) {
                    super(), this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new nn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                }
            }
            yc.prototype.isMeshToonMaterial = !0;
            class xc extends Lr {
                constructor(t) {
                    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                }
            }
            xc.prototype.isMeshNormalMaterial = !0;
            class vc extends Lr {
                constructor(t) {
                    super(), this.type = "MeshLambertMaterial", this.color = new nn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                }
            }
            vc.prototype.isMeshLambertMaterial = !0;
            class _c extends Lr {
                constructor(t) {
                    super(), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new nn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
                }
            }
            _c.prototype.isMeshMatcapMaterial = !0;
            class bc extends ql {
                constructor(t) {
                    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                }
            }
            bc.prototype.isLineDashedMaterial = !0;
            const Mc = {
                ShadowMaterial: dc,
                SpriteMaterial: gl,
                RawShaderMaterial: pc,
                ShaderMaterial: fs,
                PointsMaterial: nh,
                MeshPhysicalMaterial: fc,
                MeshStandardMaterial: mc,
                MeshPhongMaterial: gc,
                MeshToonMaterial: yc,
                MeshNormalMaterial: xc,
                MeshLambertMaterial: vc,
                MeshDepthMaterial: Zo,
                MeshDistanceMaterial: Qo,
                MeshBasicMaterial: Pr,
                MeshMatcapMaterial: _c,
                LineDashedMaterial: bc,
                LineBasicMaterial: ql,
                Material: Lr
            };
            Lr.fromType = function(t) {
                return new Mc[t]
            };
            const wc = {
                arraySlice: function(t, e, i) {
                    return wc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
                },
                convertArray: function(t, e, i) {
                    return !t || !i && t.constructor === e ? t : "number" === typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    const e = t.length,
                        i = new Array(e);
                    for (let n = 0; n !== e; ++n) i[n] = n;
                    return i.sort((function(e, i) {
                        return t[e] - t[i]
                    })), i
                },
                sortedArray: function(t, e, i) {
                    const n = t.length,
                        r = new t.constructor(n);
                    for (let s = 0, a = 0; a !== n; ++s) {
                        const n = i[s] * e;
                        for (let i = 0; i !== e; ++i) r[a++] = t[n + i]
                    }
                    return r
                },
                flattenJSON: function(t, e, i, n) {
                    let r = 1,
                        s = t[0];
                    for (; void 0 !== s && void 0 === s[n];) s = t[r++];
                    if (void 0 === s) return;
                    let a = s[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                a = s[n], void 0 !== a && (e.push(s.time), i.push.apply(i, a)), s = t[r++]
                            } while (void 0 !== s);
                        else if (void 0 !== a.toArray)
                        do {
                            a = s[n], void 0 !== a && (e.push(s.time), a.toArray(i, i.length)), s = t[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            a = s[n], void 0 !== a && (e.push(s.time), i.push(a)), s = t[r++]
                        } while (void 0 !== s)
                },
                subclip: function(t, e, i, n, r = 30) {
                    const s = t.clone();
                    s.name = e;
                    const a = [];
                    for (let l = 0; l < s.tracks.length; ++l) {
                        const t = s.tracks[l],
                            e = t.getValueSize(),
                            o = [],
                            h = [];
                        for (let s = 0; s < t.times.length; ++s) {
                            const a = t.times[s] * r;
                            if (!(a < i || a >= n)) {
                                o.push(t.times[s]);
                                for (let i = 0; i < e; ++i) h.push(t.values[s * e + i])
                            }
                        }
                        0 !== o.length && (t.times = wc.convertArray(o, t.times.constructor), t.values = wc.convertArray(h, t.values.constructor), a.push(t))
                    }
                    s.tracks = a;
                    let o = 1 / 0;
                    for (let l = 0; l < s.tracks.length; ++l) o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
                    for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
                    return s.resetDuration(), s
                },
                makeClipAdditive: function(t, e = 0, i = t, n = 30) {
                    n <= 0 && (n = 30);
                    const r = i.tracks.length,
                        s = e / n;
                    for (let a = 0; a < r; ++a) {
                        const e = i.tracks[a],
                            n = e.ValueTypeName;
                        if ("bool" === n || "string" === n) continue;
                        const r = t.tracks.find((function(t) {
                            return t.name === e.name && t.ValueTypeName === n
                        }));
                        if (void 0 === r) continue;
                        let o = 0;
                        const l = e.getValueSize();
                        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                        let h = 0;
                        const c = r.getValueSize();
                        r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
                        const u = e.times.length - 1;
                        let d;
                        if (s <= e.times[0]) {
                            const t = o,
                                i = l - o;
                            d = wc.arraySlice(e.values, t, i)
                        } else if (s >= e.times[u]) {
                            const t = u * l + o,
                                i = t + l - o;
                            d = wc.arraySlice(e.values, t, i)
                        } else {
                            const t = e.createInterpolant(),
                                i = o,
                                n = l - o;
                            t.evaluate(s), d = wc.arraySlice(t.resultBuffer, i, n)
                        }
                        if ("quaternion" === n) {
                            (new mn).fromArray(d).normalize().conjugate().toArray(d)
                        }
                        const p = r.times.length;
                        for (let t = 0; t < p; ++t) {
                            const e = t * c + h;
                            if ("quaternion" === n) mn.multiplyQuaternionsFlat(r.values, e, d, 0, r.values, e);
                            else {
                                const t = c - 2 * h;
                                for (let i = 0; i < t; ++i) r.values[e + i] -= d[i]
                            }
                        }
                    }
                    return t.blendMode = 2501, t
                }
            };
            class Sc {
                constructor(t, e, i, n) {
                    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(t) {
                    const e = this.parameterPositions;
                    let i = this._cachedIndex,
                        n = e[i],
                        r = e[i - 1];
                    t: {
                        e: {
                            let s;i: {
                                n: if (!(t < n)) {
                                    for (let s = i + 2;;) {
                                        if (void 0 === n) {
                                            if (t < r) break n;
                                            return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                        }
                                        if (i === s) break;
                                        if (r = n, n = e[++i], t < n) break e
                                    }
                                    s = e.length;
                                    break i
                                }if (t >= r) break t; {
                                    const a = e[1];
                                    t < a && (i = 2, r = a);
                                    for (let s = i - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                        if (i === s) break;
                                        if (n = r, r = e[--i - 1], t >= r) break e
                                    }
                                    s = i, i = 0
                                }
                            }
                            for (; i < s;) {
                                const n = i + s >>> 1;
                                t < e[n] ? s = n : i = n + 1
                            }
                            if (n = e[i], r = e[i - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                            if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t)
                        }
                        this._cachedIndex = i,
                        this.intervalChanged_(i, r, n)
                    }
                    return this.interpolate_(i, r, t, n)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        r = t * n;
                    for (let s = 0; s !== n; ++s) e[s] = i[r + s];
                    return e
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            Sc.prototype.beforeStart_ = Sc.prototype.copySampleValue_, Sc.prototype.afterEnd_ = Sc.prototype.copySampleValue_;
            class Ec extends Sc {
                constructor(t, e, i, n) {
                    super(t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: vi,
                        endingEnd: vi
                    }
                }
                intervalChanged_(t, e, i) {
                    const n = this.parameterPositions;
                    let r = t - 2,
                        s = t + 1,
                        a = n[r],
                        o = n[s];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case _i:
                            r = t, a = 2 * e - i;
                            break;
                        case bi:
                            r = n.length - 2, a = e + n[r] - n[r + 1];
                            break;
                        default:
                            r = t, a = i
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case _i:
                            s = t, o = 2 * i - e;
                            break;
                        case bi:
                            s = 1, o = i + n[1] - n[0];
                            break;
                        default:
                            s = t - 1, o = e
                    }
                    const l = .5 * (i - e),
                        h = this.valueSize;
                    this._weightPrev = l / (e - a), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = s * h
                }
                interpolate_(t, e, i, n) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        l = o - a,
                        h = this._offsetPrev,
                        c = this._offsetNext,
                        u = this._weightPrev,
                        d = this._weightNext,
                        p = (i - e) / (n - e),
                        m = p * p,
                        f = m * p,
                        g = -u * f + 2 * u * m - u * p,
                        y = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                        x = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                        v = d * f - d * m;
                    for (let _ = 0; _ !== a; ++_) r[_] = g * s[h + _] + y * s[l + _] + x * s[o + _] + v * s[c + _];
                    return r
                }
            }
            class Tc extends Sc {
                constructor(t, e, i, n) {
                    super(t, e, i, n)
                }
                interpolate_(t, e, i, n) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        l = o - a,
                        h = (i - e) / (n - e),
                        c = 1 - h;
                    for (let u = 0; u !== a; ++u) r[u] = s[l + u] * c + s[o + u] * h;
                    return r
                }
            }
            class Ac extends Sc {
                constructor(t, e, i, n) {
                    super(t, e, i, n)
                }
                interpolate_(t) {
                    return this.copySampleValue_(t - 1)
                }
            }
            class Cc {
                constructor(t, e, i, n) {
                    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                    this.name = t, this.times = wc.convertArray(e, this.TimeBufferType), this.values = wc.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
                }
                static toJSON(t) {
                    const e = t.constructor;
                    let i;
                    if (e.toJSON !== this.toJSON) i = e.toJSON(t);
                    else {
                        i = {
                            name: t.name,
                            times: wc.convertArray(t.times, Array),
                            values: wc.convertArray(t.values, Array)
                        };
                        const e = t.getInterpolation();
                        e !== t.DefaultInterpolation && (i.interpolation = e)
                    }
                    return i.type = t.ValueTypeName, i
                }
                InterpolantFactoryMethodDiscrete(t) {
                    return new Ac(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodLinear(t) {
                    return new Tc(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodSmooth(t) {
                    return new Ec(this.times, this.values, this.getValueSize(), t)
                }
                setInterpolation(t) {
                    let e;
                    switch (t) {
                        case gi:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case yi:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case xi:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", e), this
                    }
                    return this.createInterpolant = e, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return gi;
                        case this.InterpolantFactoryMethodLinear:
                            return yi;
                        case this.InterpolantFactoryMethodSmooth:
                            return xi
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
                    }
                    return this
                }
                scale(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
                    }
                    return this
                }
                trim(t, e) {
                    const i = this.times,
                        n = i.length;
                    let r = 0,
                        s = n - 1;
                    for (; r !== n && i[r] < t;) ++r;
                    for (; - 1 !== s && i[s] > e;) --s;
                    if (++s, 0 !== r || s !== n) {
                        r >= s && (s = Math.max(s, 1), r = s - 1);
                        const t = this.getValueSize();
                        this.times = wc.arraySlice(i, r, s), this.values = wc.arraySlice(this.values, r * t, s * t)
                    }
                    return this
                }
                validate() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    const i = this.times,
                        n = this.values,
                        r = i.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    let s = null;
                    for (let a = 0; a !== r; a++) {
                        const e = i[a];
                        if ("number" === typeof e && isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, e), t = !1;
                            break
                        }
                        if (null !== s && s > e) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, a, e, s), t = !1;
                            break
                        }
                        s = e
                    }
                    if (void 0 !== n && wc.isTypedArray(n))
                        for (let a = 0, o = n.length; a !== o; ++a) {
                            const e = n[a];
                            if (isNaN(e)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, e), t = !1;
                                break
                            }
                        }
                    return t
                }
                optimize() {
                    const t = wc.arraySlice(this.times),
                        e = wc.arraySlice(this.values),
                        i = this.getValueSize(),
                        n = this.getInterpolation() === xi,
                        r = t.length - 1;
                    let s = 1;
                    for (let a = 1; a < r; ++a) {
                        let r = !1;
                        const o = t[a];
                        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                            if (n) r = !0;
                            else {
                                const t = a * i,
                                    n = t - i,
                                    s = t + i;
                                for (let a = 0; a !== i; ++a) {
                                    const i = e[t + a];
                                    if (i !== e[n + a] || i !== e[s + a]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        if (r) {
                            if (a !== s) {
                                t[s] = t[a];
                                const n = a * i,
                                    r = s * i;
                                for (let t = 0; t !== i; ++t) e[r + t] = e[n + t]
                            }++s
                        }
                    }
                    if (r > 0) {
                        t[s] = t[r];
                        for (let t = r * i, n = s * i, a = 0; a !== i; ++a) e[n + a] = e[t + a];
                        ++s
                    }
                    return s !== t.length ? (this.times = wc.arraySlice(t, 0, s), this.values = wc.arraySlice(e, 0, s * i)) : (this.times = t, this.values = e), this
                }
                clone() {
                    const t = wc.arraySlice(this.times, 0),
                        e = wc.arraySlice(this.values, 0),
                        i = new(0, this.constructor)(this.name, t, e);
                    return i.createInterpolant = this.createInterpolant, i
                }
            }
            Cc.prototype.TimeBufferType = Float32Array, Cc.prototype.ValueBufferType = Float32Array, Cc.prototype.DefaultInterpolation = yi;
            class Rc extends Cc {}
            Rc.prototype.ValueTypeName = "bool", Rc.prototype.ValueBufferType = Array, Rc.prototype.DefaultInterpolation = gi, Rc.prototype.InterpolantFactoryMethodLinear = void 0, Rc.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Lc extends Cc {}
            Lc.prototype.ValueTypeName = "color";
            class Pc extends Cc {}
            Pc.prototype.ValueTypeName = "number";
            class zc extends Sc {
                constructor(t, e, i, n) {
                    super(t, e, i, n)
                }
                interpolate_(t, e, i, n) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = (i - e) / (n - e);
                    let l = t * a;
                    for (let h = l + a; l !== h; l += 4) mn.slerpFlat(r, 0, s, l - a, s, l, o);
                    return r
                }
            }
            class Dc extends Cc {
                InterpolantFactoryMethodLinear(t) {
                    return new zc(this.times, this.values, this.getValueSize(), t)
                }
            }
            Dc.prototype.ValueTypeName = "quaternion", Dc.prototype.DefaultInterpolation = yi, Dc.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Ic extends Cc {}
            Ic.prototype.ValueTypeName = "string", Ic.prototype.ValueBufferType = Array, Ic.prototype.DefaultInterpolation = gi, Ic.prototype.InterpolantFactoryMethodLinear = void 0, Ic.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Nc extends Cc {}
            Nc.prototype.ValueTypeName = "vector";
            class Oc {
                constructor(t, e = -1, i, n = 2500) {
                    this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = Oi(), this.duration < 0 && this.resetDuration()
                }
                static parse(t) {
                    const e = [],
                        i = t.tracks,
                        n = 1 / (t.fps || 1);
                    for (let s = 0, a = i.length; s !== a; ++s) e.push(Bc(i[s]).scale(n));
                    const r = new this(t.name, t.duration, e, t.blendMode);
                    return r.uuid = t.uuid, r
                }
                static toJSON(t) {
                    const e = [],
                        i = t.tracks,
                        n = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode
                        };
                    for (let r = 0, s = i.length; r !== s; ++r) e.push(Cc.toJSON(i[r]));
                    return n
                }
                static CreateFromMorphTargetSequence(t, e, i, n) {
                    const r = e.length,
                        s = [];
                    for (let a = 0; a < r; a++) {
                        let t = [],
                            o = [];
                        t.push((a + r - 1) % r, a, (a + 1) % r), o.push(0, 1, 0);
                        const l = wc.getKeyframeOrder(t);
                        t = wc.sortedArray(t, 1, l), o = wc.sortedArray(o, 1, l), n || 0 !== t[0] || (t.push(r), o.push(o[0])), s.push(new Pc(".morphTargetInfluences[" + e[a].name + "]", t, o).scale(1 / i))
                    }
                    return new this(t, -1, s)
                }
                static findByName(t, e) {
                    let i = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        i = e.geometry && e.geometry.animations || e.animations
                    }
                    for (let n = 0; n < i.length; n++)
                        if (i[n].name === e) return i[n];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(t, e, i) {
                    const n = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let a = 0, o = t.length; a < o; a++) {
                        const e = t[a],
                            i = e.name.match(r);
                        if (i && i.length > 1) {
                            const t = i[1];
                            let r = n[t];
                            r || (n[t] = r = []), r.push(e)
                        }
                    }
                    const s = [];
                    for (const a in n) s.push(this.CreateFromMorphTargetSequence(a, n[a], e, i));
                    return s
                }
                static parseAnimation(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const i = function(t, e, i, n, r) {
                            if (0 !== i.length) {
                                const s = [],
                                    a = [];
                                wc.flattenJSON(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a))
                            }
                        },
                        n = [],
                        r = t.name || "default",
                        s = t.fps || 30,
                        a = t.blendMode;
                    let o = t.length || -1;
                    const l = t.hierarchy || [];
                    for (let h = 0; h < l.length; h++) {
                        const t = l[h].keys;
                        if (t && 0 !== t.length)
                            if (t[0].morphTargets) {
                                const e = {};
                                let i;
                                for (i = 0; i < t.length; i++)
                                    if (t[i].morphTargets)
                                        for (let n = 0; n < t[i].morphTargets.length; n++) e[t[i].morphTargets[n]] = -1;
                                for (const r in e) {
                                    const e = [],
                                        s = [];
                                    for (let n = 0; n !== t[i].morphTargets.length; ++n) {
                                        const n = t[i];
                                        e.push(n.time), s.push(n.morphTarget === r ? 1 : 0)
                                    }
                                    n.push(new Pc(".morphTargetInfluence[" + r + "]", e, s))
                                }
                                o = e.length * s
                            } else {
                                const r = ".bones[" + e[h].name + "]";
                                i(Nc, r + ".position", t, "pos", n), i(Dc, r + ".quaternion", t, "rot", n), i(Nc, r + ".scale", t, "scl", n)
                            }
                    }
                    if (0 === n.length) return null;
                    return new this(r, o, n, a)
                }
                resetDuration() {
                    let t = 0;
                    for (let e = 0, i = this.tracks.length; e !== i; ++e) {
                        const i = this.tracks[e];
                        t = Math.max(t, i.times[i.times.length - 1])
                    }
                    return this.duration = t, this
                }
                trim() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                }
                validate() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                }
                optimize() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                }
                clone() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new this.constructor(this.name, this.duration, t, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }

            function Bc(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Pc;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Nc;
                        case "color":
                            return Lc;
                        case "quaternion":
                            return Dc;
                        case "bool":
                        case "boolean":
                            return Rc;
                        case "string":
                            return Ic
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        i = [];
                    wc.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            const Hc = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class Uc {
                constructor(t, e, i) {
                    const n = this;
                    let r, s = !1,
                        a = 0,
                        o = 0;
                    const l = [];
                    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                        o++, !1 === s && void 0 !== n.onStart && n.onStart(t, a, o), s = !0
                    }, this.itemEnd = function(t) {
                        a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (s = !1, void 0 !== n.onLoad && n.onLoad())
                    }, this.itemError = function(t) {
                        void 0 !== n.onError && n.onError(t)
                    }, this.resolveURL = function(t) {
                        return r ? r(t) : t
                    }, this.setURLModifier = function(t) {
                        return r = t, this
                    }, this.addHandler = function(t, e) {
                        return l.push(t, e), this
                    }, this.removeHandler = function(t) {
                        const e = l.indexOf(t);
                        return -1 !== e && l.splice(e, 2), this
                    }, this.getHandler = function(t) {
                        for (let e = 0, i = l.length; e < i; e += 2) {
                            const i = l[e],
                                n = l[e + 1];
                            if (i.global && (i.lastIndex = 0), i.test(t)) return n
                        }
                        return null
                    }
                }
            }
            const Fc = new Uc;
            class kc {
                constructor(t) {
                    this.manager = void 0 !== t ? t : Fc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(t, e) {
                    const i = this;
                    return new Promise((function(n, r) {
                        i.load(t, n, e, r)
                    }))
                }
                parse() {}
                setCrossOrigin(t) {
                    return this.crossOrigin = t, this
                }
                setWithCredentials(t) {
                    return this.withCredentials = t, this
                }
                setPath(t) {
                    return this.path = t, this
                }
                setResourcePath(t) {
                    return this.resourcePath = t, this
                }
                setRequestHeader(t) {
                    return this.requestHeader = t, this
                }
            }
            const Vc = {};
            class Gc extends kc {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = Hc.get(t);
                    if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                        e && e(r), this.manager.itemEnd(t)
                    }), 0), r;
                    if (void 0 !== Vc[t]) return void Vc[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    });
                    Vc[t] = [], Vc[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    });
                    const s = new Request(t, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin"
                        }),
                        a = this.mimeType,
                        o = this.responseType;
                    fetch(s).then((e => {
                        if (200 === e.status || 0 === e.status) {
                            if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" === typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                            const i = Vc[t],
                                n = e.body.getReader(),
                                r = e.headers.get("Content-Length"),
                                s = r ? parseInt(r) : 0,
                                a = 0 !== s;
                            let o = 0;
                            const l = new ReadableStream({
                                start(t) {
                                    ! function e() {
                                        n.read().then((({
                                            done: n,
                                            value: r
                                        }) => {
                                            if (n) t.close();
                                            else {
                                                o += r.byteLength;
                                                const n = new ProgressEvent("progress", {
                                                    lengthComputable: a,
                                                    loaded: o,
                                                    total: s
                                                });
                                                for (let t = 0, e = i.length; t < e; t++) {
                                                    const e = i[t];
                                                    e.onProgress && e.onProgress(n)
                                                }
                                                t.enqueue(r), e()
                                            }
                                        }))
                                    }()
                                }
                            });
                            return new Response(l)
                        }
                        throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
                    })).then((t => {
                        switch (o) {
                            case "arraybuffer":
                                return t.arrayBuffer();
                            case "blob":
                                return t.blob();
                            case "document":
                                return t.text().then((t => (new DOMParser).parseFromString(t, a)));
                            case "json":
                                return t.json();
                            default:
                                if (void 0 === a) return t.text(); {
                                    const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                        i = e && e[1] ? e[1].toLowerCase() : void 0,
                                        n = new TextDecoder(i);
                                    return t.arrayBuffer().then((t => n.decode(t)))
                                }
                        }
                    })).then((e => {
                        Hc.add(t, e);
                        const i = Vc[t];
                        delete Vc[t];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onLoad && n.onLoad(e)
                        }
                    })).catch((e => {
                        const i = Vc[t];
                        if (void 0 === i) throw this.manager.itemError(t), e;
                        delete Vc[t];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onError && n.onError(e)
                        }
                        this.manager.itemError(t)
                    })).finally((() => {
                        this.manager.itemEnd(t)
                    })), this.manager.itemStart(t)
                }
                setResponseType(t) {
                    return this.responseType = t, this
                }
                setMimeType(t) {
                    return this.mimeType = t, this
                }
            }
            class Wc extends kc {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = Hc.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const a = ji("img");

                    function o() {
                        h(), Hc.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function l(e) {
                        h(), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }

                    function h() {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                    }
                    return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                }
            }
            class jc extends kc {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    const r = new _s,
                        s = new Wc(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let a = 0;

                    function o(i) {
                        s.load(t[i], (function(t) {
                            r.images[i] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                        }), void 0, n)
                    }
                    for (let l = 0; l < t.length; ++l) o(l);
                    return r
                }
            }
            class qc extends kc {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    const r = new hn,
                        s = new Wc(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                        r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                    }), i, n), r
                }
            }
            class Xc extends yr {
                constructor(t, e = 1) {
                    super(), this.type = "Light", this.color = new nn(t), this.intensity = e
                }
                dispose() {}
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }
            Xc.prototype.isLight = !0;
            class Yc extends Xc {
                constructor(t, e, i) {
                    super(t, i), this.type = "HemisphereLight", this.position.copy(yr.DefaultUp), this.updateMatrix(), this.groundColor = new nn(e)
                }
                copy(t) {
                    return Xc.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }
            Yc.prototype.isHemisphereLight = !0;
            const Jc = new qn,
                Zc = new fn,
                Qc = new fn;
            class Kc {
                constructor(t) {
                    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vi(512, 512), this.map = null, this.mapPass = null, this.matrix = new qn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Cs, this._frameExtents = new Vi(1, 1), this._viewportCount = 1, this._viewports = [new cn(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(t) {
                    const e = this.camera,
                        i = this.matrix;
                    Zc.setFromMatrixPosition(t.matrixWorld), e.position.copy(Zc), Qc.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Qc), e.updateMatrixWorld(), Jc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Jc), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse)
                }
                getViewport(t) {
                    return this._viewports[t]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }
            class $c extends Kc {
                constructor() {
                    super(new ys(50, 1, .5, 500)), this.focus = 1
                }
                updateMatrices(t) {
                    const e = this.camera,
                        i = 2 * Ni * t.angle * this.focus,
                        n = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                }
                copy(t) {
                    return super.copy(t), this.focus = t.focus, this
                }
            }
            $c.prototype.isSpotLightShadow = !0;
            class tu extends Xc {
                constructor(t, e, i = 0, n = Math.PI / 3, r = 0, s = 1) {
                    super(t, e), this.type = "SpotLight", this.position.copy(yr.DefaultUp), this.updateMatrix(), this.target = new yr, this.distance = i, this.angle = n, this.penumbra = r, this.decay = s, this.shadow = new $c
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(t) {
                    return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }
            tu.prototype.isSpotLight = !0;
            const eu = new qn,
                iu = new fn,
                nu = new fn;
            class ru extends Kc {
                constructor() {
                    super(new ys(90, 1, .5, 500)), this._frameExtents = new Vi(4, 2), this._viewportCount = 6, this._viewports = [new cn(2, 1, 1, 1), new cn(0, 1, 1, 1), new cn(3, 1, 1, 1), new cn(1, 1, 1, 1), new cn(3, 0, 1, 1), new cn(1, 0, 1, 1)], this._cubeDirections = [new fn(1, 0, 0), new fn(-1, 0, 0), new fn(0, 0, 1), new fn(0, 0, -1), new fn(0, 1, 0), new fn(0, -1, 0)], this._cubeUps = [new fn(0, 1, 0), new fn(0, 1, 0), new fn(0, 1, 0), new fn(0, 1, 0), new fn(0, 0, 1), new fn(0, 0, -1)]
                }
                updateMatrices(t, e = 0) {
                    const i = this.camera,
                        n = this.matrix,
                        r = t.distance || i.far;
                    r !== i.far && (i.far = r, i.updateProjectionMatrix()), iu.setFromMatrixPosition(t.matrixWorld), i.position.copy(iu), nu.copy(i.position), nu.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(nu), i.updateMatrixWorld(), n.makeTranslation(-iu.x, -iu.y, -iu.z), eu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(eu)
                }
            }
            ru.prototype.isPointLightShadow = !0;
            class su extends Xc {
                constructor(t, e, i = 0, n = 1) {
                    super(t, e), this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new ru
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(t) {
                    return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }
            su.prototype.isPointLight = !0;
            class au extends Kc {
                constructor() {
                    super(new ks(-5, 5, 5, -5, .5, 500))
                }
            }
            au.prototype.isDirectionalLightShadow = !0;
            class ou extends Xc {
                constructor(t, e) {
                    super(t, e), this.type = "DirectionalLight", this.position.copy(yr.DefaultUp), this.updateMatrix(), this.target = new yr, this.shadow = new au
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(t) {
                    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }
            ou.prototype.isDirectionalLight = !0;
            class lu extends Xc {
                constructor(t, e) {
                    super(t, e), this.type = "AmbientLight"
                }
            }
            lu.prototype.isAmbientLight = !0;
            class hu extends Xc {
                constructor(t, e, i = 10, n = 10) {
                    super(t, e), this.type = "RectAreaLight", this.width = i, this.height = n
                }
                get power() {
                    return this.intensity * this.width * this.height * Math.PI
                }
                set power(t) {
                    this.intensity = t / (this.width * this.height * Math.PI)
                }
                copy(t) {
                    return super.copy(t), this.width = t.width, this.height = t.height, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }
            hu.prototype.isRectAreaLight = !0;
            class cu {
                constructor() {
                    this.coefficients = [];
                    for (let t = 0; t < 9; t++) this.coefficients.push(new fn)
                }
                set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                }
                zero() {
                    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                }
                getAt(t, e) {
                    const i = t.x,
                        n = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * n), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * i), e.addScaledVector(s[4], i * n * 1.092548), e.addScaledVector(s[5], n * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], i * r * 1.092548), e.addScaledVector(s[8], .546274 * (i * i - n * n)), e
                }
                getIrradianceAt(t, e) {
                    const i = t.x,
                        n = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * n), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * i), e.addScaledVector(s[4], .858086 * i * n), e.addScaledVector(s[5], .858086 * n * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * i * r), e.addScaledVector(s[8], .429043 * (i * i - n * n)), e
                }
                add(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                }
                addScaledSH(t, e) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
                    return this
                }
                scale(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                }
                lerp(t, e) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                    return this
                }
                equals(t) {
                    for (let e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                }
                copy(t) {
                    return this.set(t.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(t, e = 0) {
                    const i = this.coefficients;
                    for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
                    return this
                }
                toArray(t = [], e = 0) {
                    const i = this.coefficients;
                    for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
                    return t
                }
                static getBasisAt(t, e) {
                    const i = t.x,
                        n = t.y,
                        r = t.z;
                    e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * r, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = .546274 * (i * i - n * n)
                }
            }
            cu.prototype.isSphericalHarmonics3 = !0;
            class uu extends Xc {
                constructor(t = new cu, e = 1) {
                    super(void 0, e), this.sh = t
                }
                copy(t) {
                    return super.copy(t), this.sh.copy(t.sh), this
                }
                fromJSON(t) {
                    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.sh = this.sh.toArray(), e
                }
            }
            uu.prototype.isLightProbe = !0;
            class du {
                static decodeText(t) {
                    if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(t);
                    let e = "";
                    for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (i) {
                        return e
                    }
                }
                static extractUrlBase(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.slice(0, e + 1)
                }
                static resolveURL(t, e) {
                    return "string" !== typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                }
            }
            class pu extends jr {
                constructor() {
                    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(t) {
                    return super.copy(t), this.instanceCount = t.instanceCount, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const t = super.toJSON(this);
                    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                }
            }
            pu.prototype.isInstancedBufferGeometry = !0;
            let mu;
            (class extends kc {
                constructor(t) {
                    super(t), "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(t) {
                    return this.options = t, this
                }
                load(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = Hc.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const a = {};
                    a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then((function(t) {
                        return t.blob()
                    })).then((function(t) {
                        return createImageBitmap(t, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function(i) {
                        Hc.add(t, i), e && e(i), r.manager.itemEnd(t)
                    })).catch((function(e) {
                        n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    })), r.manager.itemStart(t)
                }
            }).prototype.isImageBitmapLoader = !0;
            const fu = function() {
                return void 0 === mu && (mu = new(window.AudioContext || window.webkitAudioContext)), mu
            };
            class gu extends kc {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, n) {
                    const r = this,
                        s = new Gc(this.manager);
                    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(i) {
                        try {
                            const t = i.slice(0);
                            fu().decodeAudioData(t, (function(t) {
                                e(t)
                            }))
                        } catch (s) {
                            n ? n(s) : console.error(s), r.manager.itemError(t)
                        }
                    }), i, n)
                }
            }(class extends uu {
                constructor(t, e, i = 1) {
                    super(void 0, i);
                    const n = (new nn).set(t),
                        r = (new nn).set(e),
                        s = new fn(n.r, n.g, n.b),
                        a = new fn(r.r, r.g, r.b),
                        o = Math.sqrt(Math.PI),
                        l = o * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
                }
            }).prototype.isHemisphereLightProbe = !0;
            (class extends uu {
                constructor(t, e = 1) {
                    super(void 0, e);
                    const i = (new nn).set(t);
                    this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }).prototype.isAmbientLightProbe = !0;
            class yu {
                constructor(t = !0) {
                    this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = xu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const e = xu();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }

            function xu() {
                return ("undefined" === typeof performance ? Date : performance).now()
            }
            class vu extends yr {
                constructor(t) {
                    super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                }
                setMediaElementSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                }
                setMediaStreamSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                }
                setBuffer(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(t = 0) {
                    if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + t;
                    const e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(t) {
                    return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                }
                setDetune(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(t) {
                    return this.setFilters(t ? [t] : [])
                }
                setPlaybackRate(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(t) {
                    return this.loopStart = t, this
                }
                setLoopEnd(t) {
                    return this.loopEnd = t, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }
            class _u {
                constructor(t, e, i) {
                    let n, r, s;
                    switch (this.binding = t, this.valueSize = i, e) {
                        case "quaternion":
                            n = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            n = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                            break;
                        default:
                            n = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
                    }
                    this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(t, e) {
                    const i = this.buffer,
                        n = this.valueSize,
                        r = t * n + n;
                    let s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let t = 0; t !== n; ++t) i[r + t] = i[t];
                        s = e
                    } else {
                        s += e;
                        const t = e / s;
                        this._mixBufferRegion(i, r, 0, t, n)
                    }
                    this.cumulativeWeight = s
                }
                accumulateAdditive(t) {
                    const e = this.buffer,
                        i = this.valueSize,
                        n = i * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t
                }
                apply(t) {
                    const e = this.valueSize,
                        i = this.buffer,
                        n = t * e + e,
                        r = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(i, n, t, 1 - r, e)
                    }
                    s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
                    for (let o = e, l = e + e; o !== l; ++o)
                        if (i[o] !== i[o + e]) {
                            a.setValue(i, n);
                            break
                        }
                }
                saveOriginalState() {
                    const t = this.binding,
                        e = this.buffer,
                        i = this.valueSize,
                        n = i * this._origIndex;
                    t.getValue(e, n);
                    for (let r = i, s = n; r !== s; ++r) e[r] = e[n + r % i];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                }
                _setAdditiveIdentityNumeric() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let i = t; i < e; i++) this.buffer[i] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
                }
                _select(t, e, i, n, r) {
                    if (n >= .5)
                        for (let s = 0; s !== r; ++s) t[e + s] = t[i + s]
                }
                _slerp(t, e, i, n) {
                    mn.slerpFlat(t, e, t, e, t, i, n)
                }
                _slerpAdditive(t, e, i, n, r) {
                    const s = this._workIndex * r;
                    mn.multiplyQuaternionsFlat(t, s, t, e, t, i), mn.slerpFlat(t, e, t, e, t, s, n)
                }
                _lerp(t, e, i, n, r) {
                    const s = 1 - n;
                    for (let a = 0; a !== r; ++a) {
                        const r = e + a;
                        t[r] = t[r] * s + t[i + a] * n
                    }
                }
                _lerpAdditive(t, e, i, n, r) {
                    for (let s = 0; s !== r; ++s) {
                        const r = e + s;
                        t[r] = t[r] + t[i + s] * n
                    }
                }
            }
            const bu = "\\[\\]\\.:\\/",
                Mu = new RegExp("[\\[\\]\\.:\\/]", "g"),
                wu = "[^\\[\\]\\.:\\/]",
                Su = "[^" + bu.replace("\\.", "") + "]",
                Eu = /((?:WC+[\/:])*)/.source.replace("WC", wu),
                Tu = /(WCOD+)?/.source.replace("WCOD", Su),
                Au = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wu),
                Cu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wu),
                Ru = new RegExp("^" + Eu + Tu + Au + Cu + "$"),
                Lu = ["material", "materials", "bones"];
            class Pu {
                constructor(t, e, i) {
                    this.path = e, this.parsedPath = i || Pu.parseTrackName(e), this.node = Pu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(t, e, i) {
                    return t && t.isAnimationObjectGroup ? new Pu.Composite(t, e, i) : new Pu(t, e, i)
                }
                static sanitizeNodeName(t) {
                    return t.replace(/\s/g, "_").replace(Mu, "")
                }
                static parseTrackName(t) {
                    const e = Ru.exec(t);
                    if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const i = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        n = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        const t = i.nodeName.substring(n + 1); - 1 !== Lu.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = t)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return i
                }
                static findNode(t, e) {
                    if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const i = t.skeleton.getBoneByName(e);
                        if (void 0 !== i) return i
                    }
                    if (t.children) {
                        const i = function(t) {
                                for (let n = 0; n < t.length; n++) {
                                    const r = t[n];
                                    if (r.name === e || r.uuid === e) return r;
                                    const s = i(r.children);
                                    if (s) return s
                                }
                                return null
                            },
                            n = i(t.children);
                        if (n) return n
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(t, e) {
                    t[e] = this.targetObject[this.propertyName]
                }
                _getValue_array(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
                }
                _getValue_arrayElement(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }
                _setValue_direct(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }
                _setValue_direct_setNeedsUpdate(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }
                _setValue_array_setNeedsUpdate(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }
                _setValue_arrayElement_setNeedsUpdate(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }
                _setValue_fromArray_setNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(t, e) {
                    this.bind(), this.getValue(t, e)
                }
                _setValue_unbound(t, e) {
                    this.bind(), this.setValue(t, e)
                }
                bind() {
                    let t = this.node;
                    const e = this.parsedPath,
                        i = e.objectName,
                        n = e.propertyName;
                    let r = e.propertyIndex;
                    if (t || (t = Pu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (i) {
                        let n = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === n) {
                                        n = e;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[i]
                        }
                        if (void 0 !== n) {
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[n]
                        }
                    }
                    const s = t[n];
                    if (void 0 === s) {
                        const i = e.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
                    }
                    let a = this.Versioning.None;
                    this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                        }
                        o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            Pu.Composite = class {
                constructor(t, e, i) {
                    const n = i || Pu.parseTrackName(e);
                    this._targetGroup = t, this._bindings = t.subscribe_(e, n)
                }
                getValue(t, e) {
                    this.bind();
                    const i = this._targetGroup.nCachedObjects_,
                        n = this._bindings[i];
                    void 0 !== n && n.getValue(t, e)
                }
                setValue(t, e) {
                    const i = this._bindings;
                    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
                }
                bind() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                }
                unbind() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                }
            }, Pu.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, Pu.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, Pu.prototype.GetterByBindingType = [Pu.prototype._getValue_direct, Pu.prototype._getValue_array, Pu.prototype._getValue_arrayElement, Pu.prototype._getValue_toArray], Pu.prototype.SetterByBindingTypeAndVersioning = [
                [Pu.prototype._setValue_direct, Pu.prototype._setValue_direct_setNeedsUpdate, Pu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [Pu.prototype._setValue_array, Pu.prototype._setValue_array_setNeedsUpdate, Pu.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [Pu.prototype._setValue_arrayElement, Pu.prototype._setValue_arrayElement_setNeedsUpdate, Pu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [Pu.prototype._setValue_fromArray, Pu.prototype._setValue_fromArray_setNeedsUpdate, Pu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class zu {
                constructor(t, e, i = null, n = e.blendMode) {
                    this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
                    const r = e.tracks,
                        s = r.length,
                        a = new Array(s),
                        o = {
                            endingStart: vi,
                            endingEnd: vi
                        };
                    for (let l = 0; l !== s; ++l) {
                        const t = r[l].createInterpolant(null);
                        a[l] = t, t.settings = o
                    }
                    this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(t) {
                    return this._startTime = t, this
                }
                setLoop(t, e) {
                    return this.loop = t, this.repetitions = e, this
                }
                setEffectiveWeight(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1)
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0)
                }
                crossFadeFrom(t, e, i) {
                    if (t.fadeOut(e), this.fadeIn(e), i) {
                        const i = this._clip.duration,
                            n = t._clip.duration,
                            r = n / i,
                            s = i / n;
                        t.warp(1, r, e), this.warp(s, 1, e)
                    }
                    return this
                }
                crossFadeTo(t, e, i) {
                    return t.crossFadeFrom(this, e, i)
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                setEffectiveTimeScale(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                }
                syncWith(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                }
                warp(t, e, i) {
                    const n = this._mixer,
                        r = n.time,
                        s = this.timeScale;
                    let a = this._timeScaleInterpolant;
                    null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    const o = a.parameterPositions,
                        l = a.sampleValues;
                    return o[0] = r, o[1] = r + i, l[0] = t / s, l[1] = e / s, this
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(t, e, i, n) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const r = this._startTime;
                    if (null !== r) {
                        const n = (t - r) * i;
                        if (n < 0 || 0 === i) return;
                        this._startTime = null, e = i * n
                    }
                    e *= this._updateTimeScale(t);
                    const s = this._updateTime(e),
                        a = this._updateWeight(t);
                    if (a > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        if (2501 === this.blendMode)
                            for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(s), e[i].accumulateAdditive(a);
                        else
                            for (let i = 0, r = t.length; i !== r; ++i) t[i].evaluate(s), e[i].accumulate(n, a)
                    }
                }
                _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        const i = this._weightInterpolant;
                        if (null !== i) {
                            const n = i.evaluate(t)[0];
                            e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e, e
                }
                _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        const i = this._timeScaleInterpolant;
                        if (null !== i) {
                            e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                    }
                    return this._effectiveTimeScale = e, e
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        i = this.loop;
                    let n = this.time + t,
                        r = this._loopCount;
                    const s = 2202 === i;
                    if (0 === t) return -1 === r ? n : s && 1 === (1 & r) ? e - n : n;
                    if (2200 === i) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (n >= e) n = e;
                            else {
                                if (!(n < 0)) {
                                    this.time = n;
                                    break t
                                }
                                n = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = n,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), n >= e || n < 0) {
                            const i = Math.floor(n / e);
                            n -= e * i, r += Math.abs(i);
                            const a = this.repetitions - r;
                            if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (1 === a) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, s)
                                } else this._setEndings(!1, !1, s);
                                this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: i
                                })
                            }
                        } else this.time = n;
                        if (s && 1 === (1 & r)) return e - n
                    }
                    return n
                }
                _setEndings(t, e, i) {
                    const n = this._interpolantSettings;
                    i ? (n.endingStart = _i, n.endingEnd = _i) : (n.endingStart = t ? this.zeroSlopeAtStart ? _i : vi : bi, n.endingEnd = e ? this.zeroSlopeAtEnd ? _i : vi : bi)
                }
                _scheduleFading(t, e, i) {
                    const n = this._mixer,
                        r = n.time;
                    let s = this._weightInterpolant;
                    null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
                    const a = s.parameterPositions,
                        o = s.sampleValues;
                    return a[0] = r, o[0] = e, a[1] = r + t, o[1] = i, this
                }
            }(class extends zi {
                constructor(t) {
                    super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(t, e) {
                    const i = t._localRoot || this._root,
                        n = t._clip.tracks,
                        r = n.length,
                        s = t._propertyBindings,
                        a = t._interpolants,
                        o = i.uuid,
                        l = this._bindingsByRootAndName;
                    let h = l[o];
                    void 0 === h && (h = {}, l[o] = h);
                    for (let c = 0; c !== r; ++c) {
                        const t = n[c],
                            r = t.name;
                        let l = h[r];
                        if (void 0 !== l) ++l.referenceCount, s[c] = l;
                        else {
                            if (l = s[c], void 0 !== l) {
                                null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, o, r));
                                continue
                            }
                            const n = e && e._propertyBindings[c].binding.parsedPath;
                            l = new _u(Pu.create(i, r, n), t.ValueTypeName, t.getValueSize()), ++l.referenceCount, this._addInactiveBinding(l, o, r), s[c] = l
                        }
                        a[c].resultBuffer = l.buffer
                    }
                }
                _activateAction(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                i = t._clip.uuid,
                                n = this._actionsByClip[i];
                            this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                        }
                        const e = t._propertyBindings;
                        for (let t = 0, i = e.length; t !== i; ++t) {
                            const i = e[t];
                            0 === i.useCount++ && (this._lendBinding(i), i.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                }
                _deactivateAction(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let t = 0, i = e.length; t !== i; ++t) {
                            const i = e[t];
                            0 === --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(t)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                }
                _addInactiveAction(t, e, i) {
                    const n = this._actions,
                        r = this._actionsByClip;
                    let s = r[e];
                    if (void 0 === s) s = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, r[e] = s;
                    else {
                        const e = s.knownActions;
                        t._byClipCacheIndex = e.length, e.push(t)
                    }
                    t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t
                }
                _removeInactiveAction(t) {
                    const e = this._actions,
                        i = e[e.length - 1],
                        n = t._cacheIndex;
                    i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                    const r = t._clip.uuid,
                        s = this._actionsByClip,
                        a = s[r],
                        o = a.knownActions,
                        l = o[o.length - 1],
                        h = t._byClipCacheIndex;
                    l._byClipCacheIndex = h, o[h] = l, o.pop(), t._byClipCacheIndex = null;
                    delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t)
                }
                _removeInactiveBindingsForAction(t) {
                    const e = t._propertyBindings;
                    for (let i = 0, n = e.length; i !== n; ++i) {
                        const t = e[i];
                        0 === --t.referenceCount && this._removeInactiveBinding(t)
                    }
                }
                _lendAction(t) {
                    const e = this._actions,
                        i = t._cacheIndex,
                        n = this._nActiveActions++,
                        r = e[n];
                    t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                }
                _takeBackAction(t) {
                    const e = this._actions,
                        i = t._cacheIndex,
                        n = --this._nActiveActions,
                        r = e[n];
                    t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                }
                _addInactiveBinding(t, e, i) {
                    const n = this._bindingsByRootAndName,
                        r = this._bindings;
                    let s = n[e];
                    void 0 === s && (s = {}, n[e] = s), s[i] = t, t._cacheIndex = r.length, r.push(t)
                }
                _removeInactiveBinding(t) {
                    const e = this._bindings,
                        i = t.binding,
                        n = i.rootNode.uuid,
                        r = i.path,
                        s = this._bindingsByRootAndName,
                        a = s[n],
                        o = e[e.length - 1],
                        l = t._cacheIndex;
                    o._cacheIndex = l, e[l] = o, e.pop(), delete a[r], 0 === Object.keys(a).length && delete s[n]
                }
                _lendBinding(t) {
                    const e = this._bindings,
                        i = t._cacheIndex,
                        n = this._nActiveBindings++,
                        r = e[n];
                    t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                }
                _takeBackBinding(t) {
                    const e = this._bindings,
                        i = t._cacheIndex,
                        n = --this._nActiveBindings,
                        r = e[n];
                    t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                }
                _lendControlInterpolant() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let i = t[e];
                    return void 0 === i && (i = new Tc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i
                }
                _takeBackControlInterpolant(t) {
                    const e = this._controlInterpolants,
                        i = t.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        r = e[n];
                    t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
                }
                clipAction(t, e, i) {
                    const n = e || this._root,
                        r = n.uuid;
                    let s = "string" === typeof t ? Oc.findByName(n, t) : t;
                    const a = null !== s ? s.uuid : t,
                        o = this._actionsByClip[a];
                    let l = null;
                    if (void 0 === i && (i = null !== s ? s.blendMode : Mi), void 0 !== o) {
                        const t = o.actionByRoot[r];
                        if (void 0 !== t && t.blendMode === i) return t;
                        l = o.knownActions[0], null === s && (s = l._clip)
                    }
                    if (null === s) return null;
                    const h = new zu(this, s, e, i);
                    return this._bindAction(h, l), this._addInactiveAction(h, a, r), h
                }
                existingAction(t, e) {
                    const i = e || this._root,
                        n = i.uuid,
                        r = "string" === typeof t ? Oc.findByName(i, t) : t,
                        s = r ? r.uuid : t,
                        a = this._actionsByClip[s];
                    return void 0 !== a && a.actionByRoot[n] || null
                }
                stopAllAction() {
                    const t = this._actions;
                    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                    return this
                }
                update(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        i = this._nActiveActions,
                        n = this.time += t,
                        r = Math.sign(t),
                        s = this._accuIndex ^= 1;
                    for (let l = 0; l !== i; ++l) {
                        e[l]._update(n, t, r, s)
                    }
                    const a = this._bindings,
                        o = this._nActiveBindings;
                    for (let l = 0; l !== o; ++l) a[l].apply(s);
                    return this
                }
                setTime(t) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(t)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(t) {
                    const e = this._actions,
                        i = t.uuid,
                        n = this._actionsByClip,
                        r = n[i];
                    if (void 0 !== r) {
                        const t = r.knownActions;
                        for (let i = 0, n = t.length; i !== n; ++i) {
                            const n = t[i];
                            this._deactivateAction(n);
                            const r = n._cacheIndex,
                                s = e[e.length - 1];
                            n._cacheIndex = null, n._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(n)
                        }
                        delete n[i]
                    }
                }
                uncacheRoot(t) {
                    const e = t.uuid,
                        i = this._actionsByClip;
                    for (const r in i) {
                        const t = i[r].actionByRoot[e];
                        void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
                    }
                    const n = this._bindingsByRootAndName[e];
                    if (void 0 !== n)
                        for (const r in n) {
                            const t = n[r];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                }
                uncacheAction(t, e) {
                    const i = this.existingAction(t, e);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
            }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
            class Du {
                constructor(t) {
                    "string" === typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                }
                clone() {
                    return new Du(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }(class extends pl {
                constructor(t, e, i = 1) {
                    super(t, e), this.meshPerAttribute = i
                }
                copy(t) {
                    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                }
                clone(t) {
                    const e = super.clone(t);
                    return e.meshPerAttribute = this.meshPerAttribute, e
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                }
            }).prototype.isInstancedInterleavedBuffer = !0;
            const Iu = new Vi;
            class Nu {
                constructor(t = new Vi(1 / 0, 1 / 0), e = new Vi(-1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const i = Iu.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return Iu.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            Nu.prototype.isBox2 = !0;
            const Ou = new fn,
                Bu = new qn,
                Hu = new qn;

            function Uu(t) {
                const e = [];
                !0 === t.isBone && e.push(t);
                for (let i = 0; i < t.children.length; i++) e.push.apply(e, Uu(t.children[i]));
                return e
            }
            const Fu = new ArrayBuffer(4),
                ku = (new Float32Array(Fu), new Uint32Array(Fu), new Uint32Array(512)),
                Vu = new Uint32Array(512);
            for (let nd = 0; nd < 256; ++nd) {
                const t = nd - 127;
                t < -27 ? (ku[nd] = 0, ku[256 | nd] = 32768, Vu[nd] = 24, Vu[256 | nd] = 24) : t < -14 ? (ku[nd] = 1024 >> -t - 14, ku[256 | nd] = 1024 >> -t - 14 | 32768, Vu[nd] = -t - 1, Vu[256 | nd] = -t - 1) : t <= 15 ? (ku[nd] = t + 15 << 10, ku[256 | nd] = t + 15 << 10 | 32768, Vu[nd] = 13, Vu[256 | nd] = 13) : t < 128 ? (ku[nd] = 31744, ku[256 | nd] = 64512, Vu[nd] = 24, Vu[256 | nd] = 24) : (ku[nd] = 31744, ku[256 | nd] = 64512, Vu[nd] = 13, Vu[256 | nd] = 13)
            }
            const Gu = new Uint32Array(2048),
                Wu = new Uint32Array(64),
                ju = new Uint32Array(64);
            for (let nd = 1; nd < 1024; ++nd) {
                let t = nd << 13,
                    e = 0;
                for (; 0 === (8388608 & t);) t <<= 1, e -= 8388608;
                t &= -8388609, e += 947912704, Gu[nd] = t | e
            }
            for (let nd = 1024; nd < 2048; ++nd) Gu[nd] = 939524096 + (nd - 1024 << 13);
            for (let nd = 1; nd < 31; ++nd) Wu[nd] = nd << 23;
            Wu[31] = 1199570944, Wu[32] = 2147483648;
            for (let nd = 33; nd < 63; ++nd) Wu[nd] = 2147483648 + (nd - 32 << 23);
            Wu[63] = 3347054592;
            for (let nd = 1; nd < 64; ++nd) 32 !== nd && (ju[nd] = 1024);
            uh.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(uh.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Ph.prototype.fromPoints = function(t) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            };
            (class extends eh {
                constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
                    i = new nn(i), n = new nn(n);
                    const r = e / 2,
                        s = t / e,
                        a = t / 2,
                        o = [],
                        l = [];
                    for (let c = 0, u = 0, d = -a; c <= e; c++, d += s) {
                        o.push(-a, 0, d, a, 0, d), o.push(d, 0, -a, d, 0, a);
                        const t = c === r ? i : n;
                        t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3
                    }
                    const h = new jr;
                    h.setAttribute("position", new Br(o, 3)), h.setAttribute("color", new Br(l, 3));
                    super(h, new ql({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
            }).prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, class extends eh {
                constructor(t) {
                    const e = Uu(t),
                        i = new jr,
                        n = [],
                        r = [],
                        s = new nn(0, 0, 1),
                        a = new nn(0, 1, 0);
                    for (let o = 0; o < e.length; o++) {
                        const t = e[o];
                        t.parent && t.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                    }
                    i.setAttribute("position", new Br(n, 3)), i.setAttribute("color", new Br(r, 3));
                    super(i, new ql({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(t) {
                    const e = this.bones,
                        i = this.geometry,
                        n = i.getAttribute("position");
                    Hu.copy(this.root.matrixWorld).invert();
                    for (let r = 0, s = 0; r < e.length; r++) {
                        const t = e[r];
                        t.parent && t.parent.isBone && (Bu.multiplyMatrices(Hu, t.matrixWorld), Ou.setFromMatrixPosition(Bu), n.setXYZ(s, Ou.x, Ou.y, Ou.z), Bu.multiplyMatrices(Hu, t.parent.matrixWorld), Ou.setFromMatrixPosition(Bu), n.setXYZ(s + 1, Ou.x, Ou.y, Ou.z), s += 2)
                    }
                    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                }
            }.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            };
            kc.prototype.extractUrlBase = function(t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), du.extractUrlBase(t)
            }, kc.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            };
            Nu.prototype.center = function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Nu.prototype.empty = function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Nu.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, Nu.prototype.size = function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }, xn.prototype.center = function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, xn.prototype.empty = function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, xn.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, xn.prototype.isIntersectionSphere = function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, xn.prototype.size = function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }, ir.prototype.toVector3 = function() {
                console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
            }, Bn.prototype.empty = function() {
                return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Cs.prototype.setFromMatrix = function(t) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
            }, Gi.prototype.flattenToArrayOffset = function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, Gi.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, Gi.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }, Gi.prototype.applyToBufferAttribute = function(t) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, Gi.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }, Gi.prototype.getInverse = function(t) {
                return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
            }, qn.prototype.extractPosition = function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            }, qn.prototype.flattenToArrayOffset = function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, qn.prototype.getPosition = function() {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new fn).setFromMatrixColumn(this, 3)
            }, qn.prototype.setRotationFromQuaternion = function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            }, qn.prototype.multiplyToArray = function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }, qn.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, qn.prototype.multiplyVector4 = function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, qn.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }, qn.prototype.rotateAxis = function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            }, qn.prototype.crossVector = function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, qn.prototype.translate = function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, qn.prototype.rotateX = function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, qn.prototype.rotateY = function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, qn.prototype.rotateZ = function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, qn.prototype.rotateByAxis = function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, qn.prototype.applyToBufferAttribute = function(t) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, qn.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }, qn.prototype.makeFrustum = function(t, e, i, n, r, s) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, s)
            }, qn.prototype.getInverse = function(t) {
                return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
            }, Es.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, mn.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, mn.prototype.inverse = function() {
                return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
            }, jn.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, jn.prototype.isIntersectionPlane = function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            }, jn.prototype.isIntersectionSphere = function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, Cr.prototype.area = function() {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            }, Cr.prototype.barycoordFromPoint = function(t, e) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
            }, Cr.prototype.midpoint = function(t) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
            }, Cr.prototypenormal = function(t) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
            }, Cr.prototype.plane = function(t) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
            }, Cr.barycoordFromPoint = function(t, e, i, n, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Cr.getBarycoord(t, e, i, n, r)
            }, Cr.normal = function(t, e, i, n) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Cr.getNormal(t, e, i, n)
            }, Dh.prototype.extractAllPoints = function(t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            }, Dh.prototype.extrude = function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new lc(this, t)
            }, Dh.prototype.makeGeometry = function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new uc(this, t)
            }, Vi.prototype.fromAttribute = function(t, e, i) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }, Vi.prototype.distanceToManhattan = function(t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, Vi.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, fn.prototype.setEulerFromRotationMatrix = function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, fn.prototype.setEulerFromQuaternion = function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, fn.prototype.getPositionFromMatrix = function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            }, fn.prototype.getScaleFromMatrix = function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            }, fn.prototype.getColumnFromMatrix = function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            }, fn.prototype.applyProjection = function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            }, fn.prototype.fromAttribute = function(t, e, i) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }, fn.prototype.distanceToManhattan = function(t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, fn.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, cn.prototype.fromAttribute = function(t, e, i) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }, cn.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, yr.prototype.getChildByName = function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            }, yr.prototype.renderDepth = function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, yr.prototype.translate = function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }, yr.prototype.getWorldRotation = function() {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }, yr.prototype.applyMatrix = function(t) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
            }, Object.defineProperties(yr.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), hs.prototype.setDrawMode = function() {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }, Object.defineProperties(hs.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Bl.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, ys.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Xc.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(Ir.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Ri
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Ri)
                    }
                }
            }), Ir.prototype.setDynamic = function(t) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Ri : Ci), this
            }, Ir.prototype.copyIndicesArray = function() {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }, Ir.prototype.setArray = function() {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, jr.prototype.addIndex = function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            }, jr.prototype.addAttribute = function(t, e) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ir(arguments[1], arguments[2])))
            }, jr.prototype.addDrawCall = function(t, e, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            }, jr.prototype.clearDrawCalls = function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, jr.prototype.computeOffsets = function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }, jr.prototype.removeAttribute = function(t) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
            }, jr.prototype.applyMatrix = function(t) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
            }, Object.defineProperties(jr.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), pl.prototype.setDynamic = function(t) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Ri : Ci), this
            }, pl.prototype.setArray = function() {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, lc.prototype.getArrays = function() {
                console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
            }, lc.prototype.addShapeList = function() {
                console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
            }, lc.prototype.addShape = function() {
                console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
            }, dl.prototype.dispose = function() {
                console.error("THREE.Scene: .dispose() has been removed.")
            }, Du.prototype.onUpdate = function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }, Object.defineProperties(Lr.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new nn
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                    }
                },
                vertexTangents: {
                    get: function() {
                        console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                    },
                    set: function() {
                        console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                    }
                }
            }), Object.defineProperties(fs.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), hl.prototype.clearTarget = function(t, e, i, n) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
            }, hl.prototype.animate = function(t) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
            }, hl.prototype.getCurrentRenderTarget = function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            }, hl.prototype.getMaxAnisotropy = function() {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            }, hl.prototype.getPrecision = function() {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            }, hl.prototype.resetGLState = function() {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            }, hl.prototype.supportsFloatTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, hl.prototype.supportsHalfFloatTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, hl.prototype.supportsStandardDerivatives = function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, hl.prototype.supportsCompressedTextureS3TC = function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, hl.prototype.supportsCompressedTexturePVRTC = function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, hl.prototype.supportsBlendMinMax = function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, hl.prototype.supportsVertexTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, hl.prototype.supportsInstancedArrays = function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, hl.prototype.enableScissorTest = function(t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            }, hl.prototype.initMaterial = function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, hl.prototype.addPrePlugin = function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, hl.prototype.addPostPlugin = function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, hl.prototype.updateShadowMap = function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }, hl.prototype.setFaceCulling = function() {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            }, hl.prototype.allocTextureUnit = function() {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            }, hl.prototype.setTexture = function() {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            }, hl.prototype.setTexture2D = function() {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            }, hl.prototype.setTextureCube = function() {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            }, hl.prototype.getActiveMipMapLevel = function() {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }, Object.defineProperties(hl.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Si : wi
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                },
                gammaFactor: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                    }
                }
            }), Object.defineProperties(Ko.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            });
            Object.defineProperties(un.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), vu.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                const e = this;
                return (new gu).load(t, (function(t) {
                    e.setBuffer(t)
                })), this
            }, vs.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            }, vs.prototype.clear = function(t, e, i, n) {
                return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, i, n)
            }, sn.crossOrigin = void 0, sn.loadTexture = function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const r = new qc;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(t, i, void 0, n);
                return e && (s.mapping = e), s
            }, sn.loadTextureCube = function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const r = new jc;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(t, i, void 0, n);
                return e && (s.mapping = e), s
            }, sn.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, sn.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: ke
                }
            })), "undefined" !== typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ke);
            class qu extends Sc {
                constructor(t, e, i, n) {
                    super(t, e, i, n)
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        r = t * n * 3 + n;
                    for (let s = 0; s !== n; s++) e[s] = i[r + s];
                    return e
                }
            }
            qu.prototype.beforeStart_ = qu.prototype.copySampleValue_, qu.prototype.afterEnd_ = qu.prototype.copySampleValue_, qu.prototype.interpolate_ = function(t, e, i, n) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = 2 * a,
                    l = 3 * a,
                    h = n - e,
                    c = (i - e) / h,
                    u = c * c,
                    d = u * c,
                    p = t * l,
                    m = p - l,
                    f = -2 * d + 3 * u,
                    g = d - u,
                    y = 1 - f,
                    x = g - u + c;
                for (let v = 0; v !== a; v++) {
                    const t = s[m + v + a],
                        e = s[m + v + o] * h,
                        i = s[p + v + a],
                        n = s[p + v] * h;
                    r[v] = y * t + x * e + f * i + g * n
                }
                return r
            };
            new mn;
            Int8Array, Uint8Array, Int16Array, Uint16Array, Uint32Array, Float32Array;

            function Xu(t, e, i, n, r, s, a) {
                try {
                    var o = t[s](a),
                        l = o.value
                } catch (h) {
                    return void i(h)
                }
                o.done ? e(l) : Promise.resolve(l).then(n, r)
            }

            function Yu() {
                var t = (0, a.useRef)(),
                    e = (0, a.useState)(),
                    i = e[0],
                    r = e[1],
                    l = (0, a.useState)(),
                    h = l[0],
                    c = l[1],
                    u = (0, a.useState)(new dl)[0],
                    d = (0, a.useState)(),
                    p = d[0],
                    m = d[1],
                    f = (0, a.useState)(!0),
                    g = (f[0], f[1]),
                    y = (0, a.useState)(),
                    x = y[0],
                    v = y[1],
                    _ = (0, a.useState)(new fn(0, 1.5, 0))[0],
                    b = function() {
                        var e = t.current;
                        if (e && x) {
                            var i = e.clientWidth,
                                n = e.clientHeight;
                            x.setSize(i, n), p.aspect = i / n, p.updateProjectionMatrix()
                        }
                    },
                    M = function() {
                        if (t.current && p && h) {
                            var e = window.pageYOffset;
                            p.position.y = -.004 * e, h.position.z = e >= 700 ? (e - 700) / 75 : 0
                        }
                    };
                return (0, a.useEffect)((function() {
                    return window.addEventListener("resize", b, !1), window.addEventListener("scroll", M, !1),
                        function() {
                            window.removeEventListener("resize", b, !1), window.removeEventListener("scroll", M, !1)
                        }
                }), [x, h, b]), (0, a.useEffect)((function() {
                    var e;
                    return (e = s().mark((function e() {
                            var n, a, o, l, d, p, f, g, y, b, M, w;
                            return s().wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        (n = t.current) && !x && (a = n.clientHeight, o = n.clientWidth, (l = new hl({
                                            alpha: !0
                                        })).physicallyCorrectLights = !0, l.outputEncoding = Si, l.toneMapping = 4, l.toneMappingExposure = 1, l.setSize(o, a), l.setPixelRatio(Math.min(window.devicePixelRatio, 2)), n.appendChild(l.domElement), v(l), d = new ys(75, o / a, .01, 100), m(d), d.position.set(0, 0, 0), u.add(d), p = new lu(16777215, 2), u.add(p), (f = new ou(16777215, 4)).position.set(10, -5, 7), u.add(f), g = new cc(.1, 0), y = new _c, Fe(g, y, 1e3, 80, "/texture/texture.png", u), r(i), c(h), b = new yu, M = 0, (w = function() {
                                            var t, e = b.getElapsedTime(),
                                                n = e - M;
                                            M = e, i && i.update(10 * n), h && (t = 10 * n, h.rotation.y += t / 25), d.lookAt(_), l.render(u, d), requestAnimationFrame(w)
                                        })());
                                    case 2:
                                    case "end":
                                        return e.stop()
                                }
                            }), e)
                        })), function() {
                            var t = this,
                                i = arguments;
                            return new Promise((function(n, r) {
                                var s = e.apply(t, i);

                                function a(t) {
                                    Xu(s, n, r, a, o, "next", t)
                                }

                                function o(t) {
                                    Xu(s, n, r, a, o, "throw", t)
                                }
                                a(void 0)
                            }))
                        })(),
                        function() {
                            cancelAnimationFrame(requestAnimationFrame(RAF)), x.dispose()
                        }
                }), []), (0, a.useEffect)((function() {
                    i && g(!1)
                }), [i]), (0, a.useEffect)((function() {
                    if (t.current && p && h) {
                        var e = window.pageYOffset;
                        p.position.y = -.004 * e, h.position.z = e >= 700 ? (e - 700) / 75 : 0
                    }
                }), [h, p]), (0, n.jsx)(o, {
                    ref: t
                })
            }
            i(1474);
            var Ju = i(7735);
            Ju.Xou, Ju.YnA, Ju.wVw, Ju.HA2;

            function Zu() {
                return (0, n.jsx)("footer", {
                    className: "relative bg-white w-full",
                    children: (0, n.jsx)("div", {
                        className: "flex flex-col items-center z-[9999] pb-2 sm:pb-2 p-2 sm:p-8 relative bg-white w-full",
                        children: (0, n.jsxs)("div", {
                            className: "w-full justify-center items-center max-w-7xl flex flex-col p-2 sm:p-8",
                            children: [(0, n.jsx)("h1", {
                                className: "text-3xl font-bold text-center",
                                style: {
                                    marginTop: -20
                                },
                                children: "Thank you for visiting my portfolio!"
                            }), (0, n.jsx)("img", {
                                alt: "astronaut",
                                className: "order-2 md:order-1",
                                width: 280,
                                src: "astronaut1.jpg"
                            }), (0, n.jsxs)("a", {
                                className: "buyButton",
                                target: "_blank",
                                href: "https://www.buymeacoffee.com/",
                                style: {
                                    marginTop: 40
                                },
                                children: [(0, n.jsx)("img", {
                                    className: "coffeeImage",
                                    src: "https://cdn.buymeacoffee.com/buttons/bmc-new-btn-logo.svg",
                                    alt: "Buy me a coffee"
                                }), (0, n.jsx)("span", {
                                    className: "coffeeButtonText",
                                    children: "Buy me a coffee"
                                })]
                            })]
                        })
                    })
                })
            }
            var Qu = i(6261);

            function Ku() {
                var t = (0, a.useRef)(),
                    e = (0, a.useRef)(),
                    i = (0, a.useState)(!1),
                    r = i[0],
                    s = i[1],
                    o = (0, a.useState)(0),
                    l = o[0],
                    h = o[1],
                    c = function() {
                        r ? (t.current.classList.remove("menuopen"), s(!1)) : (t.current.classList.add("menuopen"), s(!0))
                    },
                    u = function() {
                        if (e) {
                            var i = window.scrollY;
                            l > i ? e.current.style.top = "0" : (t.current.classList.remove("menuopen"), s(!1), e.current.style.top = "-74px"), h(i)
                        }
                    };
                return (0, a.useEffect)((function() {
                    return document.addEventListener("scroll", u, !1),
                        function() {
                            document.removeEventListener("scroll", u, !1)
                        }
                }), [u]), (0, n.jsx)("nav", {
                    ref: e,
                    className: "flex fixed w-full text-white z-[10010] transition-all",
                    children: (0, n.jsxs)("div", {
                        className: "w-full justify-center flex p-4 bg-black bg-opacity-75 border-b-[1px] ".concat(r ? "h-[450px] md:h-fit" : "h-[69px]", " transition-all"),
                        children: [(0, n.jsxs)("div", {
                            className: "max-w-7xl w-full justify-between xl:justify-around flex-row hidden md:flex",
                            children: [(0, n.jsx)("div", {
                                className: "flex font-nav text-3xl font-extrabold",
                                children: (0, n.jsxs)("a", {
                                    href: "#",
                                    className: "cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    children: [(0, n.jsx)("span", {
                                        children: "<"
                                    }), (0, n.jsx)("span", {
                                        children: "USHA SRI"
                                    }), (0, n.jsx)("span", {
                                        className: "pl-2",
                                        children: "/>"
                                    })]
                                })
                            }), (0, n.jsxs)("div", {
                                className: "flex justify-center items-center font-extrabold font-home",
                                children: [(0, n.jsx)(Qu.rU, {
                                    to: "home",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "Home"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "about",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "About"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "skills",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "Skills"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "experience",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "experience"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "achievements",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "achievements"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "projects",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "projects"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "education",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "education"
                                }), (0, n.jsx)(Qu.rU, {
                                    to: "contact",
                                    className: "pr-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "contact"
                                })]
                            })]
                        }), (0, n.jsxs)("div", {
                            className: "md:hidden w-full flex flex-col justify-between items-center ".concat(r ? "h-[275px]" : "h-[35px]"),
                            children: [(0, n.jsxs)("div", {
                                className: "flex w-full justify-between items-center",
                                children: [(0, n.jsxs)("a", {
                                    href: "#",
                                    className: "cursor-pointer font-extrabold font-nav text-xl hover:text-[#ddd] hover:scale-110 transition-all whitespace-nowrap",
                                    children: [(0, n.jsx)("span", {
                                        children: "<"
                                    }), (0, n.jsx)("span", {
                                        children: "Usha Sri"
                                    }), (0, n.jsx)("span", {
                                        className: "pl-2",
                                        children: "/>"
                                    })]
                                }), (0, n.jsx)("div", {
                                    ref: t,
                                    onClick: c,
                                    className: "py-4 mx-5 cursor-pointer",
                                    children: (0, n.jsx)("div", {
                                        className: "myBurguer"
                                    })
                                })]
                            }), (0, n.jsxs)("div", {
                                className: "flex flex-col text-center font-extrabold font-home ".concat(r ? "" : "opacity-0 pointer-events-none z-10", "  transition-all"),
                                children: [(0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "home",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "Home"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "about",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "About"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "skills",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "Skills"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "experience",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "experience"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "achievements",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "achievements"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "projects",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "projects"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "education",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "education"
                                }), (0, n.jsx)(Qu.rU, {
                                    onClick: c,
                                    to: "contact",
                                    className: "p-3 cursor-pointer hover:text-[#ddd] hover:scale-110 transition-all",
                                    smooth: !0,
                                    delay: 0,
                                    duration: 100,
                                    isDynamic: !0,
                                    children: "contact"
                                })]
                            })]
                        })]
                    })
                })
            }

            function $u(t) {
                var e = t.children;
                return (0, n.jsxs)(n.Fragment, {
                    children: [(0, n.jsx)(Ku, {}), (0, n.jsxs)("div", {
                        className: "min-h-screen w-full",
                        children: [(0, n.jsx)(Yu, {}), (0, n.jsxs)("main", {
                            className: "absolute w-full bg-black",
                            children: [e, (0, n.jsx)(Zu, {})]
                        })]
                    })]
                })
            }

            function td(t, e, i) {
                return e in t ? Object.defineProperty(t, e, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = i, t
            }

            function ed(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = null != arguments[e] ? arguments[e] : {},
                        n = Object.keys(i);
                    "function" === typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter((function(t) {
                        return Object.getOwnPropertyDescriptor(i, t).enumerable
                    })))), n.forEach((function(e) {
                        td(t, e, i[e])
                    }))
                }
                return t
            }
            var id = function(t) {
                var e = t.Component,
                    i = t.pageProps;
                return (0, n.jsx)($u, {
                    children: (0, n.jsx)(e, ed({}, i))
                })
            }
        },
        6774: function() {},
        2703: function(t, e, i) {
            "use strict";
            var n = i(414);

            function r() {}

            function s() {}
            s.resetWarningCache = r, t.exports = function() {
                function t(t, e, i, r, s, a) {
                    if (a !== n) {
                        var o = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                        throw o.name = "Invariant Violation", o
                    }
                }

                function e() {
                    return t
                }
                t.isRequired = t;
                var i = {
                    array: t,
                    bigint: t,
                    bool: t,
                    func: t,
                    number: t,
                    object: t,
                    string: t,
                    symbol: t,
                    any: t,
                    arrayOf: e,
                    element: t,
                    elementType: t,
                    instanceOf: e,
                    node: t,
                    objectOf: e,
                    oneOf: e,
                    oneOfType: e,
                    shape: e,
                    exact: e,
                    checkPropTypes: s,
                    resetWarningCache: r
                };
                return i.PropTypes = i, i
            }
        },
        5697: function(t, e, i) {
            t.exports = i(2703)()
        },
        414: function(t) {
            "use strict";
            t.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
        },
        8357: function(t, e, i) {
            "use strict";
            i.d(e, {
                w_: function() {
                    return h
                }
            });
            var n = i(7294),
                r = {
                    color: void 0,
                    size: void 0,
                    className: void 0,
                    style: void 0,
                    attr: void 0
                },
                s = n.createContext && n.createContext(r),
                a = function() {
                    return a = Object.assign || function(t) {
                        for (var e, i = 1, n = arguments.length; i < n; i++)
                            for (var r in e = arguments[i]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                        return t
                    }, a.apply(this, arguments)
                },
                o = function(t, e) {
                    var i = {};
                    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
                    if (null != t && "function" === typeof Object.getOwnPropertySymbols) {
                        var r = 0;
                        for (n = Object.getOwnPropertySymbols(t); r < n.length; r++) e.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[r]) && (i[n[r]] = t[n[r]])
                    }
                    return i
                };

            function l(t) {
                return t && t.map((function(t, e) {
                    return n.createElement(t.tag, a({
                        key: e
                    }, t.attr), l(t.child))
                }))
            }

            function h(t) {
                return function(e) {
                    return n.createElement(c, a({
                        attr: a({}, t.attr)
                    }, e), l(t.child))
                }
            }

            function c(t) {
                var e = function(e) {
                    var i, r = t.attr,
                        s = t.size,
                        l = t.title,
                        h = o(t, ["attr", "size", "title"]),
                        c = s || e.size || "1em";
                    return e.className && (i = e.className), t.className && (i = (i ? i + " " : "") + t.className), n.createElement("svg", a({
                        stroke: "currentColor",
                        fill: "currentColor",
                        strokeWidth: "0"
                    }, e.attr, r, h, {
                        className: i,
                        style: a(a({
                            color: t.color || e.color
                        }, e.style), t.style),
                        height: c,
                        width: c,
                        xmlns: "http://www.w3.org/2000/svg"
                    }), l && n.createElement("title", null, l), t.children)
                };
                return void 0 !== s ? n.createElement(s.Consumer, null, (function(t) {
                    return e(t)
                })) : e(r)
            }
        },
        7735: function(t, e, i) {
            "use strict";
            i.d(e, {
                q$c: function() {
                    return r
                },
                H5g: function() {
                    return s
                },
                AmJ: function() {
                    return a
                },
                O1b: function() {
                    return o
                },
                HA2: function() {
                    return l
                },
                zS0: function() {
                    return h
                },
                pZu: function() {
                    return c
                },
                tkX: function() {
                    return u
                },
                PSn: function() {
                    return d
                },
                LIX: function() {
                    return p
                },
                vl3: function() {
                    return m
                },
                c9P: function() {
                    return f
                },
                n7M: function() {
                    return g
                },
                _jt: function() {
                    return y
                },
                t$b: function() {
                    return x
                },
                Xou: function() {
                    return v
                },
                u4B: function() {
                    return _
                },
                nB$: function() {
                    return b
                },
                Cul: function() {
                    return M
                },
                pNp: function() {
                    return w
                },
                PoL: function() {
                    return S
                },
                aHj: function() {
                    return E
                },
                zKo: function() {
                    return T
                },
                YnA: function() {
                    return A
                },
                CCE: function() {
                    return C
                },
                wVw: function() {
                    return R
                }
            });
            var n = i(8357);

            function r(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M5.223 17.905h6.76l1.731 3.047H0l4.815-8.344 2.018-3.494 1.733 3.002zm2.52-10.371L9.408 4.65l9.415 16.301h-3.334zm2.59-4.486h3.33L24 20.952h-3.334z"
                        }
                    }]
                })(t)
            }

            function s(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z"
                        }
                    }]
                })(t)
            }

            function a(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M24 18.588a1.529 1.529 0 01-1.895-.72l-3.45-4.771-.5-.667-4.003 5.444a1.466 1.466 0 01-1.802.708l5.158-6.92-4.798-6.251a1.595 1.595 0 011.9.666l3.576 4.83 3.596-4.81a1.435 1.435 0 011.788-.668L21.708 7.9l-2.522 3.283a.666.666 0 000 .994l4.804 6.412zM.002 11.576l.42-2.075c1.154-4.103 5.858-5.81 9.094-3.27 1.895 1.489 2.368 3.597 2.275 5.973H1.116C.943 16.447 4.005 19.009 7.92 17.7a4.078 4.078 0 002.582-2.876c.207-.666.548-.78 1.174-.588a5.417 5.417 0 01-2.589 3.957 6.272 6.272 0 01-7.306-.933 6.575 6.575 0 01-1.64-3.858c0-.235-.08-.455-.134-.666A88.33 88.33 0 010 11.577zm1.127-.286h9.654c-.06-3.076-2.001-5.258-4.59-5.278-2.882-.04-4.944 2.094-5.071 5.264z"
                        }
                    }]
                })(t)
            }

            function o(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M7.172 20.36c-.914-.72-1.89-1.41-2.556-2.38-1.402-1.712-2.482-3.694-3.22-5.777-.446-1.355-.6-2.808-1.174-4.11-.602-.944.103-1.978 1.138-2.28.46-.087 1.272-.522.293-.211-.878.644-.963-.585-.063-.662.615-.082.84-.585.63-1.037-.66-.43 1.6-.903.463-1.544C1.5 1.08 4.34.835 3.64 2.285 3.473 3.4 5.624 2.08 5.125 3.368c.507.619 1.9.14 1.865 1.009.74.05.993.672 1.687.72.72.325 2.022.58 2.266 1.39-.713.566-2.364-1.165-2.443.398.215 2.31.16 4.689 1.004 6.888.4 1.332 1.37 2.38 2.244 3.418.837 1.016 1.971 1.73 3.127 2.333 1.014.478 2.107.795 3.213.994.448-.343 1.24-1.617 1.938-1.08.033.604-1.388 1.263-.067 1.196.776-.234 1.314.6 1.953-.152.588.697 2.446-.446 2.027.98-.566.364-1.392.144-1.959.646-.935-.467-1.68.418-2.715.306a19.86 19.86 0 01-3.484.29c-1.912-.15-3.865-.214-5.684-.88-1.024-.297-2.023-.881-2.924-1.464zm1.615.7c1 .432 1.978.888 3.074 1.026 1.74.24 3.537.614 5.283.274-.79-.357-1.608.14-2.395-.255-.944.203-1.957-.052-2.917-.177-1.092-.486-2.27-.82-3.291-1.452-1.277-.466.66.598 1.005.685.798.453-.877-.233-1.114-.421-.668-.375-.754-.297-.066.084.139.08.276.166.42.235zm-1.904-1.346c.97.359-.004-.682-.45-.622-.196-.341-.751-.557-.36-.74-.704.244-.737-.93-1.07-.763-.744-.235-.29-1.07-1.176-1.58-.081-.54-.882-1.008-1.138-1.822-.113-.416-.905-1.613-.418-.5.414 1.072 1.143 1.99 1.75 2.907.47.873 1.027 1.786 1.885 2.33.29.278.568.703.977.79zM4.09 16.647c.033-.146.177.317 0 0zm3.954 3.497c.215-.096-.31-.12 0 0zm.526.192c-.054-.265-.24.148 0 0zm.66.275c.312-.3-.484-.188 0 0zm1.127.63c.191-.282-.61-.107 0 0zM8.19 19.728c.487-.315-.63-.004 0 0zm.494.246c-.014-.166-.176.075 0 0zm2.47 1.542c.397.25 2.32.55 1.115.103-.2.042-2.23-.574-1.116-.103zm-3.921-3.054c-.04-.167-.616-.185 0 0zm1.15.67c.3-.21-.621-.16 0 0zm.966.593c.43-.162-.696-.163 0 0zm-2.584-1.773c.466.358 1.88.046.714-.213-.53-.283-1.727-.476-.912.17zm3.24 1.978c.193-.33-.815-.19 0 0zm-.984-.783c1.14.323-.958-.72-.281-.118l.15.068.13.05zm1.973 1.14c1.08.01-.975-.147 0 0zm-4.644-2.96c-.042-.2-.266.018 0 0zm6.47 3.985c.028-.363-.353.27 0 0zm-4.63-2.856c-.064-.191-.336-.008 0 0zm-1.738-1.254c.62-.037-.848-.273 0 0zm-2.06-1.332c-.077-.297-.674-.534 0 0zm5.407 3.435c-.114-.13-.054.028 0 0zm3.366 2.065c-.01-.197-.183.075 0 0zm-3.664-2.373c.06-.255-.528-.077 0 0zm-2.506-1.592c.46-.05-.74-.311 0 0zm4.241 2.637c.718-.285-.7-.14 0 0zM9.03 18.545c.827.106-.985-.563-.181-.06zm2.876 1.768c.773-.462.518 1.082 1.311.13.782-.57-.675.707.29.103.696-.467 1.726.22 2.376.445.468-.023.923.405 1.403.145.923-.25-1.806-.37-1.09-.81-.845.245-1.47-.294-1.885-.835-.948-.22-2.044-.703-2.517-1.542-.192-.315.28.044-.166-.47-.57-.508-.856-1.085-1.24-1.702-.457-.244-.51-.963-.557-.024.004-.593-.553-.992-.688-.826-.002-.571.595-.285.176-.707-.09-.592-.386-1.21-.475-1.877-.138-.322-.02-1.011-.473-.282-.165.77-.055-.947.202-.38.337-.58-.12-.51-.14-.43.22-.488.14-1.18-.057-.916.117-.517.185-1.902-.175-1.656.218-.54.414-2.473-.534-1.736-.384.005-1.048.14-1.363.296.986.543-.1.196-.5.11-.052.502-.45.285-.946.29.793.098-.386.81-.841.534-.59.282.51.987.012 1.205.06.328-.905-.12-.83.64-.573-.241-.078.9.209.514.975.264.686.866.71 1.437-.158.333-.784-.783-.14-.731-.507-.827-.561-.3-.984.085-.1.028 1.079.547.34.803.65.1.668.67.8 1.03.39.407.31-.45.779.04-.296-.436-1.567-1.228-.544-.974-.005-.44-.185-.793.129-.784.31-.562-.325 1.387.375.672.193-.085.24-.563.59.045.505.498.182.858-.531.403.127.433.954.587.799 1.265.165.595.395.376.596.342.158.578.247.153.255-.123.72.155.552.58.778.88.497.224-.712-1.522.142-.526.898.81.337 1.15-.47 1.02.51-.041.675.69 1.313.664.582.277.975 1.34-.027.897-.348-.313-1.58-.7-.573-.104.929.43 1.665.688 2.561 1.227.64.458.918.982 1.16 1.086-.538.257-1.623-.206-.817-.348-.503-.091-1.068-.345-.587.28.41.343 1.45.306 1.637.345-.159.348-.43.376.006.403-.486.26.156.3.201.448zm-.994-2.808c-.296-.31-.373-.89-.053-.385.164.066.525.947.053.385zm3.238 2.057c.185-.011.006.14 0 0zm-3.706-2.816c-.01-.468.107.36 0 0zm-.322-.433c-.372-.72.47.204 0 0zm-3.9-2.692c.219-.06.108.374 0 0zm3.104 1.682c.134-.504.158.424 0 0zm-2.192-1.525c-.155-.278.323.26 0 0zm1.882.604c-.352-.79.25-.432.078.13zM5.77 12.217c-.158-.26-.418-1.02-.334-1.252.076.378.804 1.627.357.518-.494-.93.59.302.702.534.05.23-.305-.063-.064.478-.44-.617-.26.34-.661-.278zm-1.003-.691c.04-.603.23.413 0 0zm.45.155c.216-.455.366.634 0 0zm-1.084-.84c-.374-.37-.644-.713.017-.23.255.01-.566-.778.06-.25.66.12.327 1.082-.077.48zm.57-.015c.217-.215.115.212 0 0zm.35.113c-.328-.617.4.258 0 0zm-.697-.667c-1.086-.966 1.365.506.177.18zm3.11 1.808c-.47-.282-.123-1.984.037-.82.457-.148-.025.6.315.594-.053.473-.206.643-.35.226zm1.15.68c.048-.513.099.35 0 0zm-.2-.198c.054-.22.007.258 0 0zM4.57 9.955c-.697-.963 2.027.973.447.244-.165-.043-.364-.06-.447-.244zm2.216 1.175c-.066-.81.147.134 0 0zm1.682 1.079c.13-.462.01.305 0 0zM4.676 9.587c.415-.088 1.718.729.52.234-.132-.148-.416-.08-.52-.234zm3.56 1.775c.044-.83.248-.495.002.118zM4.985 9.299c.169-.248-.45-1.12.089-.313.232.185.672.31.283.387.61.539-.15.146-.372-.074zm3.075 1.804c.117-.944.103.553 0 0zM4.632 8.427c.129-.055.068.172 0 0zm.802.478c.206-.434.38.483 0 0zm2.263 1.259c-.002-.167.043.242 0 0zm-.131-.29c-.314-.776.292.41 0 0zm-.193-.51c-.053-.32.18.404 0 0zm.314-.51c-.216-.38.272-1.673.326-.87-.227.625-.065.975.093.136.293-.66-.063 1.303-.42.735zm.322-1.923c.094-.115.02.139 0 0zM7.47 17.544c-.128-.111.016.07 0 0zm1.11.56c.615.16.612-.095.055-.17-.3-.28-1.246-.575-.4-.035.057.142.235.139.344.206zM6.389 16.65c.34.253 1.28.719.484.096.269-.312-.514-.478-.254-.686-.66-.404-.52-.368-.058-.356-.794-.354.114-.328.07-.51-.305-.06-1.52-.54-.804.04-.726-.37-.173.138-.392.084-.743-.202.66.565-.118.375.425.337 1.146.864.18.357-.128.183.69.46.892.6zm1.16.667c1.41.454-.691-.556 0 0zm5.94 3.598c.02-.28-.193.24 0 0zm.611.257c.325-.315.013.503.54-.077.005-.415-.017-.66-.606-.156-.162.09-.234.473.066.233zm-9.692-6.087c-.1-.393-.7-.39 0 0zm.652.428c-.242-.402-.864-.364 0 0zm3.71 2.237c.362.32 1.662.236.44.04-.182-.27-1.151-.204-.44-.04zm5.097 3.149c.558-.468-.54.208 0 0zm1.16.796c.003-.15-.24.066 0 0zm.001-.21c.617-.654-.598.039 0 0zM2.805 13.743c-.526-.75-.327-1.088-.835-1.7-.096-.47-.87-1.533-.4-.406.43.659.558 1.679 1.235 2.106zm12.03 7.534c1.135-.734-.466-.32 0 0zm.866.34c.57-.488-.36-.102 0 0zM4.215 14.255c.163-.242-.42-.031 0 0zm11.305 7.129c.551-.355-.126-.3-.1.032zm-7.47-4.71c-.02-.24-.291.02 0 0zm.46.267c-.145-.297-.224.047 0 0zm7.894 4.684c.705-.51-.428-.098-.148.096zm-.27-.13c.574-.482-.607.213 0 0zm1.38.918c.386-.258-.469-.083 0 0zM4.57 14.08c.517.116 2.066 1.274 1.152.08-.468-.138-.187-1.283-.665-1.08.32.535.264.763-.41.426-.845-.413-.474.204-.31.374-.224.052.299.196.233.2zm-2.356-1.86c.092-.383-.853-2.107-.446-.864.146.26.13.754.446.864zm4.324 2.666c-.266-.223-.013-.032 0 0zm.656.152c0-.405-.725-.164 0 0zm5.681 3.583c-.108-.278-.428-.006 0 0zm.273.199c-.04-.155-.157.03 0 0zM15.4 20.24c.216-.16-.27-.02 0 0zM3.39 12.52c.62-.24-.664-.17 0 0zm8.984 5.662c-.007-.401-.395.1 0 0zm-9.23-6.231c.399-.135-.367-.09 0 0zm1.156.56c-.007-.133-.122.05 0 0zm14.09 8.64c.512-.104 1.678.26 1.866-.136-.62-.015-2.15-.438-2.222.1l.136.023.22.013zM4.667 12.603c.009-.407-.317-.015 0 0zM1.63 10.495c-.138-.775-.525-.118 0 0zm.724.182c.009-.25-.663-.224 0 0zm.414.203c-.12-.097-.094.122 0 0zm2.605 1.67c.122-.112-.29-.083 0 0zm-2.88-2.128c-.07-.585-.84-.088 0 0zm-1.486-.964c-.02-.27-.144.102 0 0zm.22-.167c-.035-.32-.19.04 0 0zm1.22.729c.518-.203-.94-.42-.104-.04zm16.334 10.089c.33-.303-.42-.094 0 0zm1.974 1.023c.132-.392-.334.05 0 0zM2.573 9.38c.055-.38-.41.075 0 0zM.837 8.218c-.093-.535-.08-1.474.812-1.156-1.191.236.824 1.48.57.498.5.024.98-.296.716.19.987-.11 1.67-.964 2.624-.845.742-.098 1.554-.172 2.354-.471.658-.048 1.29-.756.93-1.175-.896-.076-1.835.036-2.827.233-1.098.228-2.096.662-3.205.849-1.08.145.217.4-.092.456-.564.196.672.328-.073.534-.46-.088-.94-.246-.743-.73-1.035.133-1.945.563-1.127 1.616h.06zm2.494-1.27c.243-.894 1.3.735.398.118-.108-.08-.285-.146-.398-.12zm.047-.434c.35-.26.186.146 0 0zm.445.008c.032-.411 1.018.218.163.148zm.608-.245c.222-.26.064.23 0 0zm.156-.104c.37-.444 2.095-.283.832-.043-.338-.255-.598.15-.832.043zm2.25-.347c-.055-1.214 1.119.432 0 0zm.64-.004c.233-.612.906-.245.108-.123.017.065-.024.316-.108.123zM2.322 9.067c.697-.427-.741-.37 0 0zm.515.144c.245-.26-.531-.106 0 0zm-1.52-1.08c.399-.305-.471-.116 0 0zm20.602 12.89c.012-.355-.304.16 0 0zm-2.093-1.43c.06-.408-.27.037 0 0zm2.67 1.568c.557 0 1.688-.173.475-.173-.19.03-1.109.024-.476.173zM3.29 8.959c.45-.03.706-.497-.087-.47-1.23-.127 1.084.42-.158.264-.167.11.236.237.245.207zm.398.202c-.048-.29-.14.154 0 0zm.47-1.257c.197-.243-.27-.065 0 0zm-1.5-2.508c.806-.274 1.907-.581 2.287.135-.387-.466-.156-.924.21-.243.516.689.775-.313.438-.545.383.476.819.7.257.03.61-.734-1.223.097-1.64.088-.2.09-2.071.477-1.551.535zm.472-.903c.46-.347 1.588.206.864-.345-.07-.062-1.586.418-.864.345zm1.674.069c.538.013-.231-.722.409-.39-.105-.343-.746-.407-1.06-.544-.176.314.36.938.65.934zm-1.38-1.52c.186-.252-.326.128 0 0zm.684.164c.866-.115-.22-.373-.174-.01zm-1.277-1c-.61-.796 1.146.134.527-.7-.522-.415-1.023.468-.527.7zm7.824 4.215c.28-.496-1.155-.668-.188-.175.09.03.07.21.188.175z"
                        }
                    }]
                })(t)
            }

            function l(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M4 0h16v8h-8zM4 8h8l8 8H4zM4 16h8v8z"
                        }
                    }]
                })(t)
            }

            function h(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M23.546 10.93L13.067.452c-.604-.603-1.582-.603-2.188 0L8.708 2.627l2.76 2.76c.645-.215 1.379-.07 1.889.441.516.515.658 1.258.438 1.9l2.658 2.66c.645-.223 1.387-.078 1.9.435.721.72.721 1.884 0 2.604-.719.719-1.881.719-2.6 0-.539-.541-.674-1.337-.404-1.996L12.86 8.955v6.525c.176.086.342.203.488.348.713.721.713 1.883 0 2.6-.719.721-1.889.721-2.609 0-.719-.719-.719-1.879 0-2.598.182-.18.387-.316.605-.406V8.835c-.217-.091-.424-.222-.6-.401-.545-.545-.676-1.342-.396-2.009L7.636 3.7.45 10.881c-.6.605-.6 1.584 0 2.189l10.48 10.477c.604.604 1.582.604 2.186 0l10.43-10.43c.605-.603.605-1.582 0-2.187"
                        }
                    }]
                })(t)
            }

            function c(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"
                        }
                    }]
                })(t)
            }

            function u(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M12.19 2.38a9.344 9.344 0 0 0-9.234 6.893c.053-.02-.055.013 0 0-3.875 2.551-3.922 8.11-.247 10.941l.006-.007-.007.03a6.717 6.717 0 0 0 4.077 1.356h5.173l.03.03h5.192c6.687.053 9.376-8.605 3.835-12.35a9.365 9.365 0 0 0-2.821-4.552l-.043.043.006-.05A9.344 9.344 0 0 0 12.19 2.38zm-.358 4.146c1.244-.04 2.518.368 3.486 1.15a5.186 5.186 0 0 1 1.862 4.078v.518c3.53-.07 3.53 5.262 0 5.193h-5.193l-.008.009v-.04H6.785a2.59 2.59 0 0 1-1.067-.23h.001a2.597 2.597 0 1 1 3.437-3.437l3.013-3.012A6.747 6.747 0 0 0 8.11 8.24c.018-.01.04-.026.054-.023a5.186 5.186 0 0 1 3.67-1.69z"
                        }
                    }]
                })(t)
            }

            function d(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.564-2.438L1.5 0zm7.031 9.75l-.232-2.718 10.059.003.23-2.622L5.412 4.41l.698 8.01h9.126l-.326 3.426-2.91.804-2.955-.81-.188-2.11H6.248l.33 4.171L12 19.351l5.379-1.443.744-8.157H8.531z"
                        }
                    }]
                })(t)
            }

            function p(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M8.851 18.56s-.917.534.653.714c1.902.218 2.874.187 4.969-.211 0 0 .552.346 1.321.646-4.699 2.013-10.633-.118-6.943-1.149M8.276 15.933s-1.028.761.542.924c2.032.209 3.636.227 6.413-.308 0 0 .384.389.987.602-5.679 1.661-12.007.13-7.942-1.218M13.116 11.475c1.158 1.333-.304 2.533-.304 2.533s2.939-1.518 1.589-3.418c-1.261-1.772-2.228-2.652 3.007-5.688 0-.001-8.216 2.051-4.292 6.573M19.33 20.504s.679.559-.747.991c-2.712.822-11.288 1.069-13.669.033-.856-.373.75-.89 1.254-.998.527-.114.828-.093.828-.093-.953-.671-6.156 1.317-2.643 1.887 9.58 1.553 17.462-.7 14.977-1.82M9.292 13.21s-4.362 1.036-1.544 1.412c1.189.159 3.561.123 5.77-.062 1.806-.152 3.618-.477 3.618-.477s-.637.272-1.098.587c-4.429 1.165-12.986.623-10.522-.568 2.082-1.006 3.776-.892 3.776-.892M17.116 17.584c4.503-2.34 2.421-4.589.968-4.285-.355.074-.515.138-.515.138s.132-.207.385-.297c2.875-1.011 5.086 2.981-.928 4.562 0-.001.07-.062.09-.118M14.401 0s2.494 2.494-2.365 6.33c-3.896 3.077-.888 4.832-.001 6.836-2.274-2.053-3.943-3.858-2.824-5.539 1.644-2.469 6.197-3.665 5.19-7.627M9.734 23.924c4.322.277 10.959-.153 11.116-2.198 0 0-.302.775-3.572 1.391-3.688.694-8.239.613-10.937.168 0-.001.553.457 3.393.639"
                        }
                    }]
                })(t)
            }

            function m(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z"
                        }
                    }]
                })(t)
            }

            function f(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M24 0H0v24h24V0zM8.45 5.16l.2.17v6.24l6.46-6.45h1.96l.2.4-5.14 5.1 5.47 7.94-.2.3h-1.94l-4.65-6.88-2.16 2.08v4.6l-.19.2H7l-.2-.2V5.33l.17-.17h1.48z"
                        }
                    }]
                })(t)
            }

            function g(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
                        }
                    }]
                })(t)
            }

            function y(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M22.379 23.343a1.62 1.62 0 0 0 1.536-2.14v.002L17.35 1.76A1.62 1.62 0 0 0 15.816.657H8.184A1.62 1.62 0 0 0 6.65 1.76L.086 21.204a1.62 1.62 0 0 0 1.536 2.139h4.741a1.62 1.62 0 0 0 1.535-1.103l.977-2.892 4.947 3.675c.28.208.618.32.966.32m-3.084-12.531 3.624 10.739a.54.54 0 0 1-.51.713v-.001h-.03a.54.54 0 0 1-.322-.106l-9.287-6.9h4.853m6.313 7.006c.116-.326.13-.694.007-1.058L9.79 1.76a1.722 1.722 0 0 0-.007-.02h6.034a.54.54 0 0 1 .512.366l6.562 19.445a.54.54 0 0 1-.338.684"
                        }
                    }]
                })(t)
            }

            function x(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M17.193 9.555c-1.264-5.58-4.252-7.414-4.573-8.115-.28-.394-.53-.954-.735-1.44-.036.495-.055.685-.523 1.184-.723.566-4.438 3.682-4.74 10.02-.282 5.912 4.27 9.435 4.888 9.884l.07.05A73.49 73.49 0 0111.91 24h.481c.114-1.032.284-2.056.51-3.07.417-.296.604-.463.85-.693a11.342 11.342 0 003.639-8.464c.01-.814-.103-1.662-.197-2.218zm-5.336 8.195s0-8.291.275-8.29c.213 0 .49 10.695.49 10.695-.381-.045-.765-1.76-.765-2.405z"
                        }
                    }]
                })(t)
            }

            function v(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M11.5725 0c-.1763 0-.3098.0013-.3584.0067-.0516.0053-.2159.021-.3636.0328-3.4088.3073-6.6017 2.1463-8.624 4.9728C1.1004 6.584.3802 8.3666.1082 10.255c-.0962.659-.108.8537-.108 1.7474s.012 1.0884.108 1.7476c.652 4.506 3.8591 8.2919 8.2087 9.6945.7789.2511 1.6.4223 2.5337.5255.3636.04 1.9354.04 2.299 0 1.6117-.1783 2.9772-.577 4.3237-1.2643.2065-.1056.2464-.1337.2183-.1573-.0188-.0139-.8987-1.1938-1.9543-2.62l-1.919-2.592-2.4047-3.5583c-1.3231-1.9564-2.4117-3.556-2.4211-3.556-.0094-.0026-.0187 1.5787-.0235 3.509-.0067 3.3802-.0093 3.5162-.0516 3.596-.061.115-.108.1618-.2064.2134-.075.0374-.1408.0445-.495.0445h-.406l-.1078-.068a.4383.4383 0 01-.1572-.1712l-.0493-.1056.0053-4.703.0067-4.7054.0726-.0915c.0376-.0493.1174-.1125.1736-.143.0962-.047.1338-.0517.5396-.0517.4787 0 .5584.0187.6827.1547.0353.0377 1.3373 1.9987 2.895 4.3608a10760.433 10760.433 0 004.7344 7.1706l1.9002 2.8782.096-.0633c.8518-.5536 1.7525-1.3418 2.4657-2.1627 1.5179-1.7429 2.4963-3.868 2.8247-6.134.0961-.6591.1078-.854.1078-1.7475 0-.8937-.012-1.0884-.1078-1.7476-.6522-4.506-3.8592-8.2919-8.2087-9.6945-.7672-.2487-1.5836-.42-2.4985-.5232-.169-.0176-1.0835-.0366-1.6123-.037zm4.0685 7.217c.3473 0 .4082.0053.4857.047.1127.0562.204.1642.237.2767.0186.061.0234 1.3653.0186 4.3044l-.0067 4.2175-.7436-1.14-.7461-1.14v-3.066c0-1.982.0093-3.0963.0234-3.1502.0375-.1313.1196-.2346.2323-.2955.0961-.0494.1313-.054.4997-.054z"
                        }
                    }]
                })(t)
            }

            function _(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M23.5594 14.7228a.5269.5269 0 0 0-.0563-.1191c-.139-.2632-.4768-.3418-1.0074-.2321-1.6533.3411-2.2935.1312-2.5256-.0191 1.342-2.0482 2.445-4.522 3.0411-6.8297.2714-1.0507.7982-3.5237.1222-4.7316a1.5641 1.5641 0 0 0-.1509-.235C21.6931.9086 19.8007.0248 17.5099.0005c-1.4947-.0158-2.7705.3461-3.1161.4794a9.449 9.449 0 0 0-.5159-.0816 8.044 8.044 0 0 0-1.3114-.1278c-1.1822-.0184-2.2038.2642-3.0498.8406-.8573-.3211-4.7888-1.645-7.2219.0788C.9359 2.1526.3086 3.8733.4302 6.3043c.0409.818.5069 3.334 1.2423 5.7436.4598 1.5065.9387 2.7019 1.4334 3.582.553.9942 1.1259 1.5933 1.7143 1.7895.4474.1491 1.1327.1441 1.8581-.7279.8012-.9635 1.5903-1.8258 1.9446-2.2069.4351.2355.9064.3625 1.39.3772a.0569.0569 0 0 0 .0004.0041 11.0312 11.0312 0 0 0-.2472.3054c-.3389.4302-.4094.5197-1.5002.7443-.3102.064-1.1344.2339-1.1464.8115-.0025.1224.0329.2309.0919.3268.2269.4231.9216.6097 1.015.6331 1.3345.3335 2.5044.092 3.3714-.6787-.017 2.231.0775 4.4174.3454 5.0874.2212.5529.7618 1.9045 2.4692 1.9043.2505 0 .5263-.0291.8296-.0941 1.7819-.3821 2.5557-1.1696 2.855-2.9059.1503-.8707.4016-2.8753.5388-4.1012.0169-.0703.0357-.1207.057-.1362.0007-.0005.0697-.0471.4272.0307a.3673.3673 0 0 0 .0443.0068l.2539.0223.0149.001c.8468.0384 1.9114-.1426 2.5312-.4308.6438-.2988 1.8057-1.0323 1.5951-1.6698zM2.371 11.8765c-.7435-2.4358-1.1779-4.8851-1.2123-5.5719-.1086-2.1714.4171-3.6829 1.5623-4.4927 1.8367-1.2986 4.8398-.5408 6.108-.13-.0032.0032-.0066.0061-.0098.0094-2.0238 2.044-1.9758 5.536-1.9708 5.7495-.0002.0823.0066.1989.0162.3593.0348.5873.0996 1.6804-.0735 2.9184-.1609 1.1504.1937 2.2764.9728 3.0892.0806.0841.1648.1631.2518.2374-.3468.3714-1.1004 1.1926-1.9025 2.1576-.5677.6825-.9597.5517-1.0886.5087-.3919-.1307-.813-.5871-1.2381-1.3223-.4796-.839-.9635-2.0317-1.4155-3.5126zm6.0072 5.0871c-.1711-.0428-.3271-.1132-.4322-.1772.0889-.0394.2374-.0902.4833-.1409 1.2833-.2641 1.4815-.4506 1.9143-1.0002.0992-.126.2116-.2687.3673-.4426a.3549.3549 0 0 0 .0737-.1298c.1708-.1513.2724-.1099.4369-.0417.156.0646.3078.26.3695.4752.0291.1016.0619.2945-.0452.4444-.9043 1.2658-2.2216 1.2494-3.1676 1.0128zm2.094-3.988-.0525.141c-.133.3566-.2567.6881-.3334 1.003-.6674-.0021-1.3168-.2872-1.8105-.8024-.6279-.6551-.9131-1.5664-.7825-2.5004.1828-1.3079.1153-2.4468.079-3.0586-.005-.0857-.0095-.1607-.0122-.2199.2957-.2621 1.6659-.9962 2.6429-.7724.4459.1022.7176.4057.8305.928.5846 2.7038.0774 3.8307-.3302 4.7363-.084.1866-.1633.3629-.2311.5454zm7.3637 4.5725c-.0169.1768-.0358.376-.0618.5959l-.146.4383a.3547.3547 0 0 0-.0182.1077c-.0059.4747-.054.6489-.115.8693-.0634.2292-.1353.4891-.1794 1.0575-.11 1.4143-.8782 2.2267-2.4172 2.5565-1.5155.3251-1.7843-.4968-2.0212-1.2217a6.5824 6.5824 0 0 0-.0769-.2266c-.2154-.5858-.1911-1.4119-.1574-2.5551.0165-.5612-.0249-1.9013-.3302-2.6462.0044-.2932.0106-.5909.019-.8918a.3529.3529 0 0 0-.0153-.1126 1.4927 1.4927 0 0 0-.0439-.208c-.1226-.4283-.4213-.7866-.7797-.9351-.1424-.059-.4038-.1672-.7178-.0869.067-.276.1831-.5875.309-.9249l.0529-.142c.0595-.16.134-.3257.213-.5012.4265-.9476 1.0106-2.2453.3766-5.1772-.2374-1.0981-1.0304-1.6343-2.2324-1.5098-.7207.0746-1.3799.3654-1.7088.5321a5.6716 5.6716 0 0 0-.1958.1041c.0918-1.1064.4386-3.1741 1.7357-4.4823a4.0306 4.0306 0 0 1 .3033-.276.3532.3532 0 0 0 .1447-.0644c.7524-.5706 1.6945-.8506 2.802-.8325.4091.0067.8017.0339 1.1742.081 1.939.3544 3.2439 1.4468 4.0359 2.3827.8143.9623 1.2552 1.9315 1.4312 2.4543-1.3232-.1346-2.2234.1268-2.6797.779-.9926 1.4189.543 4.1729 1.2811 5.4964.1353.2426.2522.4522.2889.5413.2403.5825.5515.9713.7787 1.2552.0696.087.1372.1714.1885.245-.4008.1155-1.1208.3825-1.0552 1.717-.0123.1563-.0423.4469-.0834.8148-.0461.2077-.0702.4603-.0994.7662zm.8905-1.6211c-.0405-.8316.2691-.9185.5967-1.0105a2.8566 2.8566 0 0 0 .135-.0406 1.202 1.202 0 0 0 .1342.103c.5703.3765 1.5823.4213 3.0068.1344-.2016.1769-.5189.3994-.9533.6011-.4098.1903-1.0957.333-1.7473.3636-.7197.0336-1.0859-.0807-1.1721-.151zm.5695-9.2712c-.0059.3508-.0542.6692-.1054 1.0017-.055.3576-.112.7274-.1264 1.1762-.0142.4368.0404.8909.0932 1.3301.1066.887.216 1.8003-.2075 2.7014a3.5272 3.5272 0 0 1-.1876-.3856c-.0527-.1276-.1669-.3326-.3251-.6162-.6156-1.1041-2.0574-3.6896-1.3193-4.7446.3795-.5427 1.3408-.5661 2.1781-.463zm.2284 7.0137a12.3762 12.3762 0 0 0-.0853-.1074l-.0355-.0444c.7262-1.1995.5842-2.3862.4578-3.4385-.0519-.4318-.1009-.8396-.0885-1.2226.0129-.4061.0666-.7543.1185-1.0911.0639-.415.1288-.8443.1109-1.3505.0134-.0531.0188-.1158.0118-.1902-.0457-.4855-.5999-1.938-1.7294-3.253-.6076-.7073-1.4896-1.4972-2.6889-2.0395.5251-.1066 1.2328-.2035 2.0244-.1859 2.0515.0456 3.6746.8135 4.8242 2.2824a.908.908 0 0 1 .0667.1002c.7231 1.3556-.2762 6.2751-2.9867 10.5405zm-8.8166-6.1162c-.025.1794-.3089.4225-.6211.4225a.5821.5821 0 0 1-.0809-.0056c-.1873-.026-.3765-.144-.5059-.3156-.0458-.0605-.1203-.178-.1055-.2844.0055-.0401.0261-.0985.0925-.1488.1182-.0894.3518-.1226.6096-.0867.3163.0441.6426.1938.6113.4186zm7.9305-.4114c.0111.0792-.049.201-.1531.3102-.0683.0717-.212.1961-.4079.2232a.5456.5456 0 0 1-.075.0052c-.2935 0-.5414-.2344-.5607-.3717-.024-.1765.2641-.3106.5611-.352.297-.0414.6111.0088.6356.1851z"
                        }
                    }]
                })(t)
            }

            function b(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M13.527.099C6.955-.744.942 3.9.099 10.473c-.843 6.572 3.8 12.584 10.373 13.428 6.573.843 12.587-3.801 13.428-10.374C24.744 6.955 20.101.943 13.527.099zm2.471 7.485a.855.855 0 0 0-.593.25l-4.453 4.453-.307-.307-.643-.643c4.389-4.376 5.18-4.418 5.996-3.753zm-4.863 4.861l4.44-4.44a.62.62 0 1 1 .847.903l-4.699 4.125-.588-.588zm.33.694l-1.1.238a.06.06 0 0 1-.067-.032.06.06 0 0 1 .01-.073l.645-.645.512.512zm-2.803-.459l1.172-1.172.879.878-1.979.426a.074.074 0 0 1-.085-.039.072.072 0 0 1 .013-.093zm-3.646 6.058a.076.076 0 0 1-.069-.083.077.077 0 0 1 .022-.046h.002l.946-.946 1.222 1.222-2.123-.147zm2.425-1.256a.228.228 0 0 0-.117.256l.203.865a.125.125 0 0 1-.211.117h-.003l-.934-.934-.294-.295 3.762-3.758 1.82-.393.874.874c-1.255 1.102-2.971 2.201-5.1 3.268zm5.279-3.428h-.002l-.839-.839 4.699-4.125a.952.952 0 0 0 .119-.127c-.148 1.345-2.029 3.245-3.977 5.091zm3.657-6.46l-.003-.002a1.822 1.822 0 0 1 2.459-2.684l-1.61 1.613a.119.119 0 0 0 0 .169l1.247 1.247a1.817 1.817 0 0 1-2.093-.343zm2.578 0a1.714 1.714 0 0 1-.271.218h-.001l-1.207-1.207 1.533-1.533c.661.72.637 1.832-.054 2.522zM18.855 6.05a.143.143 0 0 0-.053.157.416.416 0 0 1-.053.45.14.14 0 0 0 .023.197.141.141 0 0 0 .084.03.14.14 0 0 0 .106-.05.691.691 0 0 0 .087-.751.138.138 0 0 0-.194-.033z"
                        }
                    }]
                })(t)
            }

            function M(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M14.25.18l.9.2.73.26.59.3.45.32.34.34.25.34.16.33.1.3.04.26.02.2-.01.13V8.5l-.05.63-.13.55-.21.46-.26.38-.3.31-.33.25-.35.19-.35.14-.33.1-.3.07-.26.04-.21.02H8.77l-.69.05-.59.14-.5.22-.41.27-.33.32-.27.35-.2.36-.15.37-.1.35-.07.32-.04.27-.02.21v3.06H3.17l-.21-.03-.28-.07-.32-.12-.35-.18-.36-.26-.36-.36-.35-.46-.32-.59-.28-.73-.21-.88-.14-1.05-.05-1.23.06-1.22.16-1.04.24-.87.32-.71.36-.57.4-.44.42-.33.42-.24.4-.16.36-.1.32-.05.24-.01h.16l.06.01h8.16v-.83H6.18l-.01-2.75-.02-.37.05-.34.11-.31.17-.28.25-.26.31-.23.38-.2.44-.18.51-.15.58-.12.64-.1.71-.06.77-.04.84-.02 1.27.05zm-6.3 1.98l-.23.33-.08.41.08.41.23.34.33.22.41.09.41-.09.33-.22.23-.34.08-.41-.08-.41-.23-.33-.33-.22-.41-.09-.41.09zm13.09 3.95l.28.06.32.12.35.18.36.27.36.35.35.47.32.59.28.73.21.88.14 1.04.05 1.23-.06 1.23-.16 1.04-.24.86-.32.71-.36.57-.4.45-.42.33-.42.24-.4.16-.36.09-.32.05-.24.02-.16-.01h-8.22v.82h5.84l.01 2.76.02.36-.05.34-.11.31-.17.29-.25.25-.31.24-.38.2-.44.17-.51.15-.58.13-.64.09-.71.07-.77.04-.84.01-1.27-.04-1.07-.14-.9-.2-.73-.25-.59-.3-.45-.33-.34-.34-.25-.34-.16-.33-.1-.3-.04-.25-.02-.2.01-.13v-5.34l.05-.64.13-.54.21-.46.26-.38.3-.32.33-.24.35-.2.35-.14.33-.1.3-.06.26-.04.21-.02.13-.01h5.84l.69-.05.59-.14.5-.21.41-.28.33-.32.27-.35.2-.36.15-.36.1-.35.07-.32.04-.28.02-.21V6.07h2.09l.14.01zm-6.47 14.25l-.23.33-.08.41.08.41.23.33.33.23.41.08.41-.08.33-.23.23-.33.08-.41-.08-.41-.23-.33-.33-.23-.41-.08-.41.08z"
                        }
                    }]
                })(t)
            }

            function w(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z"
                        }
                    }]
                })(t)
            }

            function S(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M16.634 16.504c.87-.075 1.543-.84 1.5-1.754-.047-.914-.796-1.648-1.709-1.648h-.061a1.71 1.71 0 00-1.648 1.769c.03.479.226.869.494 1.153-1.048 2.038-2.621 3.536-5.005 4.795-1.603.838-3.296 1.154-4.944.93-1.378-.195-2.456-.81-3.116-1.799-.988-1.499-1.078-3.116-.255-4.734.6-1.17 1.499-2.023 2.099-2.443a9.96 9.96 0 01-.42-1.543C-.868 14.408-.416 18.752.932 20.805c1.004 1.498 3.057 2.456 5.304 2.456.6 0 1.23-.044 1.843-.194 3.897-.749 6.848-3.086 8.541-6.532zm5.348-3.746c-2.32-2.728-5.738-4.226-9.634-4.226h-.51c-.253-.554-.837-.899-1.498-.899h-.045c-.943 0-1.678.81-1.647 1.753.03.898.794 1.648 1.708 1.648h.074a1.69 1.69 0 001.499-1.049h.555c2.309 0 4.495.674 6.488 1.992 1.527 1.005 2.622 2.323 3.237 3.897.538 1.288.509 2.547-.045 3.597-.855 1.647-2.294 2.517-4.196 2.517-1.199 0-2.367-.375-2.967-.644-.36.298-.96.793-1.394 1.093 1.318.598 2.652.943 3.94.943 2.922 0 5.094-1.647 5.919-3.236.898-1.798.824-4.824-1.47-7.416zM6.49 17.042c.03.899.793 1.648 1.708 1.648h.06a1.688 1.688 0 001.648-1.768c0-.9-.779-1.647-1.693-1.647h-.06c-.06 0-.15 0-.226.029-1.243-2.098-1.768-4.347-1.572-6.772.12-1.828.72-3.417 1.797-4.735.9-1.124 2.593-1.68 3.747-1.708 3.236-.061 4.585 3.971 4.689 5.574l1.498.45C17.741 3.197 14.686.62 11.764.62 9.02.62 6.49 2.613 5.47 5.535 4.077 9.43 4.991 13.177 6.7 16.174c-.15.195-.24.539-.21.868z"
                        }
                    }]
                })(t)
            }

            function E(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M12.178.002a12.002 12.002 0 0 0-8.662 3.515 12.002 12.002 0 0 0 0 16.97 12.002 12.002 0 0 0 16.97 0 12.002 12.002 0 0 0 0-16.97A12.002 12.002 0 0 0 12.179.002zM7.77 5.995c.562.128 1.05.217 1.663.217.921 0 1.863-.217 2.786-.217 1.79 0 3.45.814 3.45 2.8 0 1.54-.921 2.517-2.35 2.93l2.788 4.107h1.301v1.01h-1.986l-3.293-4.934h-1.757v3.924h1.718v1.01H7.77v-1.01h1.483V7.134L7.77 6.951v-.957zm4.466 1.012c-.596 0-1.213.053-1.864.127v3.798l.941.02c2.298.034 3.183-.85 3.183-2.026 0-1.376-.997-1.919-2.26-1.919z"
                        }
                    }]
                })(t)
            }

            function T(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M21.678.521c-1.032-.92-2.28-.55-3.513.544a8.71 8.71 0 0 0-.547.535c-2.109 2.237-4.066 6.38-4.674 9.544.237.48.422 1.093.544 1.561a13.044 13.044 0 0 1 .164.703s-.019-.071-.096-.296l-.05-.146a1.689 1.689 0 0 0-.033-.08c-.138-.32-.518-.995-.686-1.289-.143.423-.27.818-.376 1.176.484.884.778 2.4.778 2.4s-.025-.099-.147-.442c-.107-.303-.644-1.244-.772-1.464-.217.804-.304 1.346-.226 1.478.152.256.296.698.422 1.186.286 1.1.485 2.44.485 2.44l.017.224a22.41 22.41 0 0 0 .056 2.748c.095 1.146.273 2.13.5 2.657l.155-.084c-.334-1.038-.47-2.399-.41-3.967.09-2.398.642-5.29 1.661-8.304 1.723-4.55 4.113-8.201 6.3-9.945-1.993 1.8-4.692 7.63-5.5 9.788-.904 2.416-1.545 4.684-1.931 6.857.666-2.037 2.821-2.912 2.821-2.912s1.057-1.304 2.292-3.166c-.74.169-1.955.458-2.362.629-.6.251-.762.337-.762.337s1.945-1.184 3.613-1.72C21.695 7.9 24.195 2.767 21.678.521m-18.573.543A1.842 1.842 0 0 0 1.27 2.9v16.608a1.84 1.84 0 0 0 1.835 1.834h9.418a22.953 22.953 0 0 1-.052-2.707c-.006-.062-.011-.141-.016-.2a27.01 27.01 0 0 0-.473-2.378c-.121-.47-.275-.898-.369-1.057-.116-.197-.098-.31-.097-.432 0-.12.015-.245.037-.386a9.98 9.98 0 0 1 .234-1.045l.217-.028c-.017-.035-.014-.065-.031-.097l-.041-.381a32.8 32.8 0 0 1 .382-1.194l.2-.019c-.008-.016-.01-.038-.018-.053l-.043-.316c.63-3.28 2.587-7.443 4.8-9.791.066-.069.133-.128.198-.194Z"
                        }
                    }]
                })(t)
            }

            function A(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M12.001,4.8c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 C13.666,10.618,15.027,12,18.001,12c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C16.337,6.182,14.976,4.8,12.001,4.8z M6.001,12c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 c1.177,1.194,2.538,2.576,5.512,2.576c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C10.337,13.382,8.976,12,6.001,12z"
                        }
                    }]
                })(t)
            }

            function C(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M1.292 5.856L11.54 0v24l-4.095-2.378V7.603l-6.168 3.564.015-5.31zm21.43 5.311l-.014-5.31L12.46 0v24l4.095-2.378V14.87l3.092 1.788-.018-4.618-3.074-1.756V7.603l6.168 3.564z"
                        }
                    }]
                })(t)
            }

            function R(t) {
                return (0, n.w_)({
                    tag: "svg",
                    attr: {
                        role: "img",
                        viewBox: "0 0 24 24"
                    },
                    child: [{
                        tag: "title",
                        attr: {},
                        child: []
                    }, {
                        tag: "path",
                        attr: {
                            d: "M.38 0a.268.268 0 0 0-.256.332l2.894 11.716a.268.268 0 0 0 .01.04l2.89 11.708a.268.268 0 0 0 .447.128L23.802 7.15a.268.268 0 0 0-.112-.45l-5.784-1.667a.268.268 0 0 0-.123-.035L6.38 1.715a.268.268 0 0 0-.144-.04L.456.01A.268.268 0 0 0 .38 0zm.374.654L5.71 2.08 1.99 5.664zM6.61 2.34l4.864 1.4-3.65 3.515zm-.522.12l1.217 4.926-4.877-1.4zm6.28 1.538l4.878 1.404-3.662 3.53zm-.52.13l1.208 4.9-4.853-1.392zm6.3 1.534l4.947 1.424-3.715 3.574zm-.524.12l1.215 4.926-4.876-1.398zm-15.432.696l4.964 1.424-3.726 3.586zM8.047 8.15l4.877 1.4-3.66 3.527zm-.518.137l1.236 5.017-4.963-1.432zm6.274 1.535l4.965 1.425-3.73 3.586zm-.52.127l1.235 5.012-4.958-1.43zm-9.63 2.438l4.873 1.406-3.656 3.523zm5.854 1.687l4.863 1.403-3.648 3.51zm-.54.04l1.214 4.927-4.875-1.4zm-3.896 4.02l5.037 1.442-3.782 3.638z"
                        }
                    }]
                })(t)
            }
        },
        8477: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                r = a(i(7294)),
                s = a(i(1093));

            function a(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }

            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function l(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" !== typeof e && "function" !== typeof e ? t : e
            }
            var h = function(t) {
                function e() {
                    return o(this, e), l(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments))
                }
                return function(t, e) {
                    if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, t), n(e, [{
                    key: "render",
                    value: function() {
                        return r.default.createElement("input", this.props, this.props.children)
                    }
                }]), e
            }(r.default.Component);
            e.default = (0, s.default)(h)
        },
        5343: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                    }
                    return t
                },
                r = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                s = l(i(7294)),
                a = l(i(8e3)),
                o = l(i(5697));

            function l(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }

            function h(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function c(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" !== typeof e && "function" !== typeof e ? t : e
            }
            var u = function(t) {
                function e() {
                    return h(this, e), c(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments))
                }
                return function(t, e) {
                    if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, t), r(e, [{
                    key: "render",
                    value: function() {
                        var t = this,
                            e = n({}, this.props);
                        return e.parentBindings && delete e.parentBindings, s.default.createElement("div", n({}, e, {
                            ref: function(e) {
                                t.props.parentBindings.domNode = e
                            }
                        }), this.props.children)
                    }
                }]), e
            }(s.default.Component);
            u.propTypes = {
                name: o.default.string,
                id: o.default.string
            }, e.default = (0, a.default)(u)
        },
        8939: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = s(i(7294)),
                r = s(i(1093));

            function s(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }

            function a(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function o(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" !== typeof e && "function" !== typeof e ? t : e
            }
            var l = function(t) {
                function e() {
                    var t, i, r;
                    a(this, e);
                    for (var s = arguments.length, l = Array(s), h = 0; h < s; h++) l[h] = arguments[h];
                    return i = r = o(this, (t = e.__proto__ || Object.getPrototypeOf(e)).call.apply(t, [this].concat(l))), r.render = function() {
                        return n.default.createElement("a", r.props, r.props.children)
                    }, o(r, i)
                }
                return function(t, e) {
                    if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, t), e
            }(n.default.Component);
            e.default = (0, r.default)(l)
        },
        6261: function(t, e, i) {
            "use strict";
            e.rU = void 0;
            var n = p(i(8939)),
                r = p(i(8477)),
                s = p(i(5343)),
                a = p(i(2628)),
                o = p(i(4592)),
                l = p(i(7606)),
                h = p(i(3200)),
                c = p(i(1093)),
                u = p(i(8e3)),
                d = p(i(8482));

            function p(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            e.rU = n.default, r.default, s.default, a.default, o.default, l.default, h.default, c.default, u.default, d.default, n.default, r.default, s.default, a.default, o.default, l.default, h.default, c.default, u.default, d.default
        },
        8482: function(t, e, i) {
            "use strict";
            var n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                    }
                    return t
                },
                r = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }();

            function s(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" !== typeof e && "function" !== typeof e ? t : e
            }

            function o(t, e) {
                if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }
            var l = i(7294),
                h = (i(3935), i(4259), i(7606)),
                c = i(2628),
                u = i(5697),
                d = i(9678),
                p = {
                    to: u.string.isRequired,
                    containerId: u.string,
                    container: u.object,
                    activeClass: u.string,
                    spy: u.bool,
                    smooth: u.oneOfType([u.bool, u.string]),
                    offset: u.number,
                    delay: u.number,
                    isDynamic: u.bool,
                    onClick: u.func,
                    duration: u.oneOfType([u.number, u.func]),
                    absolute: u.bool,
                    onSetActive: u.func,
                    onSetInactive: u.func,
                    ignoreCancelEvents: u.bool,
                    hashSpy: u.bool,
                    spyThrottle: u.number
                },
                m = {
                    Scroll: function(t, e) {
                        console.warn("Helpers.Scroll is deprecated since v1.7.0");
                        var i = e || c,
                            u = function(e) {
                                function c(t) {
                                    s(this, c);
                                    var e = a(this, (c.__proto__ || Object.getPrototypeOf(c)).call(this, t));
                                    return m.call(e), e.state = {
                                        active: !1
                                    }, e
                                }
                                return o(c, e), r(c, [{
                                    key: "getScrollSpyContainer",
                                    value: function() {
                                        var t = this.props.containerId,
                                            e = this.props.container;
                                        return t ? document.getElementById(t) : e && e.nodeType ? e : document
                                    }
                                }, {
                                    key: "componentDidMount",
                                    value: function() {
                                        if (this.props.spy || this.props.hashSpy) {
                                            var t = this.getScrollSpyContainer();
                                            h.isMounted(t) || h.mount(t, this.props.spyThrottle), this.props.hashSpy && (d.isMounted() || d.mount(i), d.mapContainer(this.props.to, t)), this.props.spy && h.addStateHandler(this.stateHandler), h.addSpyHandler(this.spyHandler, t), this.setState({
                                                container: t
                                            })
                                        }
                                    }
                                }, {
                                    key: "componentWillUnmount",
                                    value: function() {
                                        h.unmount(this.stateHandler, this.spyHandler)
                                    }
                                }, {
                                    key: "render",
                                    value: function() {
                                        var e = "";
                                        e = this.state && this.state.active ? ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : this.props.className;
                                        var i = n({}, this.props);
                                        for (var r in p) i.hasOwnProperty(r) && delete i[r];
                                        return i.className = e, i.onClick = this.handleClick, l.createElement(t, i)
                                    }
                                }]), c
                            }(l.Component),
                            m = function() {
                                var t = this;
                                this.scrollTo = function(e, r) {
                                    i.scrollTo(e, n({}, t.state, r))
                                }, this.handleClick = function(e) {
                                    t.props.onClick && t.props.onClick(e), e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault(), t.scrollTo(t.props.to, t.props)
                                }, this.stateHandler = function() {
                                    i.getActiveLink() !== t.props.to && (null !== t.state && t.state.active && t.props.onSetInactive && t.props.onSetInactive(), t.setState({
                                        active: !1
                                    }))
                                }, this.spyHandler = function(e) {
                                    var n = t.getScrollSpyContainer();
                                    if (!d.isMounted() || d.isInitialized()) {
                                        var r = t.props.to,
                                            s = null,
                                            a = 0,
                                            o = 0,
                                            l = 0;
                                        if (n.getBoundingClientRect) l = n.getBoundingClientRect().top;
                                        if (!s || t.props.isDynamic) {
                                            if (!(s = i.get(r))) return;
                                            var c = s.getBoundingClientRect();
                                            o = (a = c.top - l + e) + c.height
                                        }
                                        var u = e - t.props.offset,
                                            p = u >= Math.floor(a) && u < Math.floor(o),
                                            m = u < Math.floor(a) || u >= Math.floor(o),
                                            f = i.getActiveLink();
                                        return m ? (r === f && i.setActiveLink(void 0), t.props.hashSpy && d.getHash() === r && d.changeHash(), t.props.spy && t.state.active && (t.setState({
                                            active: !1
                                        }), t.props.onSetInactive && t.props.onSetInactive()), h.updateStates()) : p && f !== r ? (i.setActiveLink(r), t.props.hashSpy && d.changeHash(r), t.props.spy && (t.setState({
                                            active: !0
                                        }), t.props.onSetActive && t.props.onSetActive(r)), h.updateStates()) : void 0
                                    }
                                }
                            };
                        return u.propTypes = p, u.defaultProps = {
                            offset: 0
                        }, u
                    },
                    Element: function(t) {
                        console.warn("Helpers.Element is deprecated since v1.7.0");
                        var e = function(e) {
                            function i(t) {
                                s(this, i);
                                var e = a(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, t));
                                return e.childBindings = {
                                    domNode: null
                                }, e
                            }
                            return o(i, e), r(i, [{
                                key: "componentDidMount",
                                value: function() {
                                    if ("undefined" === typeof window) return !1;
                                    this.registerElems(this.props.name)
                                }
                            }, {
                                key: "componentDidUpdate",
                                value: function(t) {
                                    this.props.name !== t.name && this.registerElems(this.props.name)
                                }
                            }, {
                                key: "componentWillUnmount",
                                value: function() {
                                    if ("undefined" === typeof window) return !1;
                                    c.unregister(this.props.name)
                                }
                            }, {
                                key: "registerElems",
                                value: function(t) {
                                    c.register(t, this.childBindings.domNode)
                                }
                            }, {
                                key: "render",
                                value: function() {
                                    return l.createElement(t, n({}, this.props, {
                                        parentBindings: this.childBindings
                                    }))
                                }
                            }]), i
                        }(l.Component);
                        return e.propTypes = {
                            name: u.string,
                            id: u.string
                        }, e
                    }
                };
            t.exports = m
        },
        3200: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                    }
                    return t
                },
                r = (o(i(4259)), o(i(9765))),
                s = o(i(140)),
                a = o(i(4592));

            function o(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var l = function(t) {
                    return r.default[t.smooth] || r.default.defaultEasing
                },
                h = function() {
                    if ("undefined" !== typeof window) return window.requestAnimationFrame || window.webkitRequestAnimationFrame
                }() || function(t, e, i) {
                    window.setTimeout(t, i || 1e3 / 60, (new Date).getTime())
                },
                c = function(t) {
                    var e = t.data.containerElement;
                    if (e && e !== document && e !== document.body) return e.scrollLeft;
                    var i = void 0 !== window.pageXOffset,
                        n = "CSS1Compat" === (document.compatMode || "");
                    return i ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft
                },
                u = function(t) {
                    var e = t.data.containerElement;
                    if (e && e !== document && e !== document.body) return e.scrollTop;
                    var i = void 0 !== window.pageXOffset,
                        n = "CSS1Compat" === (document.compatMode || "");
                    return i ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop
                },
                d = function t(e, i, n) {
                    var r = i.data;
                    if (i.ignoreCancelEvents || !r.cancel)
                        if (r.delta = Math.round(r.targetPosition - r.startPosition), null === r.start && (r.start = n), r.progress = n - r.start, r.percent = r.progress >= r.duration ? 1 : e(r.progress / r.duration), r.currentPosition = r.startPosition + Math.ceil(r.delta * r.percent), r.containerElement && r.containerElement !== document && r.containerElement !== document.body ? i.horizontal ? r.containerElement.scrollLeft = r.currentPosition : r.containerElement.scrollTop = r.currentPosition : i.horizontal ? window.scrollTo(r.currentPosition, 0) : window.scrollTo(0, r.currentPosition), r.percent < 1) {
                            var s = t.bind(null, e, i);
                            h.call(window, s)
                        } else a.default.registered.end && a.default.registered.end(r.to, r.target, r.currentPosition);
                    else a.default.registered.end && a.default.registered.end(r.to, r.target, r.currentPositionY)
                },
                p = function(t) {
                    t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null
                },
                m = function(t, e, i, n) {
                    if (e.data = e.data || {
                            currentPosition: 0,
                            startPosition: 0,
                            targetPosition: 0,
                            progress: 0,
                            duration: 0,
                            cancel: !1,
                            target: null,
                            containerElement: null,
                            to: null,
                            start: null,
                            delta: null,
                            percent: null,
                            delayTimeout: null
                        }, window.clearTimeout(e.data.delayTimeout), s.default.subscribe((function() {
                            e.data.cancel = !0
                        })), p(e), e.data.start = null, e.data.cancel = !1, e.data.startPosition = e.horizontal ? c(e) : u(e), e.data.targetPosition = e.absolute ? t : t + e.data.startPosition, e.data.startPosition !== e.data.targetPosition) {
                        var r;
                        e.data.delta = Math.round(e.data.targetPosition - e.data.startPosition), e.data.duration = ("function" === typeof(r = e.duration) ? r : function() {
                            return r
                        })(e.data.delta), e.data.duration = isNaN(parseFloat(e.data.duration)) ? 1e3 : parseFloat(e.data.duration), e.data.to = i, e.data.target = n;
                        var o = l(e),
                            m = d.bind(null, o, e);
                        e && e.delay > 0 ? e.data.delayTimeout = window.setTimeout((function() {
                            a.default.registered.begin && a.default.registered.begin(e.data.to, e.data.target), h.call(window, m)
                        }), e.delay) : (a.default.registered.begin && a.default.registered.begin(e.data.to, e.data.target), h.call(window, m))
                    } else a.default.registered.end && a.default.registered.end(e.data.to, e.data.target, e.data.currentPosition)
                },
                f = function(t) {
                    return (t = n({}, t)).data = t.data || {
                        currentPosition: 0,
                        startPosition: 0,
                        targetPosition: 0,
                        progress: 0,
                        duration: 0,
                        cancel: !1,
                        target: null,
                        containerElement: null,
                        to: null,
                        start: null,
                        delta: null,
                        percent: null,
                        delayTimeout: null
                    }, t.absolute = !0, t
                };
            e.default = {
                animateTopScroll: m,
                getAnimationType: l,
                scrollToTop: function(t) {
                    m(0, f(t))
                },
                scrollToBottom: function(t) {
                    t = f(t), p(t), m(t.horizontal ? function(t) {
                        var e = t.data.containerElement;
                        if (e && e !== document && e !== document.body) return e.scrollWidth - e.offsetWidth;
                        var i = document.body,
                            n = document.documentElement;
                        return Math.max(i.scrollWidth, i.offsetWidth, n.clientWidth, n.scrollWidth, n.offsetWidth)
                    }(t) : function(t) {
                        var e = t.data.containerElement;
                        if (e && e !== document && e !== document.body) return e.scrollHeight - e.offsetHeight;
                        var i = document.body,
                            n = document.documentElement;
                        return Math.max(i.scrollHeight, i.offsetHeight, n.clientHeight, n.scrollHeight, n.offsetHeight)
                    }(t), t)
                },
                scrollTo: function(t, e) {
                    m(t, f(e))
                },
                scrollMore: function(t, e) {
                    e = f(e), p(e);
                    var i = e.horizontal ? c(e) : u(e);
                    m(t + i, e)
                }
            }
        },
        140: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = i(5236),
                r = ["mousedown", "mousewheel", "touchmove", "keydown"];
            e.default = {
                subscribe: function(t) {
                    return "undefined" !== typeof document && r.forEach((function(e) {
                        return (0, n.addPassiveEventListener)(document, e, t)
                    }))
                }
            }
        },
        5236: function(t, e) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            e.addPassiveEventListener = function(t, e, i) {
                var n = function() {
                    var t = !1;
                    try {
                        var e = Object.defineProperty({}, "passive", {
                            get: function() {
                                t = !0
                            }
                        });
                        window.addEventListener("test", null, e)
                    } catch (i) {}
                    return t
                }();
                t.addEventListener(e, i, !!n && {
                    passive: !0
                })
            }, e.removePassiveEventListener = function(t, e, i) {
                t.removeEventListener(e, i)
            }
        },
        8e3: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                    }
                    return t
                },
                r = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                s = l(i(7294)),
                a = (l(i(3935)), l(i(2628))),
                o = l(i(5697));

            function l(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            e.default = function(t) {
                var e = function(e) {
                    function i(t) {
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, i);
                        var e = function(t, e) {
                            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return !e || "object" !== typeof e && "function" !== typeof e ? t : e
                        }(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, t));
                        return e.childBindings = {
                            domNode: null
                        }, e
                    }
                    return function(t, e) {
                        if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                    }(i, e), r(i, [{
                        key: "componentDidMount",
                        value: function() {
                            if ("undefined" === typeof window) return !1;
                            this.registerElems(this.props.name)
                        }
                    }, {
                        key: "componentDidUpdate",
                        value: function(t) {
                            this.props.name !== t.name && this.registerElems(this.props.name)
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function() {
                            if ("undefined" === typeof window) return !1;
                            a.default.unregister(this.props.name)
                        }
                    }, {
                        key: "registerElems",
                        value: function(t) {
                            a.default.register(t, this.childBindings.domNode)
                        }
                    }, {
                        key: "render",
                        value: function() {
                            return s.default.createElement(t, n({}, this.props, {
                                parentBindings: this.childBindings
                            }))
                        }
                    }]), i
                }(s.default.Component);
                return e.propTypes = {
                    name: o.default.string,
                    id: o.default.string
                }, e
            }
        },
        4592: function(t, e) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = {
                registered: {},
                scrollEvent: {
                    register: function(t, e) {
                        i.registered[t] = e
                    },
                    remove: function(t) {
                        i.registered[t] = null
                    }
                }
            };
            e.default = i
        },
        9678: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            i(5236);
            var n, r = i(4259),
                s = (n = r) && n.__esModule ? n : {
                    default: n
                };
            var a = {
                mountFlag: !1,
                initialized: !1,
                scroller: null,
                containers: {},
                mount: function(t) {
                    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0
                },
                mapContainer: function(t, e) {
                    this.containers[t] = e
                },
                isMounted: function() {
                    return this.mountFlag
                },
                isInitialized: function() {
                    return this.initialized
                },
                initStateFromHash: function() {
                    var t = this,
                        e = this.getHash();
                    e ? window.setTimeout((function() {
                        t.scrollTo(e, !0), t.initialized = !0
                    }), 10) : this.initialized = !0
                },
                scrollTo: function(t, e) {
                    var i = this.scroller;
                    if (i.get(t) && (e || t !== i.getActiveLink())) {
                        var n = this.containers[t] || document;
                        i.scrollTo(t, {
                            container: n
                        })
                    }
                },
                getHash: function() {
                    return s.default.getHash()
                },
                changeHash: function(t, e) {
                    this.isInitialized() && s.default.getHash() !== t && s.default.updateHash(t, e)
                },
                handleHashChange: function() {
                    this.scrollTo(this.getHash())
                },
                unmount: function() {
                    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange)
                }
            };
            e.default = a
        },
        1093: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                    }
                    return t
                },
                r = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                s = c(i(7294)),
                a = c(i(7606)),
                o = c(i(2628)),
                l = c(i(5697)),
                h = c(i(9678));

            function c(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var u = {
                to: l.default.string.isRequired,
                containerId: l.default.string,
                container: l.default.object,
                activeClass: l.default.string,
                spy: l.default.bool,
                horizontal: l.default.bool,
                smooth: l.default.oneOfType([l.default.bool, l.default.string]),
                offset: l.default.number,
                delay: l.default.number,
                isDynamic: l.default.bool,
                onClick: l.default.func,
                duration: l.default.oneOfType([l.default.number, l.default.func]),
                absolute: l.default.bool,
                onSetActive: l.default.func,
                onSetInactive: l.default.func,
                ignoreCancelEvents: l.default.bool,
                hashSpy: l.default.bool,
                saveHashHistory: l.default.bool,
                spyThrottle: l.default.number
            };
            e.default = function(t, e) {
                var i = e || o.default,
                    l = function(e) {
                        function o(t) {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, o);
                            var e = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" !== typeof e && "function" !== typeof e ? t : e
                            }(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, t));
                            return c.call(e), e.state = {
                                active: !1
                            }, e
                        }
                        return function(t, e) {
                            if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(o, e), r(o, [{
                            key: "getScrollSpyContainer",
                            value: function() {
                                var t = this.props.containerId,
                                    e = this.props.container;
                                return t && !e ? document.getElementById(t) : e && e.nodeType ? e : document
                            }
                        }, {
                            key: "componentDidMount",
                            value: function() {
                                if (this.props.spy || this.props.hashSpy) {
                                    var t = this.getScrollSpyContainer();
                                    a.default.isMounted(t) || a.default.mount(t, this.props.spyThrottle), this.props.hashSpy && (h.default.isMounted() || h.default.mount(i), h.default.mapContainer(this.props.to, t)), a.default.addSpyHandler(this.spyHandler, t), this.setState({
                                        container: t
                                    })
                                }
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                a.default.unmount(this.stateHandler, this.spyHandler)
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = "";
                                e = this.state && this.state.active ? ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : this.props.className;
                                var i = n({}, this.props);
                                for (var r in u) i.hasOwnProperty(r) && delete i[r];
                                return i.className = e, i.onClick = this.handleClick, s.default.createElement(t, i)
                            }
                        }]), o
                    }(s.default.PureComponent),
                    c = function() {
                        var t = this;
                        this.scrollTo = function(e, r) {
                            i.scrollTo(e, n({}, t.state, r))
                        }, this.handleClick = function(e) {
                            t.props.onClick && t.props.onClick(e), e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault(), t.scrollTo(t.props.to, t.props)
                        }, this.spyHandler = function(e, n) {
                            var r = t.getScrollSpyContainer();
                            if (!h.default.isMounted() || h.default.isInitialized()) {
                                var s = t.props.horizontal,
                                    a = t.props.to,
                                    o = null,
                                    l = void 0,
                                    c = void 0;
                                if (s) {
                                    var u = 0,
                                        d = 0,
                                        p = 0;
                                    if (r.getBoundingClientRect) p = r.getBoundingClientRect().left;
                                    if (!o || t.props.isDynamic) {
                                        if (!(o = i.get(a))) return;
                                        var m = o.getBoundingClientRect();
                                        d = (u = m.left - p + e) + m.width
                                    }
                                    var f = e - t.props.offset;
                                    l = f >= Math.floor(u) && f < Math.floor(d), c = f < Math.floor(u) || f >= Math.floor(d)
                                } else {
                                    var g = 0,
                                        y = 0,
                                        x = 0;
                                    if (r.getBoundingClientRect) x = r.getBoundingClientRect().top;
                                    if (!o || t.props.isDynamic) {
                                        if (!(o = i.get(a))) return;
                                        var v = o.getBoundingClientRect();
                                        y = (g = v.top - x + n) + v.height
                                    }
                                    var _ = n - t.props.offset;
                                    l = _ >= Math.floor(g) && _ < Math.floor(y), c = _ < Math.floor(g) || _ >= Math.floor(y)
                                }
                                var b = i.getActiveLink();
                                if (c) {
                                    if (a === b && i.setActiveLink(void 0), t.props.hashSpy && h.default.getHash() === a) {
                                        var M = t.props.saveHashHistory,
                                            w = void 0 !== M && M;
                                        h.default.changeHash("", w)
                                    }
                                    t.props.spy && t.state.active && (t.setState({
                                        active: !1
                                    }), t.props.onSetInactive && t.props.onSetInactive(a, o))
                                }
                                if (l && (b !== a || !1 === t.state.active)) {
                                    i.setActiveLink(a);
                                    var S = t.props.saveHashHistory,
                                        E = void 0 !== S && S;
                                    t.props.hashSpy && h.default.changeHash(a, E), t.props.spy && (t.setState({
                                        active: !0
                                    }), t.props.onSetActive && t.props.onSetActive(a, o))
                                }
                            }
                        }
                    };
                return l.propTypes = u, l.defaultProps = {
                    offset: 0
                }, l
            }
        },
        7606: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n, r = i(3096),
                s = (n = r) && n.__esModule ? n : {
                    default: n
                },
                a = i(5236);
            var o = {
                spyCallbacks: [],
                spySetState: [],
                scrollSpyContainers: [],
                mount: function(t, e) {
                    if (t) {
                        var i = function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 66;
                            return (0, s.default)(t, e)
                        }((function(e) {
                            o.scrollHandler(t)
                        }), e);
                        o.scrollSpyContainers.push(t), (0, a.addPassiveEventListener)(t, "scroll", i)
                    }
                },
                isMounted: function(t) {
                    return -1 !== o.scrollSpyContainers.indexOf(t)
                },
                currentPositionX: function(t) {
                    if (t === document) {
                        var e = void 0 !== window.pageYOffset,
                            i = "CSS1Compat" === (document.compatMode || "");
                        return e ? window.pageXOffset : i ? document.documentElement.scrollLeft : document.body.scrollLeft
                    }
                    return t.scrollLeft
                },
                currentPositionY: function(t) {
                    if (t === document) {
                        var e = void 0 !== window.pageXOffset,
                            i = "CSS1Compat" === (document.compatMode || "");
                        return e ? window.pageYOffset : i ? document.documentElement.scrollTop : document.body.scrollTop
                    }
                    return t.scrollTop
                },
                scrollHandler: function(t) {
                    (o.scrollSpyContainers[o.scrollSpyContainers.indexOf(t)].spyCallbacks || []).forEach((function(e) {
                        return e(o.currentPositionX(t), o.currentPositionY(t))
                    }))
                },
                addStateHandler: function(t) {
                    o.spySetState.push(t)
                },
                addSpyHandler: function(t, e) {
                    var i = o.scrollSpyContainers[o.scrollSpyContainers.indexOf(e)];
                    i.spyCallbacks || (i.spyCallbacks = []), i.spyCallbacks.push(t), t(o.currentPositionX(e), o.currentPositionY(e))
                },
                updateStates: function() {
                    o.spySetState.forEach((function(t) {
                        return t()
                    }))
                },
                unmount: function(t, e) {
                    o.scrollSpyContainers.forEach((function(t) {
                        return t.spyCallbacks && t.spyCallbacks.length && t.spyCallbacks.splice(t.spyCallbacks.indexOf(e), 1)
                    })), o.spySetState && o.spySetState.length && o.spySetState.splice(o.spySetState.indexOf(t), 1), document.removeEventListener("scroll", o.scrollHandler)
                },
                update: function() {
                    return o.scrollSpyContainers.forEach((function(t) {
                        return o.scrollHandler(t)
                    }))
                }
            };
            e.default = o
        },
        2628: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                    }
                    return t
                },
                r = o(i(4259)),
                s = o(i(3200)),
                a = o(i(4592));

            function o(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var l = {},
                h = void 0;
            e.default = {
                unmount: function() {
                    l = {}
                },
                register: function(t, e) {
                    l[t] = e
                },
                unregister: function(t) {
                    delete l[t]
                },
                get: function(t) {
                    return l[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0]
                },
                setActiveLink: function(t) {
                    return h = t
                },
                getActiveLink: function() {
                    return h
                },
                scrollTo: function(t, e) {
                    var i = this.get(t);
                    if (i) {
                        var o = (e = n({}, e, {
                                absolute: !1
                            })).containerId,
                            l = e.container,
                            h = void 0;
                        h = o ? document.getElementById(o) : l && l.nodeType ? l : document, e.absolute = !0;
                        var c = e.horizontal,
                            u = r.default.scrollOffset(h, i, c) + (e.offset || 0);
                        if (!e.smooth) return a.default.registered.begin && a.default.registered.begin(t, i), h === document ? e.horizontal ? window.scrollTo(u, 0) : window.scrollTo(0, u) : h.scrollTop = u, void(a.default.registered.end && a.default.registered.end(t, i));
                        s.default.animateTopScroll(u, e, t, i)
                    } else console.warn("target Element not found")
                }
            }
        },
        9765: function(t, e) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = {
                defaultEasing: function(t) {
                    return t < .5 ? Math.pow(2 * t, 2) / 2 : 1 - Math.pow(2 * (1 - t), 2) / 2
                },
                linear: function(t) {
                    return t
                },
                easeInQuad: function(t) {
                    return t * t
                },
                easeOutQuad: function(t) {
                    return t * (2 - t)
                },
                easeInOutQuad: function(t) {
                    return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
                },
                easeInCubic: function(t) {
                    return t * t * t
                },
                easeOutCubic: function(t) {
                    return --t * t * t + 1
                },
                easeInOutCubic: function(t) {
                    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
                },
                easeInQuart: function(t) {
                    return t * t * t * t
                },
                easeOutQuart: function(t) {
                    return 1 - --t * t * t * t
                },
                easeInOutQuart: function(t) {
                    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
                },
                easeInQuint: function(t) {
                    return t * t * t * t * t
                },
                easeOutQuint: function(t) {
                    return 1 + --t * t * t * t * t
                },
                easeInOutQuint: function(t) {
                    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
                }
            }
        },
        4259: function(t, e) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = function(t, e) {
                for (var i = t.offsetTop, n = t.offsetParent; n && !e(n);) i += n.offsetTop, n = n.offsetParent;
                return {
                    offsetTop: i,
                    offsetParent: n
                }
            };
            e.default = {
                updateHash: function(t, e) {
                    var i = 0 === t.indexOf("#") ? t.substring(1) : t,
                        n = i ? "#" + i : "",
                        r = window && window.location,
                        s = n ? r.pathname + r.search + n : r.pathname + r.search;
                    e ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s)
                },
                getHash: function() {
                    return window.location.hash.replace(/^#/, "")
                },
                filterElementInContainer: function(t) {
                    return function(e) {
                        return t.contains ? t != e && t.contains(e) : !!(16 & t.compareDocumentPosition(e))
                    }
                },
                scrollOffset: function(t, e, n) {
                    if (n) return t === document ? e.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : "static" !== getComputedStyle(t).position ? e.offsetLeft : e.offsetLeft - t.offsetLeft;
                    if (t === document) return e.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
                    if ("static" !== getComputedStyle(t).position) {
                        if (e.offsetParent !== t) {
                            var r = i(e, (function(e) {
                                    return e === t || e === document
                                })),
                                s = r.offsetTop;
                            if (r.offsetParent !== t) throw new Error("Seems containerElement is not an ancestor of the Element");
                            return s
                        }
                        return e.offsetTop
                    }
                    if (e.offsetParent === t.offsetParent) return e.offsetTop - t.offsetTop;
                    var a = function(t) {
                        return t === document
                    };
                    return i(e, a).offsetTop - i(t, a).offsetTop
                }
            }
        }
    },
    function(t) {
        var e = function(e) {
            return t(t.s = e)
        };
        t.O(0, [774, 179], (function() {
            return e(1780), e(880)
        }));
        var i = t.O();
        _N_E = i
    }
]);